<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>xv6-lab-trap</title>
    <link href="/2024/06/08/xv6-lab-trap/"/>
    <url>/2024/06/08/xv6-lab-trap/</url>
    
    <content type="html"><![CDATA[<p>6.s081 fa20 lab4：一个很有趣，码量不大但是烧脑的lab</p><span id="more"></span><h1 id="traps"><a href="#traps" class="headerlink" title="traps"></a>traps</h1><h2 id="调试小技巧"><a href="#调试小技巧" class="headerlink" title="调试小技巧"></a>调试小技巧</h2><p><a href="https://blog.csdn.net/qq_45520114/article/details/120482127">MIT 6.S081 xv6 调试指北_xv6 调试 exec-CSDN博客</a></p><p>调试用户程序，可以在<code>exec</code>打一个断点，原理是使用sh调试时，都是用exec执行二进制程序，所以可以在这里打断点</p><p>然后在sh里面输入用户程序，在gdb里面调试，但是我试图 <code>file user/_alarmtest</code> 显示<code>can not access memory</code>，待解决</p><p>测试方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 自动化测试：make grade 可以获得得分情况</span><br>make grade<br><br><span class="hljs-comment"># 或者可以使用 进行单个测试</span><br>./grade-具体lab名字 part名字<br></code></pre></td></tr></table></figure><h2 id="backtrace"><a href="#backtrace" class="headerlink" title="backtrace"></a>backtrace</h2><p>此实验目的是panic时，通过backtrace打印出程序调用堆栈</p><p><strong>最终效果</strong>如下，打印出了地址，但是还需要你手动转换</p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202406071152091.png" alt="image-20240607115224059"></p><p>手动转换：</p><p><code>addr2line</code>是一个命令行工具，用于将地址转换成源码文件名和行号。它通常用于调试内核或其他程序时，根据地址查找对应的源代码位置。这个工具对于理解程序在运行时遇到的错误位置非常有用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">addr2line -e kernel/kernel ...<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202406071154925.png" alt="image-20240607115408884"></p><p>最后有一个 Challenge：让你不止打印出地址，而是打印出addr2line的内容</p><blockquote><p>xv6 默认的编译模式会在生成的可执行文件中，含有调试信息，其中包含了所有符号的名称以及其对应的地址。理论上 backtrace 可以做类似 addr2line 的操作，通过解析可执行文件本身附带的调试信息获得地址对应的源码文件以及行号。这里跳过该 challenge</p></blockquote><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202406071155349.png" alt="img"></p><p>通过这个栈的布局来写程序，可以看一下Lec5</p><p>你只需要通过fp来读出ra，然后让fp等于他的上一个fp</p><p>那么在哪里结束？xv6的stack至多为1页，所以读到该页的最上面就ok了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">backtrace</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;backtrace\n&quot;</span>);<br>  uint64 fp = r_fp();<br>  uint64 top = PGROUNDUP(fp);<br>  <span class="hljs-comment">// uint64 base = PGROUNDDOWN(fp);</span><br>  <span class="hljs-keyword">while</span>(fp&lt;top)&#123; <span class="hljs-comment">//注意这里不能=top，不然会有一个越界访问，你想一想栈上面的fp的ra，应该指向的是哪里？</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>,*(uint64*)(fp<span class="hljs-number">-8</span>));<br>    fp = *(uint64*)(fp<span class="hljs-number">-16</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h2><p>每当程序消耗了CPU时间达到n个 tick，内核应当使应用程序函数<code>fn</code>被调用，当<code>fn</code>返回时，应用应当在它离开的地方恢复执行</p><p>如果一个程序调用了<code>sigalarm(0, 0)</code>，系统应当停止生成周期性的报警调用</p><h3 id="test-0"><a href="#test-0" class="headerlink" title="test 0"></a>test 0</h3><p>实现在tick达到设定的值之后，调用给定的函数</p><h4 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h4><p>初次尝试，我想的是把用户的 handler 地址翻译为他在 物理内存中的地址，时间到了的时候就直接通过这个物理地址（函数指针）来调用，为什么不行呢？</p><ul><li>你在内核态能够执行用户态的代码吗？内核和用户的地址的映射是不一样的</li><li>调用函数，函数的栈那些都是用户栈，你怎么办？</li></ul><p>调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">p-&gt;sigalarm_tick += <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(p-&gt;sigalarm_tick == p-&gt;sigalarm_interval)<br>&#123;<br>  p-&gt;sigalarm_handler();<br>&#125;<br></code></pre></td></tr></table></figure><p>报错</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span>scause <span class="hljs-number">0x000000000000000c</span><br>sepc=<span class="hljs-number">0x0000000000000000</span> stval=<span class="hljs-number">0x0000000000000000</span><br></code></pre></td></tr></table></figure><p>根据sepc来看，就是调用的时候出错了</p><p>所以只能转向trap的本身，修改 trapframe 中的 epc 寄存器，来让这个clockintr返回的时候直接返回到我们的handler代码，这样就调用了一次处理函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">usertrap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    ...<br>    <span class="hljs-keyword">if</span>(which_dev == <span class="hljs-number">2</span>)<br>    &#123;<br>        p-&gt;sigalarm_tick += <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(p-&gt;sigalarm_tick == p-&gt;sigalarm_interval )<br>        &#123;<br>            p-&gt;trapframe-&gt;epc = (uint64)p-&gt;sigalarm_handler;<br>            p-&gt;sigalarm_tick = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="test1"><a href="#test1" class="headerlink" title="test1"></a>test1</h3><p>上面的做法有个问题，会导致test1失败</p><p>由于每次使用 ecall 进入中断处理前，都会使用 trapframe 存储当时的寄存器信息，包括时钟中断。因此 trapframe 在每次中断前后都会产生变换，如果要恢复状态，需要额外存储 handler 执行前的 trapframe（即更改返回值为 handler 前的 trapframe），这样，无论中间发生多少次时钟中断或是其他中断，保存的值都不会变。</p><p>好了，现在我们的目的就是从用户态程序的角度来说，保证调用 handler 函数前后的状态没有变化（对他而言是透明的），必须确保完成报警处理程序后返回到用户程序最初被计时器中断的指令执行。必须确保寄存器内容恢复到中断时的值，以便用户程序在报警后可以不受干扰地继续运行</p><p><strong>思考问题</strong></p><ol><li><p>在test0当中，从内核中返回的时候返回地址是periodic，在periodic执行结束之后conut加一，循环中可以判断出count不为0了之后break并且输出提示信息。test0当中并未直接调用periodie，请问这个过程中是怎么从periodic跳转到test0的循环当中继续执行的？</p></li><li><p>要保存哪些寄存器，全部保存吗？</p><p>我们修改了epc为handler之后，是哪一个函数会破坏我们trapframe中保存的值，首先我们知道的是要保存原来的epc，因为我们修改了epc，然后其他的trapframe里面的寄存器此时都还是原样。在这时我们返回到用户态，此时寄存器除了epc之外都被trapframe恢复为原样了。实际上在这一步，我们省去了call handler之前的寄存器保存工作，因为我们直接到了调用函数部分，所以需要事先保存caller-saved寄存器，其实这应该是编译器来做的东西，但是由于我们自定义修改了epc，所以需要我们自己来做。然后handler最后通过系统调用sigreturn进入内核，我们把保存的寄存器恢复</p></li><li><p>如果在handler执行，以及sigreturn之前发生了时钟中断，并且又达到了handler处理的间隔，怎么办？这种情况你仅仅保存caller-saved寄存器还可以吗？</p></li></ol><p>大致流程：</p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202406140933348.png"></p><ol><li>在你运行代码的时候，时不时的会产生定时器中断，进入内核。当clockintr调用n次，达到设置的警告</li><li>内核在处理定时器中断时，我们修改其epc，使其返回到用户态 handler 函数</li><li>回到handler函数继续执行，根据代码其内部调用 sigreturn</li><li>由于 sigreturn 是一个 syscall，再通过syscall陷入内核</li><li>此时到了内核，我们怎么想办法此时是返回到被打断的地方重新执行</li></ol><p>实现：</p><ul><li>proc 结构体新增一个字段：<code>struct trapframe *alarmframe;</code>，用来保存clockintr时的 trapframe，方便后续返回</li><li>然后对于这个 alarmframe 要进行页分配（allocproc函数）以及页回收（freeproc函数）</li><li>在第2步，返回之前，保存此时的 trapframe 做一个快照，方便后面恢复</li><li>在第4步，恢复快照，恢复到最初第1步被打断的地方</li></ul><p>完成之后test1 pass</p><h3 id="test2：报错"><a href="#test2：报错" class="headerlink" title="test2：报错"></a>test2：报错</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lasso">test2 start<br><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span>..alarm!<br>alarm!<br>test2 failed: alarm handler called more than once<br></code></pre></td></tr></table></figure><p>分析一下为什么报这个错误</p><p>由于<code>slow_handler</code>中的循环使其运行缓慢，如果此期间发生另一个闹钟中断，将再次触发处理程序</p><p>所以我们要保证：在前一个闹钟处理程序完成之前，闹钟处理程序不应该再次被调用。</p><p>在 proc.h 添加一个 in_handler 字段，在调用handler之前判断，该字段是否为0表示没有被占用，从此才能调用</p><p>其实有点类似上了一个锁的过程。</p><p><strong>思考：如果在执行handler时关时钟中断是否可行呢？</strong></p><p>要注意sigreturn的返回值应该是 p-&gt;trapframe-&gt;a0</p><p>测试通过：</p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202406071117954.png" alt="image-20240607111749857"></p><p>总结：</p><p>这个lab也不能算完全独立完成，中间也参考了别人的实现。有些实现还不够优雅，比如说对于alarmframe，不应该直接复制trapframe，有些寄存器你是不用保存的。你要保证的是调用handler前后，所有寄存器状态没有改变。这个地方其实只用保存caller-saved寄存器就可以了，然后调用handler，在sigretun的时候恢复这些寄存器。</p><p>还有个问题没有想清楚，就是到底是在哪一步会破坏寄存器？是在 handler吧</p><p>还需要理一下，什么是编译器自动保存的，什么是trap保存的，这样不会多保存寄存器。但是对于这样一个os，其实多保存寄存器带来的开销是可以忽略的，而且思维难度会降低很多。。</p><p><strong>一个问题，需要自己的回答</strong></p><p>请问大家一个问题，我在做 fa20 的 lab4 traps 实验的 alarm 部分，已经通过测试了但还是有点疑惑</p><p>在 test0 当中（此时还没有实现 sigreturn 保存寄存器，sigreturn 只是简单的 return 0），这部分我的实现是：修改从内核中返回的时候 epc 寄存器的值为 handler函数（periodic）的地址，根据 periodic 代码，在periodic执行结束之后 count+1</p><p>也就是我一直在 test0 的循环中，然后某时候要触发对 periodic 的调用，test0 的循环中可以判断出 count 不为 0 了之后 break 并且输出提示信息。那么触发 periodic 调用之后我又是怎么返回到这个循环里面的呢？</p><p>我本来以为是修改 epc 之后返回到用户态，然后就一直往下开始顺着 pc = epc 这条执行流执行，然后后面重新进入了test0，但是从输出可以看到test0只被执行了一次，所以不太明白这个地方</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>算法笔记-杂乱版持续更新</title>
    <link href="/2024/05/31/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E6%9D%82%E4%B9%B1%E7%89%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    <url>/2024/05/31/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E6%9D%82%E4%B9%B1%E7%89%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<p>算法模板：数学、二分、双指针、单调栈、单调队列、字典树、Z函数、dp、差分、堆、线段树</p><span id="more"></span><h1 id="蓝桥杯省赛考点"><a href="#蓝桥杯省赛考点" class="headerlink" title="蓝桥杯省赛考点"></a>蓝桥杯省赛考点</h1><p>统计结果如下：</p><p>知识点    出现次数<br>模拟    17<br>贪心    16<br>DP    14<br>枚举    11<br>数学    9<br>二分    8<br>数论    7<br>DFS    5<br>前缀和    5<br>推公式    5<br>快速幂    4<br>差分    4<br>双指针    4<br>状态压缩DP    4<br>思维题    4<br>BFS    3<br>树形DP    3<br>递推    3<br>字符串处理    3<br>排序    2<br>搜索    2<br>剪枝    2<br>递归    2<br>动态规划    2<br>分类讨论    2<br>线性DP    2<br>最大公约数    2<br>二叉树    2<br>背包问题    2<br>找规律    2<br>并查集    2<br>哈希表    2<br>分解质因数    2<br>堆    2<br>结论题    1<br>树的直径    1<br>斐波那契数列性质    1<br>龟速乘    1<br>树状数组    1<br>归并排序    1<br>矩阵乘法    1<br>哈希    1<br>区间DP    1<br>辗转相减法    1<br>图论    1<br>环    1<br>置换群    1<br>完全背包问题    1<br>扫描线    1<br>线段树    1<br>Flood Fill    1<br>均值不等式    1<br>滑动窗口    1<br>平衡树    1<br>STL Set    1<br>IDA*    1<br>日期问题    1<br>贡献法    1<br>Bellman-Ford    1<br>SPFA    1<br>Dijkstra    1<br>组合计数    1<br>栈    1<br>括号序列    1<br>博弈论    1<br>构造    1<br>图的遍历    1<br>概率论    1<br>数学期望    1<br>逆元    1<br>快速选择    1<br>链表    1<br>排序不等式    1<br>多路归并    1<br>整数分块    1<br>整除    1<br>单调队列    1<br>欧拉函数    1<br>状态机    1<br>区间合并    1</p><h1 id="蓝桥杯官方刷题"><a href="#蓝桥杯官方刷题" class="headerlink" title="蓝桥杯官方刷题"></a>蓝桥杯官方刷题</h1><p><a href="https://www.lanqiao.cn/problems/17118/learning/">0走方格 - 蓝桥云课 (lanqiao.cn)</a></p><h1 id="python刷算法技巧-知识"><a href="#python刷算法技巧-知识" class="headerlink" title="python刷算法技巧/知识"></a>python刷算法技巧/知识</h1><p><a href="https://blog.csdn.net/weixin_74850661/article/details/136595749">python 蓝桥杯之常用的库_蓝桥杯python库-CSDN博客</a></p><p><a href="https://blog.csdn.net/xia_yanbing/article/details/114641646">【蓝桥杯】Python自带编辑器IDLE的使用教程_python蓝桥杯编译器-CSDN博客</a></p><p><a href="https://blog.csdn.net/m0_67601373/article/details/124046655">蓝桥杯 python组IDLE的使用方法_蓝桥杯能打开idle自带的文档吗-CSDN博客</a></p><p>F1打开帮助文档！！！</p><ol><li><p>map事实上是返回一个迭代器</p></li><li><p>注意如果在函数里面需要使用一个全局变量</p><ul><li><p> <code>global  ans</code></p></li><li><p> <code>nonlocal ans</code></p></li><li><p> 先像上面这两种方法声明一下</p></li></ul></li></ol><ol start="3"><li><p>区分 <code>t[::-1]</code>和 <code>t[:-1]</code></p><ul><li>前者：用于反转序列，返回序列的反向版本</li><li>后者： 用于获取序列的子序列，该子序列包含从序列的第一个元素到倒数第二个元素（不包括最后一个元素），没有反转</li></ul></li><li><p>格式化输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 格式化输出十进制</span><br>decimal_format = <span class="hljs-string">&quot;The number in decimal is: %d&quot;</span> % number<br><span class="hljs-built_in">print</span>(decimal_format)  <span class="hljs-comment"># 输出: The number in decimal is: 255</span><br></code></pre></td></tr></table></figure></li><li><p>python正无穷：inf，需要先从math引入</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-keyword">from</span> <span class="hljs-built_in">math</span> <span class="hljs-keyword">import</span> inf<br></code></pre></td></tr></table></figure></li><li><p><code>isqrt(mid//i) 比 int(sqrt(mid//i))</code> 快很多吗，大概五倍，也要从math库引入</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-keyword">from</span> <span class="hljs-built_in">math</span> <span class="hljs-keyword">import</span> inf<br></code></pre></td></tr></table></figure></li><li><p><code>join</code>的使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27; &#x27;</span>.join(i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>,path)))<br></code></pre></td></tr></table></figure></li><li><p>python里面自己来调用 min，max很慢，如果觉得很慢可以自己拆开了用if，else来写。那么怎么定义”很慢“呢？</p></li><li><p><strong>输入</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#读取n个数 </span><br>a = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br></code></pre></td></tr></table></figure></li><li><p>输入数据太多比如10^5以上建议用 sys.stdin</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys <br><span class="hljs-built_in">input</span> = <span class="hljs-keyword">lambda</span> : sys.stdin.readline().strip()<br></code></pre></td></tr></table></figure></li><li><p><code>s.sort()</code> 和 <code>sorted(s)</code> 的区别：（一般习惯用<code>s.sort()</code>）</p><p>注意s.sort() 直接在s里面修改，不会返回一个新的</p><p>但是 sorted(s) 不会在s里面修改，而是返回一个新的</p></li><li><p>创建多维数组：</p><p>比如 n*m 的数组，注意先 m 后 n</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [[ <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br></code></pre></td></tr></table></figure><p>创建一个a * b *c 的数组，初始化为全0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">f = [[[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(c)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(b)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>()]<br></code></pre></td></tr></table></figure></li><li><p>min(列表1的一部分，列表1的另一部分)是不可以的</p><p>在Python中，<code>min</code> 函数不能直接接受两个列表作为参数，然后比较这两部分来决定最小值。<code>min</code> 函数期望的是一个可迭代对象，从中它会找到最小值。如果你尝试将两个列表作为参数传递给 <code>min</code>，你将得到一个类型错误，因为 <code>min</code> 函数不知道如何比较两个列表。</p></li><li><p>手动实现上取整：</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">(x+mid-<span class="hljs-number">1</span>)//mid <span class="hljs-comment">#这一步，实现上取整，怎么实现的？ </span><br>                <span class="hljs-comment"># 上取整，其实可以测试一下 (x-1) // mid</span><br>                <span class="hljs-comment"># 如果 x是mid的倍数，那么这个结果就应该加1（恢复原样）</span><br>                <span class="hljs-comment"># 如果 x不是mid的倍数，那么这个结果也应该加一（上取整）</span><br></code></pre></td></tr></table></figure><ol start="15"><li><p>python自带的bisect使用：</p><p>bisect_left：（最左）如果要查找 最左边的，使用bisect_left 找如果要插入，应该插入的最左端位置，如果列表中已经存在该元素，它将返回该元素在列表中的最左侧位置</p><p>bisect_right：（最右）返回的是插入点的右侧位置，即如果列表中已经存在该元素，它将返回该元素在列表中的最右侧位置</p><p>bisect：<code>bisect</code>是<code>bisect_right</code>的别名，所以它的使用方式与<code>bisect_right</code>完全相同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bisect <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 有序列表</span><br>a = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>]<br><br><span class="hljs-comment"># 要插入的元素</span><br>x = <span class="hljs-number">5</span><br><br><span class="hljs-comment"># 使用bisect_left找到插入点</span><br>index = bisect.bisect_left(a, x)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;插入点的索引:&quot;</span>, index)<br><span class="hljs-comment"># 输出: 插入点的索引: 2</span><br><br>index = bisect.bisect_right(a, x)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;插入点的索引:&quot;</span>, index)  <span class="hljs-comment"># 输出: 插入点的索引: 3</span><br></code></pre></td></tr></table></figure></li><li><p>其实列表就是栈，Python中列表的实现是基于链表来的，python中的列表里的pop（）可以实现出栈，append（）实现入栈，而这两个操作的时间复杂度都是o（1），所以列表本身就是一个栈，实现队列的话用pop（0）实现出队，append（）实现入队，只不过这里的pop（0）的时间复杂度是<strong>o（n）</strong></p><p>所以队列最好还是用deque的popleft和append，这两个时间复杂度是o（1）</p><p>使用队列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> collections<br>q = collections.deque()<br><br><span class="hljs-comment">#左端出队</span><br>q.pop_left()<br><span class="hljs-comment">#右端入队</span><br>q.append()<br><br><span class="hljs-comment">#判断队列是否为空</span><br><span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li><li><p>熟悉一下文件操作，可能需要你打开文件？</p><p>逆元，博弈</p></li><li><p>排序：按照某个key排序</p><ul><li><p>按照元组的第二个元素排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = [(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">4</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">5</span>, <span class="hljs-number">0</span>)]<br>arr.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure></li><li><p>按照字典的某个键排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用 sort 方法按字典的 &#x27;age&#x27; 键排序</span><br>arr.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-string">&#x27;age&#x27;</span>])<br></code></pre></td></tr></table></figure></li></ul></li><li><p>千万不要像这样初始化数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">nums = [[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]]*n<br></code></pre></td></tr></table></figure><p>使用列表推导式而不是乘法的原因是，乘法会创建对同一个列表对象的多个引用，这可能会导致意外的副作用。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">python复制代码<span class="hljs-comment"># 错误的方法：使用乘法</span><br>n = <span class="hljs-number">5</span><br>my_list = [[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]] * n<br><br><span class="hljs-comment"># 修改一个元素会影响所有元素，因为它们引用的是同一个对象</span><br>my_list[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(my_list)  <span class="hljs-comment"># 输出 [[1, 0], [1, 0], [1, 0], [1, 0], [1, 0]]</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>[[0, 0]] * n</code> 会创建一个包含对同一个 <code>[0, 0]</code> 列表的 <code>n</code> 个引用的列表。因此，修改其中一个元素会导致所有元素都发生变化。</p><p>因此，推荐使用列表推导式来避免这种问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">python复制代码n = <span class="hljs-number">5</span><br>my_list = [[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br><br><span class="hljs-comment"># 修改一个元素不会影响其他元素</span><br>my_list[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(my_list)  <span class="hljs-comment"># 输出 [[1, 0], [0, 0], [0, 0], [0, 0], [0, 0]]</span><br></code></pre></td></tr></table></figure><p>这样可以确保每个元素都是独立的 <code>[0, 0]</code> 列表，不会相互影响。</p></li><li><p>python对部分数组排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">tmp[i:j+<span class="hljs-number">1</span>] = <span class="hljs-built_in">sorted</span>(tmp[i:j+<span class="hljs-number">1</span>])<br><span class="hljs-comment"># tmp[i:j+1].sort()是错误的，不会作用于原数组</span><br><span class="hljs-comment"># 创建的是原数组的一个切片（即一个新的列表），并对这个新的列表进行排序，而不会影响原数组</span><br></code></pre></td></tr></table></figure></li><li><p>ascii转字符串：<code>chr()</code></p><p>字符串转ascii：<code>ord()</code></p></li><li><p>四舍五入: round(n)</p></li></ol><h1 id="由数据范围反推算法复杂度以及算法内容"><a href="#由数据范围反推算法复杂度以及算法内容" class="headerlink" title="由数据范围反推算法复杂度以及算法内容"></a>由数据范围反推算法复杂度以及算法内容</h1><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202404051525946.png" alt="image-20240405152508844"></p><h1 id="1-数学"><a href="#1-数学" class="headerlink" title="1.数学"></a>1.数学</h1><h2 id="1-2试除法判定质数"><a href="#1-2试除法判定质数" class="headerlink" title="1.2试除法判定质数"></a>1.2试除法判定质数</h2><p>质数： &gt; 1且约数只包含1 和本身</p><p>性质： d | n， (n/d) | n</p><p>因此n的所有约数其实都是成对出现的，因此我们可以每次只枚举每一对里面较小的那一个，也就是满足 d &lt;= n/d，整理一下就得到 d &lt;= 根号n，因此我们只需要枚举到根号n就可以，从而降低了时间复杂度</p><p>n中最多只包含一个大于sqrt(n)的质因子，如果有两个，相乘不就 &gt; n了吗</p><h2 id="快速求因数"><a href="#快速求因数" class="headerlink" title="快速求因数"></a>快速求因数</h2><p>只用从 $1$ 到 $\sqrt{n}$ 枚举因数，另一个因数就等于 $n \div 当前因数$  ，必被整除的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums1:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,isqrt(x)+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> x%i == <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">dict</span>[i] += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> i*i &lt; x: <span class="hljs-comment"># 等于x的话就重复计算了</span><br>                <span class="hljs-built_in">dict</span>[x//i]+=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>快速排序</strong></p><ol><li>确定分界点，q[(l+r)//2] or q[random]</li><li>调整区间： 让所有 &lt;=x 的在x左边，&gt;= x的在x右边</li><li>递归处理左右区间</li></ol><p>最难实现的就是第二步了：</p><ul><li><p>容易想到但是不优美的做法：</p><p>可以开两个额外的数组，把 &lt;= x的放在一个，&gt;=x 的放在另一个，最后把他们俩拼起来</p></li><li><p>优雅做法：</p><ul><li>用两个指针，其中 i 指向第一个，j 指向最后一个</li><li>遇到 &lt;=x 的数，i++，直到遇到第一个 &gt;x 的数，停下</li><li>遇到 &gt;=x 的数，j–，直到遇到第一个 &lt;x 的数，停下</li><li>交换 i 和 j 对应的数</li><li>循环直到 i &gt; j</li></ul></li></ul><h2 id="1-3离散化"><a href="#1-3离散化" class="headerlink" title="1.3离散化"></a>1.3离散化</h2><p>数的值域很大，但是范围不大（稀疏），需要用到数的值做下标，但是又不可能开那么大的全局数组，于是需要离散化：把数值映射</p><p>需要解决的问题：</p><ul><li>去重（先排序后unique去重）</li><li>如何算出 x 离散化之后的值（二分）</li></ul><p>一般来说 10的五次方以内差不多</p><p>把下标在 i 的值，映射到一个数</p><h2 id="1-4模运算"><a href="#1-4模运算" class="headerlink" title="1.4模运算"></a>1.4模运算</h2><p><a href="https://leetcode.cn/circle/discuss/mDfnkW/">分享丨模运算的世界：当加减乘除遇上取模 - 力扣（LeetCode）</a></p><p>加法和乘法的取模：<br>$$<br>(a+b)\ mod\ m=((a\ mod\ m)+(b\ mod\ m))\ mod\ m<br>$$</p><p>$$<br>(a <em>b)\ mod\ m=((a\ mod\ m)</em>(b\ mod\ m))\ mod\ m<br>$$</p><p>负数的取模： $x&lt;0$ ，$y&gt;=0$，则 $x \equiv y\ mod\ m$ 等价于<br>$$<br>x\ mod\ m+m=y\ mod\ m<br>$$</p><p>除法的取模：如果 𝑝 是一个质数，𝑎是 𝑏的倍数且 𝑏和 𝑝互质（𝑏不是 𝑝的倍数），那么有<br>$$<br>\frac{a}{b}\ mod\ p =(a*b^{p-2})\ mod\ p<br>$$</p><p>总结<br>代码实现时，上面的加减乘除通常是这样写的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">MOD = <span class="hljs-number">1_000_000_007</span><br><br>// 加<br>(a + b) % MOD<br><br>// 减<br>(a - b + MOD) % MOD<br><br>// 乘<br>a * b % MOD<br><br>// 多个数相乘，要步步取模，防止溢出<br>a * b % MOD * c % MOD<br><br>// 除（MOD 是质数且 b 不是 MOD 的倍数）<br>a * qpow(b, MOD - <span class="hljs-number">2</span>, MOD) % MOD<br></code></pre></td></tr></table></figure><h2 id="1-5-gcd-与-lcm"><a href="#1-5-gcd-与-lcm" class="headerlink" title="1.5 gcd 与 lcm"></a>1.5 gcd 与 lcm</h2><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405312321398.png" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">gcd</span>(<span class="hljs-params">a,b</span>):<br>  <span class="hljs-keyword">if</span> a&lt;b:<br>    a,b=b,a<br>  <span class="hljs-keyword">while</span> b!=<span class="hljs-number">0</span>:<br>    a,b=b,a%b<br>  <span class="hljs-keyword">return</span> a<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lcm</span>(<span class="hljs-params">a,b</span>):<br><span class="hljs-keyword">return</span> (a*b)/gcd(a,b);<br><br></code></pre></td></tr></table></figure><p>gcd(a,b) = gcd(b,a)</p><h1 id="2-双指针-变长滑动窗口"><a href="#2-双指针-变长滑动窗口" class="headerlink" title="2.双指针 变长滑动窗口"></a>2.双指针 变长滑动窗口</h1><p>两数之和，三数之和：</p><ul><li>什么时候可以使用双指针？<ul><li>双指针要求一定要排序，排序之后元素对应的下标就变了</li><li>因此如果题目要求返回元素数值我们就可以使用双指针</li></ul></li><li>使用hash表<ul><li>题目要求返回下标时</li></ul></li></ul><p>双指针要满足单调性</p><p>在什么时候移动指针</p><p>什么时候记录答案要搞清楚</p><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/subarray-product-less-than-k/description/">713. 乘积小于 K 的子数组 - 力扣（LeetCode）</a></p><p>[3. 无重复字符的最长子串 - 力扣（LeetCode）](</p><h1 id="3-二分"><a href="#3-二分" class="headerlink" title="3.二分"></a>3.二分</h1><h2 id="红蓝染色法理解二分"><a href="#红蓝染色法理解二分" class="headerlink" title="红蓝染色法理解二分"></a>红蓝染色法理解二分</h2><p>我们以寻找到 &gt;= x 的第一个下标来举例：</p><p>你的条件可以灵活定义</p><p>用<strong>红色</strong>表示不满足条件的，<strong>蓝色</strong>表示满足条件的，<strong>白色</strong>表示不确定</p><p><strong>核心</strong>：</p><ul><li>你要维护的区间内的都是没有染色的，<strong>区间的定义是未染色的范围，而不是答案的范围！！！</strong></li><li><strong>l 和 r 的初始值怎么定义？</strong>看你初始的不知道如何染色的区间范围（白色）是多少，以及你二分是使用闭区间 or 开区间 or 左闭右开 哪种策略编写的，据此定下来你的 l 和 r值</li><li><strong>循环条件如何终止？</strong>当你的区间不为空的时候循环</li><li>中间判断了之后 l，r 与 m 的关系应该怎么变化：看你想要寻找什么</li><li>最后答案应该怎么return：在找第一个 &gt;= x 的情况下你要return的应该是蓝色（true）的第一个</li></ul><p><strong>mid</strong> 表示正在询问的数 </p><p>闭区间写法下我们如何取得答案？</p><p>有一个循环不变量保持着：</p><ul><li>L-1始终是红色</li><li>R+1始终是蓝色</li><li>那么答案其实就是 蓝色的第一个，也就是L或者R+1</li></ul><h2 id="多种写法"><a href="#多种写法" class="headerlink" title="多种写法"></a>多种写法</h2><p><strong>一般求什么就二分什么</strong></p><p>三种写法：推荐开区间，中间l,r,m之间的判断关系简单</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 找 &gt;= target 的第一个</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lower_bound</span>(<span class="hljs-params">nums,target</span>):<br>    l = -<span class="hljs-number">1</span><br>    r = <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-comment">#开区间写法</span><br>    <span class="hljs-comment"># mid 满足要求时，更新的是谁就返回谁</span><br>    <span class="hljs-keyword">while</span> l+<span class="hljs-number">1</span> &lt; r: <span class="hljs-comment">#区间不为空</span><br>        m = (l+r) // <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[m] &lt; target: <span class="hljs-comment">#false</span><br>            l =  m   <span class="hljs-comment">#(m,r)</span><br>        <span class="hljs-keyword">else</span>:<br>            r = m <span class="hljs-comment">#(l,m)</span><br>    <span class="hljs-keyword">return</span> r<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lower_bound2</span>(<span class="hljs-params">nums,target</span>):<br>    <span class="hljs-comment">#闭区间写法</span><br>    l = <span class="hljs-number">0</span><br>    r = <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> l&lt;=r: <span class="hljs-comment">#区间不为空</span><br>        m = (l+r) // <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[m] &lt; target: <span class="hljs-comment">#false</span><br>            l =  m+<span class="hljs-number">1</span>   <br>        <span class="hljs-keyword">else</span>:<br>            r = m-<span class="hljs-number">1</span> <br>    <span class="hljs-keyword">return</span> l<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lower_bound3</span>(<span class="hljs-params">nums,target</span>):<br>    l = <span class="hljs-number">0</span><br>    r = <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-comment">#左闭右开区间写法 </span><br>    <span class="hljs-keyword">while</span> l &lt; r: <span class="hljs-comment">#区间不为空</span><br>        m = (l+r) // <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[m] &lt; target: <span class="hljs-comment">#false</span><br>            l =  m+<span class="hljs-number">1</span>   <br>        <span class="hljs-keyword">else</span>:<br>            r = m <br>    <span class="hljs-keyword">return</span> r<br></code></pre></td></tr></table></figure><p>那么一共演变了四种题型：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm">&gt;<span class="hljs-operator">=</span> <span class="hljs-keyword">x</span> 这种是我们熟知的<br>&gt; <span class="hljs-keyword">x</span> 这种可以转化为 &gt;<span class="hljs-operator">=</span> <span class="hljs-keyword">x</span><span class="hljs-number">+1</span><br>&lt; <span class="hljs-keyword">x</span> 这种可以转为 &gt;<span class="hljs-operator">=</span><span class="hljs-keyword">x</span> 的下标 <span class="hljs-number">-1</span><br>&lt;<span class="hljs-operator">=</span> <span class="hljs-keyword">x</span>这种可以转为 &gt;<span class="hljs-keyword">x</span> 的下标 <span class="hljs-number">-1</span> 即 &gt;<span class="hljs-operator">=</span> <span class="hljs-keyword">x</span><span class="hljs-number">+1</span><br></code></pre></td></tr></table></figure><p>如果说target比所有的数都大的话：会返回数组最大下标的next</p><p>target比所有的数都小的话：会返回 0</p><p>target在最大最小范围内，但是没有target，会返回 &gt;= target 的第一个</p><p>python 写二分最好还是直接调用库，这样比较快，大概快一半</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bisect <span class="hljs-keyword">import</span> *<br>bisect_left(nums,target) <span class="hljs-comment">#返回 &gt;= target的第一个，行为与我自己写的完全一致</span><br></code></pre></td></tr></table></figure><h2 id="162"><a href="#162" class="headerlink" title="162"></a>162</h2><p><a href="https://leetcode.cn/problems/find-peak-element/">https://leetcode.cn/problems/find-peak-element/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#红色代表峰顶左边</span><br><span class="hljs-comment">#蓝色代表峰顶以及峰顶右边</span><br><span class="hljs-comment">#区间表示不知道染什么色的东西</span><br><span class="hljs-comment">#只需要比较mid和mid+1就行，找到第一个下坡？</span><br><span class="hljs-comment">#如果你往下坡方向走，也许可能遇到新的山峰，但是也许是一个一直下降的坡，最后到边界。</span><br><span class="hljs-comment">#但是如果你往上坡方向走，就算最后一直上的边界，由于最边界是负无穷，所以就一定能找到山峰</span><br><span class="hljs-comment">#总的一句话，往递增的方向上，二分，一定能找到，往递减的方向只是可能找到，也许没有</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lower_bound</span>(<span class="hljs-params">nums</span>):<br>    l = -<span class="hljs-number">1</span> <span class="hljs-comment">#[0,n-2]</span><br>    r = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> l+<span class="hljs-number">1</span>&lt;r:<br>        mid = (l+r) // <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[mid] &lt; nums[mid+<span class="hljs-number">1</span>]:<br>            l = mid <span class="hljs-comment">#染红色</span><br>        <span class="hljs-keyword">else</span>:<br>            r = mid <span class="hljs-comment">#染蓝色</span><br>    <span class="hljs-keyword">return</span> r<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findPeakElement</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> lower_bound(nums)<br></code></pre></td></tr></table></figure><h2 id="153"><a href="#153" class="headerlink" title="153"></a>153</h2><p>原题链接： <a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值 - 力扣（LeetCode）</a></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这题一共就两种情况，因为是对一个有序数组的旋转，看下面画的图</p><p>第一种情况很好解决，简单的二分，第二种情况需要分析一下</p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405091804608.png" alt="image-20240509180447566"></p><p>我们要找的相当于是谷底，也就是左右都比他大的</p><p><strong>红蓝染色法二分：</strong></p><ul><li>红色表示最小数的左边</li><li>蓝色表示最小数或者最小数的右边</li></ul><p>我们可以首先确定最后一个数一定是蓝色，所以开始的区间可以设为 [0,n-2]，这个区间是我们不知道要怎么染色的，接下来开始二分缩小这个区间</p><p>使用开区间来写的话，最初 l = -1，r = n-1</p><p><strong>那么我们怎么确定要染什么颜色？</strong></p><ul><li>通过已知条件来看，我们仿照上一题，让mid和mid+1来比较可以吗？显然是不行的，因为除了最小值旁边的元素其他位置都满足 num[mid] &lt; num[mid+1] ，无法根据这个来染色</li><li>可以根据 num[mid] 和 num[-1] (最后一个元素) 来比较<ul><li>如果 num[mid] &lt; num[-1]：由图可知，需要让 r = mid</li><li>如果 num[mid] &gt; num[-1]：由图可知：需要让 l = mid</li></ul></li></ul><p>最后返回值应该是什么呢，下标返回 r 即可</p><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这题不就是寻找谷值吗</span><br><span class="hljs-comment"># 红色表示谷左边</span><br><span class="hljs-comment"># 蓝色表示谷以及谷的右边</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">binsearch</span>(<span class="hljs-params">nums</span>):<br>    l = -<span class="hljs-number">1</span> <span class="hljs-comment"># [0,n-2]</span><br>    r = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> l+<span class="hljs-number">1</span> &lt; r:<br>        mid = (l+r) // <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[mid] &lt; nums[-<span class="hljs-number">1</span>]:<br>            r = mid <br>        <span class="hljs-keyword">else</span>:<br>            l = mid<br>    <span class="hljs-keyword">return</span> nums[r]<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findMin</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> binsearch(nums)<br></code></pre></td></tr></table></figure><p>思考：</p><p>边界条件，最小的在最右怎么办?</p><ul><li>这种情况由于一开始其实我们就给最右染色了，那么 r 一直是不会移动的，合理</li></ul><p>一般最大化最小值或者最小化最大值都可以用二分来做</p><h1 id="4-单调栈"><a href="#4-单调栈" class="headerlink" title="4.单调栈"></a>4.单调栈</h1><p>单调栈：如果你发现你要计算的内容和上一个更大（小）/下一个更大/（小）的元素有关，尝试单调栈</p><p>栈中保存有用的，维护它的单调性【这一点是最难的，你如果知道需要保留什么，就知道什么东西需要入栈，什么东西需要出栈，在什么时候计算答案】</p><p>可以在进栈 or 出栈的时候来做你想做的</p><p>原题链接：<a href="https://leetcode.cn/problems/daily-temperatures/description/">739. 每日温度 - 力扣（LeetCode）</a></p><p>从左往右</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dailyTemperatures</span>(<span class="hljs-params">self, temperatures: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        st = [] <span class="hljs-comment"># st 存的下标</span><br>        ans = [<span class="hljs-number">0</span>]*<span class="hljs-built_in">len</span>(temperatures)<br>        <span class="hljs-keyword">for</span> i,x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(temperatures):<br>            <span class="hljs-keyword">while</span> st <span class="hljs-keyword">and</span> x &gt; temperatures[st[-<span class="hljs-number">1</span>]]:<br>                t = st.pop()<br>                ans[t] = i - t<br>            st.append(i)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><p>从右往左：</p><p>现在的是 x，弹出栈中所有 &lt;= x的数（弹出意味着这些数没有用了，为什么呢，是因为x把右边的全部遮住了，我们左边的所有数的答案都不可能是和遮住的这些数有关）</p><p>那为什么比更大的数还要保留呢，如果一个数比x大并且小于这个栈顶更大的数，那么这个数的答案就是我们提到的更大的数</p><p>然后放入栈，x的答案是在发现栈为空（此时不用操作，初始化时已经设置为了0）或者栈顶元素比自己大了，此时可以算x对应的答案，然后放入x</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dailyTemperatures</span>(<span class="hljs-params">self, temperatures: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        st = [] <span class="hljs-comment"># st 存的下标</span><br>        n = <span class="hljs-built_in">len</span>(temperatures)<br>        ans = [<span class="hljs-number">0</span>]*n <span class="hljs-comment"># 这里的初始化很重要，对于没有下一个更高温度的，在下面是不会处理它的</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br>            x = temperatures[i]<br>            <span class="hljs-keyword">while</span> st <span class="hljs-keyword">and</span> x &gt;= temperatures[st[-<span class="hljs-number">1</span>]]: <span class="hljs-comment"># 注意这里要 x&gt;= 不然对于一样的会有错误比如 3,5,5,6,2</span><br>                t = st.pop()<br>            <span class="hljs-keyword">if</span> st:<br>                ans[i] = st[-<span class="hljs-number">1</span>] - i<br>            st.append(i)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><p>注意最后，栈不一定是空的</p><p>个人更偏向从左往右</p><p>对栈顶元素找上一个更大的元素，在找的过程中填坑</p><p>横着计算，看成水泥，填平了，那么 &lt;= 自己的高度就不需要了，因为已经填平</p><p>需要的下标：当前元素的下标，栈顶元素的下标，栈顶元素的上一个的下标</p><p>这个栈里面存的是从右往左能看到的东西</p><p>每次必入栈，出栈不一定</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">trap</span>(<span class="hljs-params">self, height: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ans = <span class="hljs-number">0</span><br>        st = []<br>        <span class="hljs-keyword">for</span> i,x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(height):<br>            <span class="hljs-comment">#要找下一个更小和下一个&gt;=自己的</span><br>            <span class="hljs-comment"># 出栈的,清除掉 &lt;= x的</span><br>            left = <span class="hljs-number">0</span><br>            bottom = <span class="hljs-number">0</span><br>            right = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">while</span> st <span class="hljs-keyword">and</span>  x &gt;= height[st[-<span class="hljs-number">1</span>]]: <span class="hljs-comment">#这里 &gt; 或者 &gt;= 都可以，如果是&gt;=的话 min(right,left)-bottom 就等于 0 ，其实 &gt;= 更好，比如2,2,0,1，其</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(st) &gt;= <span class="hljs-number">2</span>:<br>                    bot = st.pop()<br>                    l = st[-<span class="hljs-number">1</span>] <span class="hljs-comment">#注意这个不能出栈，这个还有用，只有栈顶没用了，被水泥封上了</span><br>                    bottom = height[bot]<br>                    left = height[l]<br>                    right = x<br>                    ans += (<span class="hljs-built_in">min</span>(right,left)-bottom)*(i-l -<span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    st.pop()<br>            st.append(i)<br>        <span class="hljs-keyword">return</span> ans<br>                    <br></code></pre></td></tr></table></figure><p>时间复杂度</p><p><a href="https://www.lanqiao.cn/problems/17152/learning/?page=3&first_category_id=1&second_category_id=3&tags=2023,%E5%9B%BD%E8%B5%9B">0最大区间 - 蓝桥云课 (lanqiao.cn)</a></p><p>需要特别注意，在数组的开头和末尾各自加上一个0 如果开头不加上0，会出现越界访问；如果末尾不加上0，会出现这种数据没有结果 5,1 2 3 4 5。原理是让最后一个0来让前面的所有没有更新的出栈更新至少一次</p><h1 id="5-单调队列"><a href="#5-单调队列" class="headerlink" title="5.单调队列"></a>5.单调队列</h1><blockquote><p>及时去掉无用数据，保证双端队列有序</p></blockquote><p>滑动窗口最大值</p><p>deque里面存的是下标</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxSlidingWindow</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        q = deque()<br>        ans = []<br>        <span class="hljs-keyword">for</span> i,x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            <span class="hljs-comment"># 出</span><br>            <span class="hljs-keyword">while</span> q <span class="hljs-keyword">and</span> x &gt;= nums[q[-<span class="hljs-number">1</span>]]:<br>                q.pop()<br><br>            <span class="hljs-comment"># 入</span><br>            q.append(i)<br>            <span class="hljs-comment">#最大下标 i-k+1</span><br>            <span class="hljs-comment">#为什么只看q[0]呢，因为我们只后移了一位相当于，只有队首有可能out了</span><br>            <span class="hljs-keyword">if</span> q[<span class="hljs-number">0</span>] &lt; i-k+<span class="hljs-number">1</span>: <br>                q.popleft()<br>            <span class="hljs-comment">#记录答案</span><br>            <span class="hljs-keyword">if</span> i&gt;=k-<span class="hljs-number">1</span>:<br>                ans.append(nums[q[<span class="hljs-number">0</span>]])<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><p>复杂度：每个下标最多入队出队各一次，所以复杂度是O(n)</p><p>当前数字 &gt;= 队尾，弹出队尾</p><p>弹出队首不在窗口内的元素</p><p><a href="https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/description/">1438. 绝对差不超过限制的最长连续子数组 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dq</span>(<span class="hljs-params">nums,limit</span>):<br>    q_min = deque()<br>    q_max = deque()<br>    ret =left= <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i,x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>        <span class="hljs-keyword">while</span> q_min <span class="hljs-keyword">and</span> x &lt; nums[q_min[-<span class="hljs-number">1</span>]]:<br>            q_min.pop()<br>        q_min.append(i)<br>        <span class="hljs-comment"># if q_min[0] &lt; i-k+1:</span><br>        <span class="hljs-comment">#     q_min.popleft()</span><br>        <br>        <span class="hljs-keyword">while</span> q_max <span class="hljs-keyword">and</span> x &gt; nums[q_max[-<span class="hljs-number">1</span>]]:<br>            q_max.pop()<br>        q_max.append(i)<br>        <span class="hljs-comment"># if q_max[0] &lt; i-k+1:</span><br>        <span class="hljs-comment">#     q_max.popleft()</span><br><br>        <span class="hljs-keyword">while</span> q_min <span class="hljs-keyword">and</span> q_max <span class="hljs-keyword">and</span>  nums[q_max[<span class="hljs-number">0</span>]]-nums[q_min[<span class="hljs-number">0</span>]] &gt; limit:<br>            <span class="hljs-keyword">if</span> nums[q_min[<span class="hljs-number">0</span>]] == nums[left]:<br>                q_min.popleft()<br>            <span class="hljs-keyword">if</span> nums[q_max[<span class="hljs-number">0</span>]] == nums[left]:<br>                q_max.popleft()<br>            left += <span class="hljs-number">1</span><br><br>        ret = <span class="hljs-built_in">max</span>(ret,i-left+<span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">return</span> ret<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestSubarray</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], limit: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 任意两个元素之间的绝对差必须小于或者等于 limit 转化为 最大最小之差 &lt;= limit</span><br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> :<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> dq(nums,limit)<br><br></code></pre></td></tr></table></figure><p>注意这是没有 k 限制的滑动窗口</p><p>然后 <code>ret = max(ret,i-left+1)</code> 这里不能写成 <code>ret = max(ret,i-min(q_max[0],q_min[0])+1)</code>，因为窗口最左端的索引有可能已经被顶掉了，看下面这个样例。 nums = [4,10,2,6,1] limit = 10</p><p>所以需要额外的信息来保存最左端的索引</p><p><a href="https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/solutions/2777332/ling-shen-ke-hou-zuo-ye-dan-diao-dui-lie-to7c/comments/2301234/">1438. 绝对差不超过限制的最长连续子数组 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">https://leetcode.cn/problems/longest-substring-without-repeating-characters/</a>)</p><h1 id="6-字典树"><a href="#6-字典树" class="headerlink" title="6.字典树"></a>6.字典树</h1><p>注意下面所说的字母和字符串的区别</p><ol><li>把<strong>字符串</strong>按照前缀分组，第一个字母相同的，分到一组，第二个字母相同的，分到另一组….</li><li>用一颗树来实现</li><li>把每个<strong>字母</strong>对应到一颗树上的某个节点，保证对于每个字符串s内部，s[i]一定是s[i+1]的父节点</li></ol><p>字典树可以用来快速判断一个字符串是否是另一个字符串的前缀，但是没办法判断后缀</p><p>后缀可以转为前缀 ，从后往前建树和查找不就行了</p><p>可以用两个前缀树，但是可以转化，把这两个信息整合到一个pair</p><p>什么时候想到用字典树呢，分组，组里面还有更小的组，这种就可能需要树：本质就是用树来分组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.children = &#123;&#125;<br>        self.is_end_of = <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">self, word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        current = self<br>        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> word:<br>            <span class="hljs-keyword">if</span> char <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> current.children:<br>                current.children[char] = Trie()<br>            current = current.children[char]<br>        current.is_end_of = <span class="hljs-literal">True</span>    <br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        current = self<br>        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> word:<br>            <span class="hljs-keyword">if</span> char <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> current.children:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            current = current.children[char]<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span> <span class="hljs-keyword">if</span> current.is_end_of <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span><br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">startsWith</span>(<span class="hljs-params">self, prefix: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        current = self<br>        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> prefix:<br>            <span class="hljs-keyword">if</span> char <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> current.children:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            current = current.children[char]<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><br><span class="hljs-comment"># Your Trie object will be instantiated and called as such:</span><br><span class="hljs-comment"># obj = Trie()</span><br><span class="hljs-comment"># obj.insert(word)</span><br><span class="hljs-comment"># param_2 = obj.search(word)</span><br><span class="hljs-comment"># param_3 = obj.startsWith(prefix)</span><br></code></pre></td></tr></table></figure><p>入门字典树：<a href="https://leetcode.cn/problems/implement-trie-prefix-tree/description/">208. 实现 Trie (前缀树) - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/longest-common-suffix-queries/solutions/2785807/zi-dian-shu-ban-zi-jie-ti-by-insist-w-rlfv/">3093. 最长公共后缀查询 - 力扣（LeetCode）</a></p><p><strong>最大异或和</strong></p><p><a href="https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/description/">421. 数组中两个数的最大异或值 - 力扣（LeetCode）</a></p><h1 id="7-Z函数-扩展kmp"><a href="#7-Z函数-扩展kmp" class="headerlink" title="7.Z函数 扩展kmp"></a>7.Z函数 扩展kmp</h1><p>但实际上和kmp没什么关系</p><p>计算每个后缀能和字符串开头匹配多长</p><p>利用已经匹配的信息</p><p>z-box右侧的字符都是没有见过的</p><h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><p>回溯三问！！！</p><ol><li>当前操作</li><li>子问题？</li><li>下一个子问题？</li></ol><h1 id="8-dp"><a href="#8-dp" class="headerlink" title="8.dp"></a>8.dp</h1><h2 id="如何手动记忆化搜索"><a href="#如何手动记忆化搜索" class="headerlink" title="如何手动记忆化搜索"></a>如何手动记忆化搜索</h2><p>核心是两点：</p><ul><li>dfs改成数组</li><li>递归改成循环</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 由于有两个背包，所以二维肯定不行</span><br><span class="hljs-comment"># 考虑用两个数组或者三维</span><br>n,a,b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())<br>nums = [<span class="hljs-number">0</span>]*n<br>nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split()))<br><span class="hljs-comment"># f[a][b][n] 表示余量为a,b，前n个物品的最大值</span><br>f = [[[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n+<span class="hljs-number">1</span>)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(b+<span class="hljs-number">1</span>)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(a+<span class="hljs-number">1</span>)]<br><br><br> <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i,j,k</span>):<br>   <span class="hljs-keyword">if</span> k&lt;<span class="hljs-number">0</span>:<br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>   <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> j &lt;<span class="hljs-number">0</span>:<br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>   <span class="hljs-keyword">if</span> f[i][j][k] != -<span class="hljs-number">1</span>:<br>     <span class="hljs-keyword">return</span> f[i][j][k]<br>   <span class="hljs-keyword">if</span> i &gt;= nums[k]:<br>     suma = <span class="hljs-built_in">max</span>(dfs(i,j,k-<span class="hljs-number">1</span>),dfs(i-nums[k],j,k-<span class="hljs-number">1</span>)+nums[k])<br>   <span class="hljs-keyword">else</span>:<br>     suma = dfs(i,j,k-<span class="hljs-number">1</span>)<br>   <span class="hljs-keyword">if</span> j &gt;= nums[k]:<br>     sumb = <span class="hljs-built_in">max</span>(dfs(i,j,k-<span class="hljs-number">1</span>),dfs(i,j-nums[k],k-<span class="hljs-number">1</span>)+nums[k])<br>   <span class="hljs-keyword">else</span>:<br>     sumb = dfs(i,j,k-<span class="hljs-number">1</span>)<br>   f[i][j][k] = <span class="hljs-built_in">max</span>(suma,sumb)<br>   <span class="hljs-keyword">return</span> f[i][j][k]<br></code></pre></td></tr></table></figure><p>注意看，<code>if f[i][j][k] != -1 return f[i][j][k]</code> 这一行就是利用记忆化搜索了</p><p>然后注意更新数组的位置<code> f[i][j][k] = max(suma,sumb)</code> 别忘记了</p><p>在每次return之前更新对应的dp数组，然后dp数组的初始值可以给一个不可能达到的值，后面判断是不是这个值就可以知道是否搜索过了，从而实现记忆化搜索</p><p>注意你的结果是return dfs的结果而不是dp数组</p><p>dfs.cache_clear()  # 防止爆内存</p><p>记忆化搜索：</p><p><a href="https://leetcode.cn/problems/find-number-of-ways-to-reach-the-k-th-stair/description/">3154. 到达第 K 级台阶的方案数 - 力扣（LeetCode）</a></p><p>注意如果很难确定数组大小，用hash表</p><p>注意遇到需要记录的dp数组，右边应该是dfs结果而不是dp数组结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#正确</span><br><span class="hljs-keyword">if</span> s[i] == s[j]:<br>    f[i][j] = dfs(i+<span class="hljs-number">1</span>,j-<span class="hljs-number">1</span>)+<span class="hljs-number">2</span><br>    <span class="hljs-keyword">return</span> f[i][j]<br><span class="hljs-comment">#错误</span><br><span class="hljs-keyword">if</span> s[i] == s[j]:<br>    f[i][j] = f[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+<span class="hljs-number">2</span><br>    <span class="hljs-keyword">return</span> f[i][j]<br><span class="hljs-comment">#然后要注意return的是 f[i][j] 而不是 dfs(i,j)不然又算了一遍哈，浪费时间</span><br></code></pre></td></tr></table></figure><p>记忆化搜索翻译为递推时，要注意循环的顺序，看你是从什么转移过来的</p><ul><li>从i+1这种更大的转移过来，那么就需要反序枚举</li><li>从i-1这种更小的转移过来，那么就需要正序枚举</li></ul><p>还要注意是否增加下标防止数组越界，也就是看有没有-1的出现和n的出现（数组最大下标为n-）</p><h2 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h2><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405212349828.png" alt="image-20240521234859561"></p><ul><li>恰好：dfs时必须等于0才记录答案</li><li>至多：dfs时&gt;=0记录答案，然后初始化要变一下</li><li>至少：这个没看懂</li></ul><p>看评论七水佬的总结</p><p>递推的初始值就是递归的边界</p><p>判断一维数组时是否需要反序遍历，自己根据状态转移方程列一个表来比较看一下</p><p>在只用一个一维数组的情况下，要注意转移来源 1. 不能被覆盖 2. 必须已经计算出来。按照这个要求，正序遍历会导致 0-1 背包状态被覆盖，而完全背包则是正确的（转移来源被计算出来，且不存在被覆盖的问题）；逆序遍历对于 0-1 背包是正确的（转移来源是上一行的，早就被计算出来了且没有被覆盖），而完全背包则不行（转移来源没有被计算出来）。</p><p>像这样画个图就很好理解</p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405212359639.png" alt="image-20240521235910512"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findTargetSumWays</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 假设添加+号的正数的和为p</span><br>        <span class="hljs-comment"># s为 sum(nums)</span><br>        <span class="hljs-comment"># 那么添加-号的负数绝对值之和就为 s-p</span><br>        <span class="hljs-comment"># 那么题意就转化为 p-(s-p) = t</span><br>        <span class="hljs-comment"># p = (s+t)/2，p是非负数，整数</span><br>        <span class="hljs-comment"># 那这样本题就变成了从nums中选择一些数，他们的和恰好为 (s+t)/2，这个固定的数</span><br>        <span class="hljs-comment"># 也就是背包问题</span><br>        target += <span class="hljs-built_in">sum</span>(nums)<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">if</span> target&lt;<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> target%<span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        target//=<span class="hljs-number">2</span><br>        <span class="hljs-comment"># def dfs(i,c):</span><br>        <span class="hljs-comment">#     if i &lt; 0:</span><br>        <span class="hljs-comment">#         return 1 if c == 0 else 0</span><br>        <span class="hljs-comment">#     if c &lt; nums[i]:</span><br>        <span class="hljs-comment">#         return dfs(i-1,c)</span><br>        <span class="hljs-comment">#     return dfs(i-1,c) + dfs(i-1,c-nums[i])</span><br>        <span class="hljs-comment"># return dfs(n-1,target)</span><br><br>        <span class="hljs-comment">#优化空间，每次只用到了i-1和i，那么第一个下标就只用2就好了，每次%2</span><br>        <span class="hljs-comment"># f = [[0]*(target+1) for _ in range(2)]</span><br>        <span class="hljs-comment"># f[0][0] = 1</span><br>        <span class="hljs-comment"># for i in range(1,n+1):</span><br>        <span class="hljs-comment">#     for c in range(target+1):</span><br>        <span class="hljs-comment">#         if c &lt; nums[i-1]:</span><br>        <span class="hljs-comment">#             f[i%2][c] = f[(i-1)%2][c]</span><br>        <span class="hljs-comment">#         else:</span><br>        <span class="hljs-comment">#             f[i%2][c] = f[(i-1)%2][c] + f[(i-1)%2][c-nums[i-1]]</span><br>        <span class="hljs-comment"># return f[n%2][target]</span><br><br>        <span class="hljs-comment"># 优化空间之一维</span><br>                <span class="hljs-comment">#优化空间，每次只用到了i-1和i，那么第一个下标就只用2就好了，每次%2</span><br>        f = [<span class="hljs-number">0</span>]*(target+<span class="hljs-number">1</span>)<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(target,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>): <span class="hljs-comment">#或者枚举范围 range(target,nums[i-1]-1,-1)，这样就不需要if了</span><br>                <span class="hljs-keyword">if</span> c &gt;= nums[i-<span class="hljs-number">1</span>]:<br>                    f[c] = f[c] + f[c-nums[i-<span class="hljs-number">1</span>]]<br>        <span class="hljs-keyword">return</span> f[target]<br></code></pre></td></tr></table></figure><p>类似背包问题循环顺序的思考：</p><p>假设你现在在c，要转移到<code>(i+1,c)</code>你转移的其中一个肯定是<code>(i,c)</code></p><p>那么对于另一个，如果你是从图中这两个蓝色框转移过来，那么需要倒序遍历</p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405302351001.png" alt="image-20240530235131706"></p><ul><li>左上蓝色圈分析：你需要从一个左边的旧值转移过来，你如果正序遍历，那么左边的旧值会被新值覆盖，导致错误</li><li>右下蓝色圈分析：你需要从一个右边的新值转移过来，如果正序遍历，你得到的右边的还没有更新，还是旧值</li></ul><p>如果是从这两个绿色框转移过来，那么需要正序遍历：</p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405302354265.png" alt="image-20240530235422146"></p><ul><li>左下绿色圈分析：你需要从一个左边的新值转移过来，那么就要从左到右依次更新，如果你倒序遍历，左边的还是旧值没有更新</li><li>右上绿色圈分析：你需要一个右边的旧值转移过来，那么不能从右边更新过来，如果倒序遍历，右边的旧值会被新值覆盖，导致错误</li></ul><p>如果察觉到重复的子问题，就可以使用动态规划（记忆化搜索）</p><p>从第一个或者最后一个开始思考?</p><p>如何满足恰好？ 在dfs返回值的时候判断此时背包剩余容量是不是0</p><h2 id="线性dp"><a href="#线性dp" class="headerlink" title="线性dp"></a>线性dp</h2><ul><li><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a></li><li><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/">583. 两个字符串的删除操作</a></li><li><a href="https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/">712. 两个字符串的最小 ASCII 删除和</a></li><li><a href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a></li></ul><ul><li><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></li></ul><p>前缀或者后缀</p><h2 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h2><p>不再是前缀或者后缀，而是数组中间的区间</p><p>核心思想是分治法？</p><p><a href="https://leetcode.cn/problems/minimum-score-triangulation-of-polygon/description/">1039. 多边形三角剖分的最低得分 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/guess-number-higher-or-lower-ii/solutions/2793594/ling-shen-ke-hou-ti-da-qia-liang-chong-f-e83e/">375. 猜数字大小 II - 力扣（LeetCode）</a></p><h2 id="状态压缩dp"><a href="#状态压缩dp" class="headerlink" title="状态压缩dp"></a>状态压缩dp</h2><p>一般看到很小的数据范围，就有可能是一个状压dp，什么十几啊这种</p><h1 id="9-差分数组"><a href="#9-差分数组" class="headerlink" title="9.差分数组"></a>9.差分数组</h1><p><a href="https://leetcode.cn/circle/discuss/FfMCgb/">分享｜【算法小课堂】差分数组（Python/Java/C++/Go/JS） - 力扣（LeetCode）</a></p><p>优化对区间每个数都加/减同一个数的操作</p><p>记录变化量来优化</p><p>也可以这样理解，d[i] 表示把下标  &gt;= i 的数都加上 d[i]。</p><p><strong>性质 1</strong>：从左到右累加 𝑑 中的元素，可以得到数组 𝑎</p><p>代码模板</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 你有一个长为 n 的数组 a，一开始所有元素均为 0。</span><br><span class="hljs-comment"># 给定一些区间操作，其中 queries[i] = [left, right, x]，</span><br><span class="hljs-comment"># 你需要把子数组 a[left], a[left+1], ... a[right] 都加上 x。</span><br><span class="hljs-comment"># 返回所有操作执行完后的数组 a。</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solve</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span>, queries: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>    diff = [<span class="hljs-number">0</span>] * n  <span class="hljs-comment"># 差分数组</span><br>    <span class="hljs-keyword">for</span> left, right, x <span class="hljs-keyword">in</span> queries:<br>        diff[left] += x<br>        <span class="hljs-comment">#</span><br>        <span class="hljs-keyword">if</span> right + <span class="hljs-number">1</span> &lt; n:<br>            diff[right + <span class="hljs-number">1</span>] -= x<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>        diff[i] += diff[i - <span class="hljs-number">1</span>]  <span class="hljs-comment"># 直接在差分数组上复原数组 a</span><br>    <span class="hljs-keyword">return</span> diff<br></code></pre></td></tr></table></figure><p>这题目前还看不懂：<a href="https://leetcode.cn/problems/maximize-the-minimum-powered-city/description/">2528. 最大化城市的最小电量 - 力扣（LeetCode）</a></p><h1 id="10-堆，优先队列"><a href="#10-堆，优先队列" class="headerlink" title="10.堆，优先队列"></a>10.堆，优先队列</h1><p><a href="https://leetcode.cn/problems/last-stone-weight/">1046. 最后一块石头的重量 - 力扣（LeetCode）</a></p><p>手写小顶堆：<a href="https://leetcode.cn/problems/last-stone-weight/solutions/540369/python-zui-da-dui-diao-ku-shou-xie-shi-x-utdj/">1046. 最后一块石头的重量 - 力扣（LeetCode）</a></p><p>python库实现的是小顶堆：<code>heapq</code> 是 Python 中的一个内置模块（不需要导入？）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> heapq<br>a = []<br>heapq.heapify(a) <span class="hljs-comment">#将一个可迭代对象转换为堆数据结构</span><br>heapq.heappush(a,<span class="hljs-number">1</span>) <span class="hljs-comment">#向堆中添加一个新元素</span><br>heapq.heappop(a) <span class="hljs-comment">#从堆中弹出并返回最小元素</span><br>heapreplace(heap, item) <span class="hljs-comment">#弹出并返回最小元素，并将新元素推入堆中</span><br>nlargest(n, iterable) <span class="hljs-comment">#返回可迭代对象中的前 n 个最大元素</span><br>nsmallest(n, iterable) <span class="hljs-comment">#返回可迭代对象中的前 n 个最小元素</span><br></code></pre></td></tr></table></figure><p>堆顶就是第0个元素</p><p>如果你需要实现大顶堆（最大优先队列），可以通过将优先级的值取负来实现：</p><p><a href="https://www.lanqiao.cn/problems/17120/learning/">0选段排序 - 蓝桥云课 (lanqiao.cn)</a></p><h1 id="11-树状数组，线段树"><a href="#11-树状数组，线段树" class="headerlink" title="11.树状数组，线段树"></a>11.树状数组，线段树</h1><p><a href="https://www.bilibili.com/video/BV1ce411u7qP">https://www.bilibili.com/video/BV1ce411u7qP</a></p><p>动机，我们想修改一个点，然后查询某个区间的和</p><p>可选的方法：</p><ul><li>维护 $n^2$ 个区间的和：此时查询是 $O(1)$，但是更新某个点是$O(n^2)$</li><li>把每个区间分成单个，也就是[1,1], [2,2] .. [n,n]，这样的话更新某个点是$O(1)$，查询是$O(n)$</li></ul><p>这里查询和更新就像天平的两端，你需要做一个tradeoff</p><p>那么我们试着把维护的区间多一点，但是又不至于到 $n^2$ 个</p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405292026288.png" alt="image-20240529202553048"></p><p>像这张图一样：此时我们要查询某个区间的和，复杂度其实降到了$O(logn)$</p><p>上面看上去就像树形结构了，好了，此时你就发明了线段树了()</p><p>代码实现：</p><p>首先我们需要开多大的数组，图上面这个数组最下面一层16，然后8,4,2,1</p><p>$16+8+4+2+1=31$ </p><p>你的数组长度要差不多 $2^{n的二进制长度}*2$  或者 4n</p><p>把最下面一层补满</p><p>树状数组：单点更新，区间查询<br>线段树：区间更新（都加上一个数、把子数组内的元素取反），区间查询</p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405292226555.png" alt="image-20240529222616388"></p><p>两大思想：</p><ol><li><p>挑选O(n)个特殊区间，使得任意一个区间可以拆分为O(logn)个特殊区间</p><p>特殊区间个数 &lt;= 4n </p><p>最坏情况下，左边走到叶子结点，右边走到叶子结点，一共就拆分了2*树高 = 2 *logn个区间，也可以最近公共祖先来思考</p></li></ol><p>o 表示结点编号</p><p>特别注意：<strong>由于o和0离得比较近切像，不要打错了！</strong>！！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">o:<span class="hljs-built_in">int</span>, l:<span class="hljs-built_in">int</span>, r:<span class="hljs-built_in">int</span></span>):<span class="hljs-comment">#相当于自底向上建树</span><br>    <span class="hljs-keyword">if</span> l==r:<br>        <span class="hljs-comment">#更新...</span><br>        d[o] = a[l]<br>        <span class="hljs-keyword">return</span><br>    m = l+r&gt;&gt;<span class="hljs-number">1</span><br>    <span class="hljs-comment">#递归对左右区间建树</span><br>    build(o*<span class="hljs-number">2</span>,l,m)<br>    build(o*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,m+<span class="hljs-number">1</span>,r)<br>    <span class="hljs-comment">#维护...</span><br>    d[o] = d[o*<span class="hljs-number">2</span>] + d[o*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]<br><br><span class="hljs-comment">#区间查询</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getsum</span>(<span class="hljs-params">o:<span class="hljs-built_in">int</span>, l:<span class="hljs-built_in">int</span>, r:<span class="hljs-built_in">int</span>, L:<span class="hljs-built_in">int</span>, R:<span class="hljs-built_in">int</span></span>)-&gt;<span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># [L,R]表示固定的你需要查询的区间</span><br>    <span class="hljs-comment"># [l,r]表示当前节点包含区间</span><br>    <span class="hljs-keyword">if</span> L&lt;=l <span class="hljs-keyword">and</span> r&lt;=R: <br>        <span class="hljs-keyword">return</span> d[o] <span class="hljs-comment">#当前区间为询问区间的子集时直接返回当前区间的和</span><br>    m = l+r&gt;&gt;<span class="hljs-number">1</span><br>    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 如果左儿子代表的区间 [l, m] 与询问区间有交集, 则递归查询左儿子</span><br>    <span class="hljs-keyword">if</span> L&lt;=m:<span class="hljs-built_in">sum</span>+=getsum(o,l,m,L,R)<br>    <span class="hljs-comment"># 如果右儿子代表的区间 [m+1, r] 与询问区间有交集, 则递归查询左儿子</span><br>    <span class="hljs-keyword">if</span> m+<span class="hljs-number">1</span>&lt;=R:<span class="hljs-built_in">sum</span>+=getsum(o,m+<span class="hljs-number">1</span>,r,L,R)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span><br>    <br>    <br>    <span class="hljs-comment">#[L,R]表示固定的，你需要update的区间</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">o:<span class="hljs-built_in">int</span>, l:<span class="hljs-built_in">int</span>, r:<span class="hljs-built_in">int</span>, L:<span class="hljs-built_in">int</span>, R:<span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-keyword">if</span> L&lt;=l <span class="hljs-keyword">and</span> r&lt;=R: <br>        <span class="hljs-comment">#更新...</span><br>        <span class="hljs-keyword">return</span><br>    m = l+r&gt;&gt;<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> m&gt;=L:update(o*<span class="hljs-number">2</span>,l,m,L,R)<br>    <span class="hljs-keyword">if</span> m+<span class="hljs-number">1</span>&lt;=R:update(o*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,m+<span class="hljs-number">1</span>,r,L,R)<br>    <span class="hljs-comment">#维护...</span><br></code></pre></td></tr></table></figure><p>单点修改不用lazy？区间修改才用lazy</p><blockquote><p>单点修改直接到底了 不需要lazy延迟?</p></blockquote><p>lazy更新</p><p>如果说我要更新的区间被完全包含在了这次更新的区间内，那就不继续往下走，而是添加一个lazy tag</p><p>如果这个区间在后续的更新、查询被破坏掉了，就把lazy tag往下传</p><p>lazy标记下，区间修改和查询操作的实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python">todo = [<span class="hljs-number">0</span>]*<span class="hljs-number">4</span>*n <span class="hljs-comment">#todo数组表示lazy标记</span><br><span class="hljs-comment">#注意lazy tag打在的这个区间是已经更新了的，只是他的自区间还没有更新</span><br><br><span class="hljs-comment"># 区间修改</span><br><span class="hljs-comment"># c表示被修改区间的变化量</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">o:<span class="hljs-built_in">int</span>, l:<span class="hljs-built_in">int</span>, r:<span class="hljs-built_in">int</span>, L:<span class="hljs-built_in">int</span>, R:<span class="hljs-built_in">int</span>, c:<span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-keyword">if</span> L&lt;=l <span class="hljs-keyword">and</span> r&lt;=R: <span class="hljs-comment"># 当前区间为修改区间的子集时直接修改当前节点的值,然后打标记,结束修改</span><br>        d[o] += (r-l+<span class="hljs-number">1</span>)*c<br>        todo[o] += c<br>        <span class="hljs-keyword">return</span> <br>    m=l+r&gt;&gt;<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> todo[o] <span class="hljs-keyword">and</span> l!=r: <span class="hljs-comment">#如果当前节点的懒标记非空,则更新当前节点两个子节点的值和懒标记值</span><br>        <span class="hljs-comment">#如果l==r代表到了叶结点，下面没有子节点了，不用更新子节点</span><br>        <span class="hljs-comment">#更新当前节点两个子结点的值</span><br>        d[o*<span class="hljs-number">2</span>] += todo[o]*(m-l+<span class="hljs-number">1</span>)<br>        d[o*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>] += todo[o]*(r-m)<br>        <span class="hljs-comment"># 将标记下传给子节点</span><br>        todo[o*<span class="hljs-number">2</span>] += todo[o]<br>        todo[o*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>] += todo[o]<br>        <span class="hljs-comment">#清空当前节点的标记</span><br>        todo[o] = <span class="hljs-number">0</span><br>        <br>    <span class="hljs-keyword">if</span> m&gt;=L:update(o*<span class="hljs-number">2</span>,l,m,L,R,c)<br>    <span class="hljs-keyword">if</span> m+<span class="hljs-number">1</span>&lt;=R:update(o*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,m+<span class="hljs-number">1</span>,r,L,R,c)<br>    d[o] = d[o*<span class="hljs-number">2</span>]+d[o*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]<br>    <br><span class="hljs-comment">#区间查询</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getsum</span>(<span class="hljs-params">o:<span class="hljs-built_in">int</span>, l:<span class="hljs-built_in">int</span>, r:<span class="hljs-built_in">int</span>, L:<span class="hljs-built_in">int</span>, R:<span class="hljs-built_in">int</span></span>)-&gt;<span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">if</span> L&lt;=l <span class="hljs-keyword">and</span> r&lt;=R:<br>        <span class="hljs-keyword">return</span> d[o]<br>    m = l+r&gt;&gt;<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> todo[o]:<br>        d[o*<span class="hljs-number">2</span>] += todo[o]*(m-l+<span class="hljs-number">1</span>)<br>        d[o*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>] += todo[o]*(r-m)<br>        todo[o*<span class="hljs-number">2</span>] += todo[o]<br>        todo[o*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>] += todo[o]<br>        todo[o] = <span class="hljs-number">0</span><br>    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> m&gt;=L: <span class="hljs-built_in">sum</span>+=getsum(o*<span class="hljs-number">2</span>,l,m,L,R)<br>    <span class="hljs-keyword">if</span> m+<span class="hljs-number">1</span>&lt;=R:<span class="hljs-built_in">sum</span>+=getsum(o*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,m+<span class="hljs-number">1</span>,r,L,R)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span><br></code></pre></td></tr></table></figure><p>如果要实现区间修改为某个值而不是加上某一个值的话：把<code>+=</code>改为<code>=</code></p><p>注意，下面这个是oi-wiki的模板，不是我的，等待修改为我的版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">o:<span class="hljs-built_in">int</span>, l:<span class="hljs-built_in">int</span>, r:<span class="hljs-built_in">int</span>, L:<span class="hljs-built_in">int</span>, R:<span class="hljs-built_in">int</span>, c:<span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-keyword">if</span> L&lt;=l <span class="hljs-keyword">and</span> r&lt;=R:<br>        d[o]<br></code></pre></td></tr></table></figure><h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><p>灵神主页题单：<a href="https://leetcode.cn/u/endlesscheng/">灵茶山艾府 - 力扣（LeetCode）</a> 在讨论发布里面</p><p><a href="https://leetcode.cn/circle/discuss/CaOJ45/">分享｜从集合论到位运算，常见位运算技巧分类总结！ - 力扣（LeetCode）</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c">n,p,q = <span class="hljs-built_in">map</span>(<span class="hljs-type">int</span>,input().split())<br><br>f = [<span class="hljs-number">0</span>] + <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-type">int</span>,input().split()))<br><br># 求f[q]-f[p]的最大值，选一段来排序<br># 先向着左边扩展 [p,q]扩展为[<span class="hljs-number">0</span>,q]<br># 双堆模拟，大根堆，小根堆<br># 其实不用小根堆<br>mint = inf<br>maxt = <span class="hljs-number">0</span><br><br>h2 = [] #大根堆，存的相反数<br><span class="hljs-keyword">for</span> i in range(p,q+<span class="hljs-number">1</span>):<br>  maxt = max(maxt,f[i])<br>  mint = min(mint,f[i])<br>  heapq.heappush(h2,-f[i])<br>res = maxt-mint<br>#开始向右扩展<br><span class="hljs-keyword">for</span> i in range(q+<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):<br>  # 找此时的最小值，也就是f[p]<br>  mint = min(mint,f[i])<br>  # 找此时的最大值，也就是f[q]<br>  # 取出大根堆top<br>  heapq.heappush(h2,-f[i])<br>  heapq.heappop(h2)<br>  maxt = -h2[<span class="hljs-number">0</span>]<br>  res = max(res,maxt-mint)<br><br>h2 = [] #大根堆，存的相反数<br><span class="hljs-keyword">for</span> i in range(p,q+<span class="hljs-number">1</span>):<br>  maxt = max(maxt,f[i])<br>  mint = min(mint,f[i])<br>  heapq.heappush(h2,f[i])<br><br>#向左拓展<br><span class="hljs-keyword">for</span> i in range(p<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>):<br>  maxt = max(f[i],maxt)<br>  heapq.heappush(h2,f[i])<br>  heapq.heappop(h2)<br>  mint = h2[<span class="hljs-number">0</span>]<br>  res = max(res,maxt-mint)<br><br>print(res)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>xv6-locks</title>
    <link href="/2024/05/28/xv6-locks/"/>
    <url>/2024/05/28/xv6-locks/</url>
    
    <content type="html"><![CDATA[<p>自旋锁，睡眠锁，死锁，锁排序，锁的粒度</p><span id="more"></span><h1 id="Chapter-6-锁"><a href="#Chapter-6-锁" class="headerlink" title="Chapter 6 锁"></a>Chapter 6 锁</h1><h2 id="为什么需要锁？"><a href="#为什么需要锁？" class="headerlink" title="为什么需要锁？"></a><strong>为什么需要锁？</strong></h2><ul><li>多CPU内核：计算机的多个CPU之间独立执行，如xv6的RISC-V。多个处理器共享物理内存，这种共享增加了一种可能性，即一个CPU读取数据结构，而另一个CPU正在更新它</li><li>单CPU多线程内核：内核也可能在许多线程之间切换CPU，导致它们的执行交错</li></ul><p>以上可能导致数据损坏，单词<strong>并发（concurrency）</strong>是指由于多处理器并行、线程切换或中断，多个指令流交错的情况。</p><p>锁作为并发控制的一种，广泛使用。锁提供了互斥，确保一次只有一个CPU可以持有锁。如果程序员将<strong>每个共享数据项关联一个锁</strong>，并且代码在使用一个数据项时<strong>总是持有相关联的锁</strong>，那么该项一次将只被一个CPU使用。在这种情况下，我们说锁保护数据项。</p><p>锁的缺点是它会扼杀性能，因为他会串行化并发操作</p><p>一个例子：xv6的kfree实现是把一个内存页面添加到空闲链表上，这涉及到一个push操作。考虑这样一个情况，两个CPU同时执行push，如果没有锁，你的push实现可能是这样的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">element</span> &#123;</span><br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">element</span> *<span class="hljs-title">next</span>;</span><br>&#125;; <br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">element</span> *<span class="hljs-title">list</span> =</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-type">void</span> <br><span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">element</span> *<span class="hljs-title">l</span>;</span><br><br>    l = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span> *l);<br>    l-&gt;data = data;<br>    l-&gt;next = <span class="hljs-built_in">list</span>;<br>    <span class="hljs-built_in">list</span> = l; <br>&#125;<br></code></pre></td></tr></table></figure><p>现在两个CPU同时执行了15行，即将执行16行，这会出现错误</p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405281506486.png" alt="image-20240526120158956"></p><p>我们假定CPU2先执行16行，CPU1再执行16行，可以看到CPU1的执行会覆盖CPU2的执行，导致我们最后顺着list为头的链表，会找不到CPU2分配的L，这就是竞态条件的例子</p><p><strong>竞态条件</strong>是指多个进程读写某些共享数据（至少有一个访问是写入）的情况。竞争的结果取决于进程在处理器运行的确切时机以及内存系统如何排序它们的内存操作，这可能会使竞争引起的错误难以复现和调试。例如，在调试<code>push</code>时添加<code>printf</code>语句可能会改变执行的时间，从而使竞争消失。（神奇的内核。。）</p><p>那么<strong>如何解决</strong>这个问题呢，锁来了！在敏感的代码行加一把锁来保护共享数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <br><span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">element</span> *<span class="hljs-title">l</span>;</span><br><br>    l = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span> *l);<br>    l-&gt;data = data;<br>    acquire(&amp;listlock);<br>    l-&gt;next = <span class="hljs-built_in">list</span>;<br>    <span class="hljs-built_in">list</span> = l; <br>    release(&amp;listlock);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>acquire</code>和<code>release</code>之间的指令序列通常被称为<strong>临界区域</strong>（critical section）它们要么会一起执行，要么一条也不会执行</p><blockquote><p>当我们说锁保护数据时，我们实际上是指锁保护适用于数据的某些<strong>不变量集合</strong>。通常，操作的正确行为取决于操作开始时不变量是否为真。操作可能暂时违反不变量，但必须在完成之前重新建立它们</p><p>在链表的例子中，不变量是<code>list</code>指向列表中的第一个元素，以及每个元素的<code>next</code>字段指向下一个元素。<code>push</code>的实现暂时违反了这个不变量：在第17行，<code>l-&gt;next</code>指向<code>list</code>（注：则此时<code>list</code>不再指向列表中的第一个元素，即违反了不变量），但是<code>list</code>还没有指向<code>l</code>（在第18行重新建立）。我们上面检查的竞态条件发生了，因为第二个CPU执行了依赖于列表不变量的代码，而这些代码（暂时）被违反了。正确使用锁可以确保每次只有一个CPU可以对临界区域中的数据结构进行操作，因此当数据结构的不变量不成立时，将没有其他CPU对数据结构执行操作</p><p>妙！</p></blockquote><p>锁的位置对性能也很重要。例如，在<code>push</code>中把<code>acquire</code>的位置提前也是正确的：将<code>acquire</code>移动到第13行之前完全没问题。但这样对<code>malloc</code>的调用也会被串行化，从而降低了性能</p><p>总结：一个非常保守同时也是非常简单的规则：如果两个进程访问了一个共享的数据结构，并且其中一个进程会更新共享的数据结构，那么就需要对于这个共享的数据结构加锁</p><h2 id="如何实现锁？"><a href="#如何实现锁？" class="headerlink" title="如何实现锁？"></a><strong>如何实现锁？</strong></h2><h3 id="自旋锁spinlock"><a href="#自旋锁spinlock" class="headerlink" title="自旋锁spinlock"></a>自旋锁spinlock</h3><p>为什么叫自旋，因为上锁的过程是在一个死循环里面</p><p>结构体定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> &#123;</span><br>  uint locked;       <span class="hljs-comment">// Is the lock held?</span><br><br>  <span class="hljs-comment">// For debugging:</span><br>  <span class="hljs-type">char</span> *name;        <span class="hljs-comment">// Name of lock.</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cpu</span> *<span class="hljs-title">cpu</span>;</span>   <span class="hljs-comment">// The cpu holding the lock.</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>主要关注locked这个字段，为0表示这个锁没有被某个进程持有，为1表示被某个进程持有</li></ul><h4 id="aquire"><a href="#aquire" class="headerlink" title="aquire"></a>aquire</h4><p>一种可能实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spinlock* lk)</span> <span class="hljs-comment">// does not work!</span><br>&#123;<br>  <span class="hljs-keyword">for</span>(;;) &#123;<br>    <span class="hljs-keyword">if</span>(lk-&gt;locked == <span class="hljs-number">0</span>) &#123;<br>      lk-&gt;locked = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这段代码还是有问题<ul><li>执行流是指令级别的，而不是C语言代码级别的，因此这样一段代码反汇编之后就容易看出问题，可能造成两个控制流都判断锁没有被占用</li><li>可能会发生两个CPU同时到达第5行，看到<code>lk-&gt;locked</code>为零，然后都通过执行第6行占有锁。此时就有两个不同的CPU持有锁，从而违反了互斥属性。我们需要的是一种方法，使第5行和第6行作为<strong>原子</strong>（即不可分割）步骤执行。</li></ul></li><li>处理器通常提供实现第5行和第6行的原子版本的指令。RISC-V上是<code>amoswap r,a</code>：这条指令的会把r的值写入a指向的地址，并且将a这个地址原本指向的值写入r，也就是交换了寄存器r和指定内存地址的值</li></ul><p>解决方法：原子操作</p><ul><li><code>__sync_lock_test_and_set</code>：返回值是<code>lk-&gt;locked</code>的旧（交换了的）内容</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(__sync_lock_test_and_set(&amp;lk-&gt;locked,<span class="hljs-number">1</span>) != <span class="hljs-number">0</span> )<span class="hljs-comment">//返回值不为0，表示这个锁一直被持有，因此我们自旋等待</span><br></code></pre></td></tr></table></figure><p>反汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">loop:<br>lw a4,-20(s0)<br>li a5,1<br>amoswap.w.aq a5,a5(a4) #把a4地址指向的内存和a5交换<br>mv a3,a5<br>bnez a3,loop<br></code></pre></td></tr></table></figure><p>为什么要传一个1进去，效果是什么</p><ul><li>如果原来里面的值是1，上锁，那么和1交换没有改变</li><li>如果原来里面的值是0，没有上锁，那么和1交换之后就上锁了</li></ul><p>相当于一条指令就完成上锁和后面的判断</p><p>获取锁后，用于调试，<code>acquire</code>将记录下来获取锁的CPU。<code>lk-&gt;cpu</code>字段受锁保护，只能在保持锁时更改</p><h4 id="release"><a href="#release" class="headerlink" title="release"></a>release</h4><p>与<code>acquire</code>相反：它清除<code>lk-&gt;cpu</code>字段，然后释放锁</p><p>从概念上讲，<code>release</code>只需要将0分配给<code>lk-&gt;locked</code>。</p><p>C标准允许编译器用多个存储指令实现赋值，因此对于并发代码，C赋值可能是非原子的。因此<code>release</code>使用执行原子赋值的C库函数<code>__sync_lock_release</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spinlock*lk)</span>&#123;<br>    ...<br>__sync_lock_release(&amp;lk-&gt;locked);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>反汇编大概如下：就是直接把0写进去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">s1 = &amp;lk-&gt;locked<br>amoswap.w zero, zero, (s1)<br></code></pre></td></tr></table></figure><h3 id="睡眠锁"><a href="#睡眠锁" class="headerlink" title="睡眠锁"></a>睡眠锁</h3><p>有时候需要长时间保持锁。如果另一个进程想要获取自旋锁，那么长时间保持自旋锁会导致获取进程在自旋时浪费很长时间的CPU。</p><p>自旋锁的一个缺点是在自旋等待时不能主动让出CPU，但是我们希望某些持有锁的进程在等待磁盘I/O的时候其他进程可以使用CPU</p><p>为什么自旋锁不能主动让出CPU？</p><ul><li>如果你在持有自旋锁时让出了CPU，然后第二个进程试图获取这个自旋锁，那么就有可能导致死锁</li><li>在持有锁时让步也违反了在持有自旋锁时中断必须关闭的要求。</li></ul><p>因此我们希望有这样一个锁：它在等待获取锁时让出CPU（不自旋），并允许在持有锁时让步（以及中断）</p><p>注意sleeplock是进程级别的，spinlock是CPU级别的？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Long-term locks for processes</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sleeplock</span> &#123;</span><br>  uint locked;       <span class="hljs-comment">// Is the lock held?</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lk</span>;</span> <span class="hljs-comment">// spinlock protecting this sleep lock</span><br>  <br>  <span class="hljs-comment">// For debugging:</span><br>  <span class="hljs-type">char</span> *name;        <span class="hljs-comment">// Name of lock.</span><br>  <span class="hljs-type">int</span> pid;           <span class="hljs-comment">// Process holding lock</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>acquiresleep</code> ( <strong>kernel/sleeplock.c</strong>:22) 在等待时让步CPU</p><p>睡眠锁有一个被<strong>自旋锁</strong>保护的锁定字段，<code>acquiresleep</code>对<code>sleep</code>的调用原子地让出CPU并释放自旋锁。结果是其他线程可以在<code>acquiresleep</code>等待时执行。</p><p>限制：</p><ul><li>因为睡眠锁保持中断使能，所以它们不能用在中断处理程序中</li><li>因为<code>acquiresleep</code>可能会让出CPU，所以睡眠锁不能在自旋锁临界区域中使用（尽管自旋锁可以在睡眠锁临界区域中使用）</li><li>因为等待会浪费CPU时间，所以自旋锁最适合短的临界区域；睡眠锁对于冗长的操作效果很好</li></ul><h2 id="如何使用锁？"><a href="#如何使用锁？" class="headerlink" title="如何使用锁？"></a><strong>如何使用锁？</strong></h2><p>锁的bug有时难以复现，竞争仅仅是可能发生</p><p>使用锁的一个困难部分是决定要使用多少锁，以及每个锁应该保护哪些数据和不变量。</p><p>有几个基本原则：</p><ul><li>任何时候可以被一个CPU写入，同时又可以被另一个CPU读写的变量，都应该使用锁来防止两个操作重叠</li><li>请记住锁保护不变量（invariants）：如果一个不变量涉及多个内存位置，通常所有这些位置都需要由一个锁来保护，以确保不变量不被改变。</li></ul><h3 id="粗粒度锁"><a href="#粗粒度锁" class="headerlink" title="粗粒度锁"></a><strong>粗粒度锁</strong></h3><p>如果并行性不重要，那么可以安排只拥有一个线程，而不用担心锁。一个简单的内核可以在多处理器上做到这一点，方法是拥有一个锁，这个锁必须在进入内核时获得，并在退出内核时释放（尽管如管道读取或<code>wait</code>的系统调用会带来问题）。（一把大锁保平安）</p><p>缺点：牺牲了并行性：一次只能有一个CPU运行在内核中。如果内核做一些繁重的计算，使用一组更细粒度的锁的集合会更有效率，这样内核就可以同时在多个处理器上执行。</p><p>例子：上面所说的kalloc对应的空闲链表，在不同CPU之间是同一个，所以需要单个锁来保护。改进：可以每个CPU一个空闲列表，每个列表都有自己的锁，然后如果某个CPU不够用了，再从另一个CPU调度</p><h3 id="细粒度锁"><a href="#细粒度锁" class="headerlink" title="细粒度锁"></a><strong>细粒度锁</strong></h3><p>xv6对每个文件都有一个单独的锁，这样操作不同文件的进程通常可以不需等待彼此的锁而继续进行</p><p>xv6中的所有锁。</p><table><thead><tr><th><strong>锁</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>bcache.lock</code></td><td>保护块缓冲区缓存项（block buffer cache entries）的分配</td></tr><tr><td><code>cons.lock</code></td><td>串行化对控制台硬件的访问，避免混合输出</td></tr><tr><td><code>ftable.lock</code></td><td>串行化文件表中文件结构体的分配</td></tr><tr><td><code>icache.lock</code></td><td>保护索引结点缓存项（inode cache entries）的分配</td></tr><tr><td><code>vdisk_lock</code></td><td>串行化对磁盘硬件和DMA描述符队列的访问</td></tr><tr><td><code>kmem.lock</code></td><td>串行化内存分配</td></tr><tr><td><code>log.lock</code></td><td>串行化事务日志操作</td></tr><tr><td>管道的<code>pi-&gt;lock</code></td><td>串行化每个管道的操作</td></tr><tr><td><code>pid_lock</code></td><td>串行化next_pid的增量</td></tr><tr><td>进程的<code>p-&gt;lock</code></td><td>串行化进程状态的改变</td></tr><tr><td><code>tickslock</code></td><td>串行化时钟计数操作</td></tr><tr><td>索引结点的 <code>ip-&gt;lock</code></td><td>串行化索引结点及其内容的操作</td></tr><tr><td>缓冲区的<code>b-&gt;lock</code></td><td>串行化每个块缓冲区的操作</td></tr></tbody></table><p>我们想要获得更好的性能，那么我们需要有更多的锁，但是这又引入了大量的工作</p><p>通常来说，开发的流程是：</p><ul><li>先以coarse-grained lock（注，也就是大锁）开始。</li><li>再对程序进行测试，来看一下程序是否能使用多核。</li><li>如果可以的话，那么工作就结束了，你对于锁的设计足够好了；如果不可以的话，那意味着锁存在竞争，多个进程会尝试获取同一个锁，因此它们将会序列化的执行，性能也上不去，之后你就需要重构程序。</li></ul><p>例子：xv6的yield函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Give up the CPU for one scheduling round.</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">yield</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>    acquire(&amp;p-&gt;lock);<br>    p-&gt;state = RUNNABLE; <br>    sched();<br>    release(&amp;p-&gt;lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，在锁释放之前，进程的状态会变得不一致，例如，yield将要将进程的状态改为RUNABLE，表明进程并没有在运行，但是实际上这个进程还在运行，代码正在当前进程的内核线程中运行。</p><p>所以这里加锁的目的之一就是：即使我们将进程的状态改为了RUNABLE，其他的CPU核的调度器线程也不可能看到进程的状态为RUNABLE并尝试运行它。否则的话，进程就会在两个CPU核上运行了</p><h2 id="死锁和锁排序"><a href="#死锁和锁排序" class="headerlink" title="死锁和锁排序"></a>死锁和锁排序</h2><p>如果在内核中执行的代码路径必须同时持有数个锁，那么所有代码路径以相同的顺序获取这些锁是很重要的</p><p>如果不以相同的顺序获取锁，可能导致死锁：</p><ul><li>假设xv6中的两个代码路径需要锁A和B，</li><li>代码路径1按照先A后B的顺序获取锁</li><li>另一个路径按照先B后A的顺序获取锁</li><li>假设线程T1执行代码路径1并获取锁A，线程T2执行代码路径2并获取锁B。接下来T1将尝试获取锁B，T2将尝试获取锁A。两个获取都将无限期阻塞，因为在这两种情况下，另一个线程都持有所需的锁，并且不会释放它，直到它的获取返回。</li></ul><p>全局锁获取顺序的需求意味着锁实际上是每个<strong>函数规范的一部分</strong>：调用者必须以一种使锁按照约定顺序被获取的方式调用函数。</p><p>多的锁通常意味着更多的死锁可能性</p><p>不过在设计一个操作系统的时候，定义一个全局的锁的顺序会有些问题。如果一个模块m1中方法g调用了另一个模块m2中的方法f，那么m1中的方法g需要知道m2的方法f使用了哪些锁。因为如果m2使用了一些锁，那么m1的方法g必须集合f和g中的锁，并形成一个全局的锁的排序。这意味着在m2中的锁必须对m1可见，这样m1才能以恰当的方法调用m2。</p><p>但是这样又违背了代码抽象的原则。在完美的情况下，代码抽象要求m1完全不知道m2是如何实现的。但是不幸的是，具体实现中，m2内部的锁需要泄露给m1，这样m1才能完成全局锁排序。所以当你设计一些更大的系统时，锁使得代码的模块化更加的复杂了</p><p>没有必要对所有的锁进行一个全局的排序，但是所有的函数需要对共同使用的一些锁进行一个排序。</p><p><code>clockintr</code>定时器中断处理程序在增加<code>ticks</code>(<strong>kernel/trap.c</strong>：163)的同时内核线程可能在<code>sys_sleep</code>(ker<strong>nel/sysproc.c</strong>：64)中读取<code>ticks</code>。锁<code>tickslock</code>串行化这两个访问。</p><h3 id="中断和死锁"><a href="#中断和死锁" class="headerlink" title="中断和死锁"></a>中断和死锁</h3><p>假设<code>sys_sleep</code>持有<code>tickslock</code>，并且它的CPU被计时器中断中断。<code>clockintr</code>会尝试获取<code>tickslock</code>，意识到它被持有后等待释放。在这种情况下，<code>tickslock</code>永远不会被释放：只有<code>sys_sleep</code>可以释放它，但是<code>sys_sleep</code>直到<code>clockintr</code>返回前不能继续运行。所以CPU会死锁，任何需要锁的代码也会冻结。</p><p>解决办法：如果一个自旋锁被中断处理程序所使用，那么CPU必须保证在启用中断的情况下永远不能持有该锁（也就是你不能在进入中断前拿走别人的锁）</p><p>xv6的解决方法是：当CPU获取任何锁时，xv6总是禁用该CPU上的中断。直到release该锁的时候才开启中断。中断仍然可能发生在其他CPU上，此时中断的<code>acquire</code>可以等待线程释放自旋锁；由于中断不在同一CPU上，不会造成死锁。</p><p><code>acquire</code>调用<code>push_off </code>(kernel/spinlock.c:89) 并且<code>release</code>调用<code>pop_off </code>(kernel/spinlock.c:100)来跟踪当前CPU上锁的嵌套级别。当计数达到零时，<code>pop_off</code>恢复最外层临界区域开始时存在的中断使能状态。<code>intr_off</code>和<code>intr_on</code>函数执行RISC-V指令分别用来禁用和启用中断。</p><p>严格的在设置<code>lk-&gt;locked</code> (kernel/spinlock.c:28)之前让<code>acquire</code>调用<code>push_off</code>是很重要的。如果两者颠倒，会存在一个既持有锁又启用了中断的短暂窗口期，不幸的话定时器中断会使系统死锁。同样，只有在释放锁之后，<code>release</code>才调用<code>pop_off</code>也是很重要的( kernel/spinlock.c:66)。</p><h2 id="指令和内存访问顺序"><a href="#指令和内存访问顺序" class="headerlink" title="指令和内存访问顺序"></a>指令和内存访问顺序</h2><p>我们自然地会想到程序是按照源代码语句出现的顺序执行的。然而，许多编译器和中央处理器为了获得更高的性能而不按顺序执行代码。</p><p>如果一条指令需要许多周期才能完成，中央处理器可能会提前发出指令，这样它就可以与其他指令重叠，避免中央处理器停顿</p><p>例如，中央处理器可能会注意到在顺序指令序列A和B中彼此不存在依赖。CPU也许首先启动指令B，或者是因为它的输入先于A的输入准备就绪，或者是为了重叠执行A和B。编译器可以执行类似的重新排序，方法是在源代码中一条语句的指令发出之前，先发出另一条语句的指令。</p><p>例如，在<code>push</code>的代码中，如果编译器或CPU将对应于第4行的存储指令移动到第6行<code>release</code>后的某个地方，那将是一场灾难：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">l = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span> *l);<br>l-&gt;data = data;<br>acquire(&amp;listlock);<br>l-&gt;next = <span class="hljs-built_in">list</span>;<br><span class="hljs-built_in">list</span> = l;<br>release(&amp;listlock);<br></code></pre></td></tr></table></figure><p>如果发生这样的重新排序，将会有一个窗口期，另一个CPU可以获取锁并查看更新后的<code>list</code>，但却看到一个未初始化的<code>list-&gt;next</code>。</p><p>为了避免这样的重新排序，使用<code>__sync_synchronize()</code></p><ul><li>是一个内存障碍：它告诉编译器和CPU不要跨障碍重新排序<code>load</code>或<code>store</code>指令</li><li>强制顺序执行</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>xv6 lock</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6-multithread-switch</title>
    <link href="/2024/05/28/xv6-multithread-switch/"/>
    <url>/2024/05/28/xv6-multithread-switch/</url>
    
    <content type="html"><![CDATA[<p>xv6任务切换详细分析，可以说是我认为xv6中最难的几个点之一，涉及到很多跳转，锁的运用</p><span id="more"></span><h1 id="chapter7-多线程"><a href="#chapter7-多线程" class="headerlink" title="chapter7 多线程"></a>chapter7 多线程</h1><blockquote><p>进程和线程在这里好像没有特别做区分？是吗</p><p>一个进程对应一个线程</p><p>Linux，允许在一个用户进程中包含多个线程，进程中的多个线程共享进程的地址空间</p><p>学生提问：我们这里一直在说线程，但是从我看来XV6的实现中，一个进程就只有一个线程，有没有可能一个进程有多个线程？</p><p>Robert教授：我们这里的用词的确有点让人混淆。在XV6中，一个进程要么在用户空间执行指令，要么是在内核空间执行指令，要么它的状态被保存在context和trapframe中，并且没有执行任何指令。这里该怎么称呼它呢？你可以根据自己的喜好来称呼它，对于我来说，每个进程有两个线程，一个用户空间线程，一个内核空间线程，并且存在限制使得一个进程要么运行在用户空间线程，要么为了执行系统调用或者响应中断而运行在内核空间线程 ，但是永远也不会两者同时运行。</p></blockquote><h2 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h2><h3 id="为什么需要线程"><a href="#为什么需要线程" class="headerlink" title="为什么需要线程"></a>为什么需要线程</h3><ul><li>有可能计算机需要执行分时复用的任务，例如MIT的公共计算机系统Athena允许多个用户同时登陆一台计算机，并运行各自的进程。</li><li>多线程可以让程序的结构变得简单（比如fork实现素数筛）</li><li>使用多线程可以通过并行运算，在拥有多核CPU的计算机上获得更快的处理速度</li></ul><p>一个线程可以认为是串行执行代码的单元，它<strong>只占用一个CPU</strong>并且以普通的方式一个接一个的执行指令</p><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>我们可以随时保存线程的状态并暂停线程的运行，并在之后通过恢复状态来恢复线程的运行</p><ul><li>PC寄存器，表示当前线程执行指令的位置</li><li>保存变量的寄存器</li><li>栈（通常来说每个线程都有属于自己的stack）</li></ul><h3 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h3><p>我们主要关注一个CPU在多个线程之间来回切换</p><p>多个线程都在这一个地址空间内运行，并且它们可以看到彼此的更新。比如说共享一个地址空间的线程修改了一个变量，共享地址空间的另一个线程可以看到变量的修改。所以当多个线程运行在一个共享地址空间时，我们需要用到锁。</p><p>XV6内核共享了内存，并且XV6支持内核线程的概念，对于每个用户进程都有一个内核线程来执行来自用户进程的系统调用。所有的内核线程都共享了内核内存，所以XV6的内核线程的确会共享内存</p><p>另一方面，XV6还有另外一种线程。每一个用户进程都有独立的内存地址空间，并且包含了一个线程，这个线程控制了用户进程代码指令的执行。所以XV6中的用户线程之间没有共享内存</p><blockquote><p>还有一些其他的方式可以支持在一台计算机上交织的运行多个任务，可以搜索event-driven programming或者state machine</p></blockquote><h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><blockquote><p>主要解决：</p><ol><li>如何实现线程切换，停止一个线程的运行然后启动另一个线程的运行？</li><li>切换线程时涉及到保存和回复线程状态，你要决定哪些信息是必须保存的，在哪里保存？ context上下文，保存在proc或者cpu中</li><li>如何处理运算密集型线程（compute bound thread），这样的线程并不能自愿的出让CPU给其他的线程运行。所以这里需要能从长时间运行的运算密集型线程撤回对于CPU的控制，将其放置于一边，稍后再运行它</li></ol></blockquote><p>如何处理运算密集型线程（我的理解就是长时间占用CPU的线程）：</p><p>利用定时器中断。位于内核的定时器中断处理程序，会自愿的将CPU出让（yield）给线程调度器，并告诉线程调度器说，你可以让一些其他的线程运行了。</p><p>基本流程是，定时器中断将CPU控制权给到内核，内核再自愿的出让CPU</p><p>XV6为<strong>每个CPU</strong>核都创建了一个线程调度器（Scheduler），他本身就是一个线程，不过专门用来调度的。每个线程都运行<code>scheduler</code>函数</p><p>在执行线程调度的时候，操作系统需要能<strong>区分几类线程</strong>：</p><ul><li>RUNNING：当前在CPU上运行的线程</li><li>RUNABLE：一旦CPU有空闲时间就想要运行在CPU上的线程</li><li>SLEEPING：以及不想运行在CPU上的线程，因为这些线程可能在等待I/O或者其他事件</li></ul><p>定时器中断实际上就是把一个RUNNING线程转换成一个RUNABLE线程</p><p>当用户程序在运行时，实际上是用户进程中的一个用户线程在运行</p><p>如果XV6内核决定从一个用户进程a切换到另一个用户进程b</p><ul><li><p>第一个用户进程a通过中断/系统调用等从用户空间陷入内核空间，此时是他对应的内核线程 a’</p></li><li><p>内核线程 a’ 通过swtch函数切换到了调度器线程，调度器线程执行scheduler来寻找要切换到的线程b</p></li><li><p>调度器线程通过swtch函数切换到了另一个用户进程b</p></li><li><p>之后再在第二个进程的内核线程中返回到用户空间的第二个进程，这里返回也是通过恢复trapframe中保存的用户进程状态完成。</p></li></ul><blockquote><p>为什么需要一个调度器线程作为媒介？</p><p>因为我们要执行调度程序scheduler，如果在旧进程的内核栈上执行是不安全的：其他一些核心可能会唤醒进程并运行它，而在两个不同的核心上使用同一个栈将是一场灾难，因此需要一个专门的调度线程专门调度</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405281501825.png" alt="img"></p><p>也就是在XV6中，任何时候都需要经历：</p><ol><li>从一个用户进程切换到另一个用户进程，都需要从第一个用户进程接入到内核中，保存用户进程的状态并运行第一个用户进程的内核线程。</li><li>再从第一个用户进程的内核线程切换到第二个用户进程的内核线程。</li><li>之后，第二个用户进程的内核线程暂停自己，并恢复第二个用户进程的用户寄存器。</li><li>最后返回到第二个用户进程继续执行。</li></ol><p>一个线程切换的例子：</p><p>时钟中断在usertrap中调用了yield -&gt; yield调用sched -&gt; sched调用swtch保存当前上下文，并且切换到调度器线程的上下文 -&gt; 调度器执行调度程序scheduler找到一个可以运行的进程 -&gt; 然后调度器线程swtch到找到的线程 -&gt; 如果找到的这个线程以前执行过，那么他一定也是从swtch这里进入的（因为如果要暂停这个进程需要任务调度使用swtch切换），现在返回也是到他以前调用swtch指令的地方</p><p><strong>以<code>cc</code>切换到<code>ls</code>为例，且<code>ls</code>此前运行过</strong></p><ol><li><p>XV6将<code>cc</code>程序的内核线程的内核寄存器保存在一个<code>context</code>对象中</p></li><li><p>因为要切换到<code>ls</code>程序的内核线程，那么<code>ls</code> 程序现在的状态必然是<code>RUNABLE</code> ，表明<code>ls</code>程序之前运行了一半。这同时也意味着：</p><p>a. <code>ls</code>程序的用户空间状态已经保存在了对应的trapframe中</p><p>b. <code>ls</code>程序的内核线程对应的内核寄存器已经保存在对应的<code>context</code>对象中</p><p>所以接下来，XV6会恢复<code>ls</code>程序的内核线程的<code>context</code>对象，也就是恢复内核线程的寄存器。</p></li><li><p>之后<code>ls</code>会继续在它的内核线程栈上，完成它的中断处理程序</p></li><li><p>恢复<code>ls</code>程序的trapframe中的用户进程状态，返回到用户空间的<code>ls</code>程序中</p></li><li><p>最后恢复执行<code>ls</code></p></li></ol><h3 id="线程切换的核心函数"><a href="#线程切换的核心函数" class="headerlink" title="线程切换的核心函数"></a>线程切换的核心函数</h3><p><code>void swtch(struct context *old, struct context *new)</code>（switch 是C 语言关键字，因此这个函数命名为swtch 来避免冲突）：这是用汇编来写的</p><ul><li><p><code>swtch</code>函数会保存用户进程 P1 对应内核线程的寄存器至<code>context</code>对象。</p><p>所以目前为止有两类寄存器：</p><ul><li>用户寄存器存在<code>trapframe</code>中</li><li>内核线程的寄存器存在<code>context</code>中</li></ul></li><li><p>实现很简单，就是把当前<code>context</code>里面的寄存器保存在以<code>a0(old)</code>为基址的地方，然后从<code>a1(new)</code>里面恢复寄存器的值</p></li><li><p>实际上<code>swtch</code>函数并不是直接从一个内核线程切换到另一个内核线程。XV6中，一个CPU上运行的内核线程可以直接切换到的是这个CPU对应的<strong>调度器线程</strong></p></li><li><p>所以如果我们运行在CPU0，<code>swtch</code>函数会恢复CPU0的调度器线程保存的寄存器和stack pointer，之后就在调度器线程的context下执行schedulder函数中</p><ul><li><p><strong>为什么会跳到scheduler函数</strong>呢，调度器线程的 ra 事先保存的</p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405281503145.png" alt="image-20240528150342109"></p><p>调度器线程的ra被设置为了scheduler函数的入口，从而在swtch返回时通过ra跳到了这里</p></li></ul></li><li><p>为什么RISC-V中有32个寄存器，但是swtch函数中只保存并恢复了14个寄存器？</p><blockquote><p>学生回答：因为switch是按照一个普通函数来调用的，对于有些寄存器，swtch函数的调用者默认swtch函数会做修改，所以调用者已经在自己的栈上保存了这些寄存器，当函数返回时，这些寄存器会自动恢复。所以swtch函数里只需要保存Callee Saved Register就行</p></blockquote></li><li><p>为什么swtch函数要用汇编来实现，而不是C语言？</p><p>Robert教授：C语言中很难与寄存器交互。可以肯定的是C语言中没有方法能更改sp、ra寄存器。所以在普通的C语言中很难完成寄存器的存储和加载，唯一的方法就是在C中嵌套汇编语言。所以我们也可以在C函数中内嵌switch中的指令，但是这跟我们直接定义一个汇编函数是一样的。或者说swtch函数中的操作是在C语言的层级之下，所以并不能使用C语言</p></li><li><p>swtch函数是线程切换的核心，但是swtch函数中只有保存寄存器，再加载寄存器的操作。线程除了寄存器以外的还有<a href="###%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81">很多其他状态</a>，它有变量，堆中的数据等等，但是所有的这些数据<strong>都在内存中</strong>，并且会保持不变</p><p>我们没有改变线程的任何栈或者堆数据。所以线程切换的过程中，<strong>处理器中的寄存器是唯一的不稳定状态</strong>，且需要保存并恢复。而所有其他在内存中的数据会保存在内存中不被改变，所以不用特意保存并恢复。我们只是保存并恢复了处理器中的寄存器，因为我们想在新的线程中也使用相同的一组寄存器。</p></li><li><p>值得注意的是，调用swtch之前，都持有<code>p-&gt;lock</code>这个锁，很疑惑，按照常理来说一般获取锁的线程还要负责释放锁，但是这里是swtch了，把释放锁的工作交给切换的线程，why？</p><ul><li><p>因为<code>p-&gt;lock</code>保护进程<code>state</code>和<code>context</code>字段上的不变量，而这些不变量在<code>swtch</code>中执行时不成立</p><ul><li>如果在<code>swtch</code>期间没有保持<code>p-&gt;lock</code>，可能会出现一个问题：在<code>yield</code>将其状态设置为<code>RUNNABLE</code>之后，但在<code>swtch</code>使其停止使用自己的内核栈之前，另一个CPU可能会决定运行该进程（因为他看到这个进程的状态是<code>RUNNABLE</code>）。结果将是两个CPU在同一栈上运行，这是致命的</li></ul></li><li><p>这也是为什么在 forkret 最开头需要 release 锁，锁都是在这里释放的吗？</p></li></ul></li><li><p>考虑调度代码结构的一种方法是，它为每个进程强制维持一个不变量的集合，并在这些不变量不成立时持有<code>p-&gt;lock</code></p></li></ul><p><code>void scheduler(void)</code>：</p><ul><li><p>通过进程表单找到下一个RUNABLE进程P2，然后swtch到这个找到的进程</p><ol><li><p>先保存自己的寄存器到调度器线程的context对象</p></li><li><p>找到进程P2之前保存的context，恢复其中的寄存器</p></li><li><p>因为进程P2在进入RUNABLE状态之前，如刚刚介绍的进程P1一样，必然也调用了swtch函数。所以之前的swtch函数会被恢复，并返回到进程P2所在的系统调用或者中断处理程序中（注，<strong>因为P2进程之前调用swtch函数必然在系统调用或者中断处理程序中</strong>）。</p></li><li><p>不论是系统调用也好中断处理程序也好，在从用户空间进入到内核空间时会保存用户寄存器到trapframe对象。所以当内核程序执行完成之后，trapframe中的用户寄存器会被恢复。</p></li><li><p>最后用户进程P2就恢复运行了。</p></li></ol></li></ul><p><code>void sched(void)</code>：做一些合理性检查，发现异常则panic，然后swtch到当前CPU的调度器线程</p><ul><li>检查：想要放弃CPU的进程必须先获得自己的进程锁<code>p-&gt;lock</code>，并释放它持有的任何其他锁，更新自己的状态（<code>p-&gt;state</code>）</li><li>并检查这些条件的隐含条件：由于锁被持有，中断应该被禁用</li></ul><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>内核线程总是在<code>sched</code>中放弃其CPU，并总是切换到调度程序中的同一位置，而调度程序（几乎）总是切换到以前调用<code>sched</code>的某个内核线程。在两个线程之间进行这种样式化切换的过程有时被称为<strong>协程</strong>（coroutines），XV6中 sched<code>和</code>scheduler`是彼此的协同程序。</p><p>调度器线程——内核线程的一种</p><ul><li>每一个CPU都有一个完全不同的调度器线程。调度器线程也是一种内核线程，它也有自己的context对象。任何运行在CPU1上的进程，当它决定让出CPU，它都会切换到CPU1对应的调度器线程，并由调度器线程切换到下一个进程。</li><li>每一个调度器线程都有自己独立的栈。这个栈是在<code>entry.S</code>设置的调度器线程栈，即调度器线程运行在CPU对应的bootstack上</li></ul><p>context保存在哪？（每一个内核线程都有一个context对象）</p><ul><li>用户线程对应的内核线程：保存在用户进程对应的proc结构体中</li><li>调度器线程：没有对应的进程和proc结构体，所以调度器线程的context对象保存在cpu结构体中</li></ul><p>在XV6的代码中，context对象总是由swtch函数产生，所以context总是保存了内核线程在执行swtch函数时的状态。当我们在恢复一个内核线程时，对于刚恢复的线程所做的第一件事情就是从之前的swtch函数中返回</p><p>调度器线程调用了swtch函数，但是我们从swtch函数返回时，实际上是返回到了对于swtch的另一个调用，而不是调度器线程中的调用。我们返回到的是pid为4的进程在很久之前对于switch的调用。这里可能会有点让人困惑，但是这就是线程切换的核心。</p><h2 id="xv6线程第一次调用swtch函数"><a href="#xv6线程第一次调用swtch函数" class="headerlink" title="xv6线程第一次调用swtch函数"></a>xv6线程第一次调用swtch函数</h2><p>思考一下swtch函数，实际上是从一个线程对于swtch的调用返回到了另一个线程对于swtch的调用（通过保存的ra）。那么线程第一次调用swtch函数时，需要伪造一个“另一个线程”对于switch的调用，是吧？因为也不能通过swtch函数随机跳到其他代码去。</p><p>那么特别重要的就是ra，swtch通过这个返回</p><p>在创建一个线程时，<code>allocproc</code>会设置好它的pid，trapframe page，user page table，然后是context</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> proc*<br><span class="hljs-title function_">allocproc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    ...<br>  <span class="hljs-comment">// Set up new context to start executing at forkret,</span><br>  <span class="hljs-comment">// which returns to user space.</span><br>  <span class="hljs-built_in">memset</span>(&amp;p-&gt;context, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(p-&gt;context));<br>  p-&gt;context.ra = (uint64)forkret;<br>  p-&gt;context.sp = p-&gt;kstack + PGSIZE; <br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>可以看到 ra 被设置为了 forkret，说明第一次swtch到这个新的线程时都会返回forkret的开头</p></li><li><p>forkret只会在启动线程的时候以这种看起来奇怪的方式运行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">forkret</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">static</span> <span class="hljs-type">int</span> first = <span class="hljs-number">1</span>;<br><br>  <span class="hljs-comment">// Still holding p-&gt;lock from scheduler.</span><br>  release(&amp;myproc()-&gt;lock);<br><br>  <span class="hljs-keyword">if</span> (first) &#123;<br>    <span class="hljs-comment">// File system initialization must be run in the context of a</span><br>    <span class="hljs-comment">// regular process (e.g., because it calls sleep), and thus cannot</span><br>    <span class="hljs-comment">// be run from main().</span><br>    first = <span class="hljs-number">0</span>;<br>    fsinit(ROOTDEV);<br>  &#125;<br><br>  usertrapret();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>释放调度器之前获取的锁</p></li><li><p>if(first)是什么意思？</p><ul><li>XV6只能在进程的context下执行文件系统操作，比如等待I/O。所以初始化文件系统需要等到我们有了一个进程才能进行。而这一步是在第一次调用forkret时完成的，所以在forkret中才有了if(first)判断</li></ul></li><li><p>forkret 其实伪造了我们从usertrapret，使程序看起来像从trap中返回，跳到用户的第一个指令，注意pc需要被设置为0</p></li><li><p>因为fork拷贝的进程会同时拷贝父进程的程序计数器，所以我们唯一不是通过fork创建进程的场景就是创建第一个进程的时候。这时需要设置程序计数器为0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Set up first user process.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">userinit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br><br>  p = allocproc();<br>  initproc = p;<br>  <br>  <span class="hljs-comment">// allocate one user page and copy initcode&#x27;s instructions</span><br>  <span class="hljs-comment">// and data into it.</span><br>  uvmfirst(p-&gt;pagetable, initcode, <span class="hljs-keyword">sizeof</span>(initcode));<br>  p-&gt;sz = PGSIZE;<br><br>  <span class="hljs-comment">// prepare for the very first &quot;return&quot; from kernel to user.</span><br>  p-&gt;trapframe-&gt;epc = <span class="hljs-number">0</span>;      <span class="hljs-comment">// user program counter</span><br>  p-&gt;trapframe-&gt;sp = PGSIZE;  <span class="hljs-comment">// user stack pointer</span><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到把epc设置为了0</p></li></ul></li></ul><p>具体示例可以看<a href="https://www.bilibili.com/video/BV1rS4y1n7y1/?p=10&vd_source=7a39dbfc457222c1894595f42f7958fd">Lecture 11 - Thread Switching 中文版_哔哩哔哩_bilibili</a></p><p>44分之后</p>]]></content>
    
    
    
    <tags>
      
      <tag>任务切换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>latex in typora</title>
    <link href="/2024/05/25/latex-in-typora/"/>
    <url>/2024/05/25/latex-in-typora/</url>
    
    <content type="html"><![CDATA[<p>在typora编辑器使用latex公式，基本的语法，用来当自用手册查询</p><span id="more"></span><p>参考<a href="https://blog.csdn.net/happyday_d/article/details/83715440">Typora中利用LaTeX 插入数学公式_typora插入latex公式-CSDN博客</a></p><h3 id="hexo开启latex渲染功能"><a href="#hexo开启latex渲染功能" class="headerlink" title="hexo开启latex渲染功能"></a>hexo开启latex渲染功能</h3><ol><li><p><strong>安装Hexo-Math</strong>: Hexo-Math是Hexo的一个插件，它支持LaTeX数学公式，并且可以通过MathJax来渲染。</p><p>打开终端或命令提示符，进入您的Hexo项目目录，然后运行以下命令来安装Hexo-Math：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> hexo-<span class="hljs-keyword">math</span> --save<br></code></pre></td></tr></table></figure></li><li><p><strong>配置Hexo主配置文件</strong>: 打开您的Hexo配置文件（通常是<code>_config.yml</code>），然后添加或修改以下配置项：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">math:<br>  enable: true<br>  engine: mathjax<br>  mathjax:<br>    cdn: <span class="hljs-regexp">//</span>cdnjs.cloudflare.com<span class="hljs-regexp">/ajax/</span>libs<span class="hljs-regexp">/mathjax/</span><span class="hljs-number">2.7</span>.<span class="hljs-number">9</span>/MathJax.js?config=TeX-AMS-MML_HTMLorMML<br></code></pre></td></tr></table></figure><p>这里<code>enable: true</code>表示启用数学公式支持，<code>engine: mathjax</code>指定使用MathJax引擎，<code>cdn</code>是MathJax的CDN链接。</p></li><li><p>然后在要使用的md文档添加 <code>math: true</code> ，不要忘记这个了</p></li></ol><h3 id="LaTeX-编辑数学公式基本语法元素"><a href="#LaTeX-编辑数学公式基本语法元素" class="headerlink" title="LaTeX 编辑数学公式基本语法元素"></a>LaTeX 编辑数学公式基本语法元素</h3><p>数学公式有两种形式： inline 和 display</p><ul><li><p><strong>inline（行间公式）</strong>：在正文插入数学公式，用<code>$...$</code> 将公式括起来</p></li><li><p><strong>display(快间公式)</strong> ：独立排列的公式，用 <code>$$...$$</code>将公式括起来，默认显示在行中间</p></li><li><p><strong>各类希腊字母表：</strong></p><p>eg: <code>$\alpha$</code>：$\alpha$</p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405252342080.jpeg" alt="在这里插入图片描述"></p></li></ul><h4 id="上下标、根号、省略号"><a href="#上下标、根号、省略号" class="headerlink" title="上下标、根号、省略号"></a>上下标、根号、省略号</h4><ul><li><p><strong>下标：</strong><code>_</code> eg:  $x_2$</p></li><li><p><strong>上标：</strong><code>^</code> eg: $x^2$</p><p>注意：上下标如果多于一个字母或者符号，需要用一对{}括起来 </p><p>eg： $x_{il}$ 、$x^{2y}$</p></li><li><p><strong>根号：</strong>\sqrt eg:  $\sqrt{5}$</p></li><li><p><strong>省略号：</strong>\dots \cdots 分别表示  $\dots$  $ \cdots$</p></li></ul><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p><strong>基本预算符：</strong> $\pm$     $\div$</p><ul><li><h5 id="求和：-sum-1-n-：-sum-1-n"><a href="#求和：-sum-1-n-：-sum-1-n" class="headerlink" title="求和： \sum_1^n ： $\sum_1^n$"></a><strong>求和：</strong> \sum_1^n ： $\sum_1^n$</h5></li><li><p><strong>积分：</strong>\int_1^n： $\int_1^n$</p></li><li><p><strong>极限：</strong>lim_{x \to \infty} :  $ lim_{x \to \infty}$</p></li><li><p><strong>分数：</strong>\frac{}{} 如：  $\frac{3}{8}$</p></li><li><p><strong>矩阵与行列式</strong></p><p>矩阵：<code>$$\begin&#123;matrix&#125;...\end&#123;matrix&#125;$$</code> </p><ul><li>使用<code>&amp;</code>分隔同行元素</li><li><code>\ </code>换行。</li></ul><p>$$ \begin{matrix} 1 &amp; x &amp; x^2\ 1 &amp; y &amp; y^2\ 1 &amp; z &amp; z^2\ \end{matrix} $$</p></li><li><p><strong>行列式</strong>：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br>X=<span class="hljs-keyword">\left</span>|<br><span class="hljs-keyword">\begin</span>&#123;matrix&#125;<br>x<span class="hljs-built_in">_</span>&#123;11&#125; <span class="hljs-built_in">&amp;</span> x<span class="hljs-built_in">_</span>&#123;12&#125; <span class="hljs-built_in">&amp;</span> <span class="hljs-keyword">\cdots</span> <span class="hljs-built_in">&amp;</span> x<span class="hljs-built_in">_</span>&#123;1d&#125;<span class="hljs-keyword">\\</span><br>x<span class="hljs-built_in">_</span>&#123;21&#125; <span class="hljs-built_in">&amp;</span> x<span class="hljs-built_in">_</span>&#123;22&#125; <span class="hljs-built_in">&amp;</span> <span class="hljs-keyword">\cdots</span> <span class="hljs-built_in">&amp;</span> x<span class="hljs-built_in">_</span>&#123;2d&#125;<span class="hljs-keyword">\\</span><br><span class="hljs-keyword">\vdots</span> <span class="hljs-built_in">&amp;</span> <span class="hljs-keyword">\vdots</span> <span class="hljs-built_in">&amp;</span> <span class="hljs-keyword">\ddots</span> <span class="hljs-built_in">&amp;</span> <span class="hljs-keyword">\vdots</span> <span class="hljs-keyword">\\</span><br>x<span class="hljs-built_in">_</span>&#123;11&#125; <span class="hljs-built_in">&amp;</span> x<span class="hljs-built_in">_</span>&#123;12&#125; <span class="hljs-built_in">&amp;</span> <span class="hljs-keyword">\cdots</span> <span class="hljs-built_in">&amp;</span> x<span class="hljs-built_in">_</span>&#123;1d&#125;<span class="hljs-keyword">\\</span><br><span class="hljs-keyword">\end</span>&#123;matrix&#125;<br><span class="hljs-keyword">\right</span>|<br><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br></code></pre></td></tr></table></figure></li></ul><p>$$<br>\left|<br>    \begin{matrix}<br>        x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1d}\<br>        x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2d}\<br>        \vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>        x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1d}\<br>    \end{matrix}<br>\right|<br>$$</p><ul><li><p><strong>分隔符</strong></p><p>各种括号用 () [] { } \langle\rangle 等命令表示,注意花括号通常用来输入命令和环境的参数,所以在数学公式中它们前面要加 \。可以在上述分隔符前面加 \big \Big \bigg \Bigg 等命令来调整大小。</p></li><li><p><strong>箭头</strong></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-built_in">$</span><span class="hljs-keyword">\leftarrow</span><span class="hljs-built_in">$</span><br></code></pre></td></tr></table></figure><p>$\leftarrow$</p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405252335111.jpeg" alt="在这里插入图片描述"></p></li><li><p><strong>方程式</strong></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">E=mc<span class="hljs-built_in">^</span>2<br></code></pre></td></tr></table></figure><p>$E=mc^2$</p></li><li><p><strong>分段函数</strong>：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br>f(n)=<br><span class="hljs-keyword">\begin</span>&#123;cases&#125;<br>n/2, <span class="hljs-built_in">&amp;</span> <span class="hljs-keyword">\text</span>&#123;if <span class="hljs-built_in">$</span>n<span class="hljs-built_in">$</span> is even&#125;<span class="hljs-keyword">\\</span><br>3n+1,<span class="hljs-built_in">&amp;</span> <span class="hljs-keyword">\text</span>&#123;if <span class="hljs-built_in">$</span>n<span class="hljs-built_in">$</span> is odd&#125;<br><span class="hljs-keyword">\end</span>&#123;cases&#125;<br><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br></code></pre></td></tr></table></figure><p>$$<br>f(n)=</p><pre><code class="hljs">\begin&#123;cases&#125;    n/2, &amp; \text&#123;if $n$ is even&#125;\\    3n+1,&amp; \text&#123;if $n$ is odd&#125;\end&#123;cases&#125;</code></pre><p>$$</p></li><li><p><strong>方程组</strong></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br><span class="hljs-keyword">\left</span><span class="hljs-keyword">\&#123;</span><br><span class="hljs-keyword">\begin</span>&#123;array&#125;&#123;c&#125;<br>a<span class="hljs-built_in">_</span>1x+b<span class="hljs-built_in">_</span>1y+c<span class="hljs-built_in">_</span>1z=d<span class="hljs-built_in">_</span>1<span class="hljs-keyword">\\</span><br>a<span class="hljs-built_in">_</span>2x+b<span class="hljs-built_in">_</span>2y+c<span class="hljs-built_in">_</span>2z=d<span class="hljs-built_in">_</span>2<span class="hljs-keyword">\\</span><br>a<span class="hljs-built_in">_</span>3x+b<span class="hljs-built_in">_</span>3y+c<span class="hljs-built_in">_</span>3z=d<span class="hljs-built_in">_</span>3<br><span class="hljs-keyword">\end</span>&#123;array&#125;<br><span class="hljs-keyword">\right</span>.<br><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br></code></pre></td></tr></table></figure></li></ul><p>$$<br>\left{<br>\begin{array}{c}<br>a_1x+b_1y+c_1z=d_1\<br>a_2x+b_2y+c_2z=d_2\<br>a_3x+b_3y+c_3z=d_3<br>\end{array}<br>\right.<br>$$</p>]]></content>
    
    
    
    <tags>
      
      <tag>latex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RVOS的trap</title>
    <link href="/2024/05/10/RVOS%E7%9A%84trap/"/>
    <url>/2024/05/10/RVOS%E7%9A%84trap/</url>
    
    <content type="html"><![CDATA[<p>看 xv6 的代码有点迷惑了，对于需要看 qemu 手册和 RISC-V 手册的实现不太懂，来汪辰老师的 RVOS 课程补一补，讲的真好，很精妙的设计！</p><span id="more"></span><h2 id="05-trap和中断"><a href="#05-trap和中断" class="headerlink" title="05 trap和中断"></a>05 trap和中断</h2><p>mtvec 的 两种模式</p><ul><li><p>dircet：</p></li><li><p>vector：一张中断向量表，处理效率更高</p></li></ul><p>分清什么是硬件自动执行的，什么是我们手动来实现的，才知道怎么code</p><blockquote><p>处理 trap 的时候我们可以修改 mepc 的值达到改变 mret 返回地址的目的</p></blockquote><p>mtval辅助 mcause来告诉我们异常或者中断更加详细的信息</p><p>mpp占两位，因为可能是 m,s,u 这三个特权级要用 2 bit表示</p><p>没有 upp （因为他只有一种可能：自己陷入自己）</p><p><strong>RISC-V Trap 处理流程</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405102021280.png" alt="image-20240510202113155"></p><p>top half是不受我们控制的，硬件发生的过程</p><ul><li>把 mstatus 的 MIE 值复制到 MPIE 中，清除 mstatus 中的 MIE 标 志位，效果是中断被禁止。</li><li>设置 mepc ，同时 PC 被设置为 mtvec。（<strong>需要注意的是，对于 exception， mepc 指向导致异常的指令；对于 interrupt，它指向被 中断的指令的下一条指令的位置。</strong>）<ul><li>为什么要这样设置？ 发生异常的时候相当于给了你一个机会，你可以执行你的异常处理函数，你可以在这里面解决掉你的异常，例子：缺页异常 </li><li>而中断一般是外设产生的，要去执行一段外设的逻辑，回来的话回到下一条，达到对应用程序看来好像什么都没有发生过的效果 </li></ul></li><li>根据 trap 的种类设置 mcause，并根据需要为 mtval 设置附加信息</li><li>将 trap 发生之前的权限模式保存在 mstatus 的 MPP 域中，再把 hart 权限模式更改为 M（也就是说无论在任何 Level 下触发 trap， hart 首先切换到 Machine 模式）。</li></ul><p>所以要使用 s 模式的话这些也是一样的吗？</p><p>bottom-half：软件需要做的事，以下是在汇编中写的</p><ul><li>保存当前控制流的上下文信息</li><li>调用 c 语言的 trap handler</li><li>从 trap handler 返回， mepc 的值有可能需要调整</li><li>恢复上下文</li><li>执行 mret 指令返回到 trap 之前的状态</li></ul><p>mret指令：还有sret/uret    </p><ul><li>当前 hart 的权限级别 = mstatus.MPP；mstatus.MPP = U（如果 hart 不支持 U 则为 M）（恢复hart trap前的权限级别）</li><li>mstatus.MIE = mstatus.MPIE; mstatus.MPIE=1 （恢复hart trap前的中断使能）</li><li>pc = mepc （跳转到 trap 前的执行流）</li></ul><p>很有意思的点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">reg_t</span> <span class="hljs-title function_">trap_handler</span><span class="hljs-params">(<span class="hljs-type">reg_t</span> epc, <span class="hljs-type">reg_t</span> cause)</span><br>&#123;<br><span class="hljs-type">reg_t</span> return_pc = epc;<br><span class="hljs-type">reg_t</span> cause_code = cause &amp; MCAUSE_MASK_ECODE;<br><br><span class="hljs-keyword">if</span> (cause &amp; MCAUSE_MASK_INTERRUPT) &#123;<br><span class="hljs-comment">/* Asynchronous trap - interrupt */</span><br><span class="hljs-keyword">switch</span> (cause_code) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>uart_puts(<span class="hljs-string">&quot;software interruption!\n&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br>uart_puts(<span class="hljs-string">&quot;timer interruption!\n&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">11</span>:<br>uart_puts(<span class="hljs-string">&quot;external interruption!\n&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Unknown async exception! Code = %ld\n&quot;</span>, cause_code);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/* Synchronous trap - exception */</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Sync exceptions! Code = %ld\n&quot;</span>, cause_code);<br><span class="hljs-comment">// panic(&quot;OOPS! What can I do!&quot;);</span><br>return_pc += <span class="hljs-number">4</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> return_pc;<br>&#125;<br></code></pre></td></tr></table></figure><p>试试第25，26行：分别注释掉的效果</p><p>只使用 25 行：panic死循环</p><p>只使用 26 行：改变了 return 到了下一条指令，那么可以返回这里异常的下一条指令</p><h2 id="06-外部设备中断"><a href="#06-外部设备中断" class="headerlink" title="06 外部设备中断"></a>06 外部设备中断</h2><p>中断分类</p><ul><li>本地中断<ul><li>软件中断</li><li>时钟中断</li></ul></li><li>全局中断<ul><li>外部中断：外设产生的中断 </li></ul></li></ul><p>问题：前面提到的 mstatus.mie 和这里的 mie 寄存器什么关系？</p><p>mstatus. mie 控制全局的中断使能状态，而 mie 寄存器中的各个位控制具体的中断源是否被使能</p><p>比如你要打开时钟中断（mie里的MTIE）：要保证 mstatus.mie = 1 <strong>&amp;&amp;</strong> mie.MTIE = 1</p><p><strong>寄存器</strong></p><p><code>mie</code>：打开或者关闭 M/S/U 模式下对应的 External/Timer/Software 中断</p><p><code>mip</code> 获取当前 M/S/U 模式 下对应的 External/Timer/Software 中断是否发</p><p>mie可以理解为是用来写的，mip可以理解为是用来读的</p><h3 id="PLIC介绍"><a href="#PLIC介绍" class="headerlink" title="PLIC介绍"></a>PLIC介绍</h3><p>为什么需要PLIC，因为外部设备很多，不可能对每一个外设都设置一个引脚，来告诉 cpu 这个外设产生中断了，于是需要一个中断代理，这样我们只需要一个引脚，简化了cpu的设计复杂度</p><p>PLIC每次只放一个中断进来</p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405102126837.png" alt="image-20240510212629762"></p><p>中断源介绍：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//https://github.com/qemu/qemu/blob/master/include/hw/riscv/virt.h</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    UART0_IRQ = <span class="hljs-number">10</span>,<br>    RTC_IRQ = <span class="hljs-number">11</span>,<br>    VIRTIO_IRQ = <span class="hljs-number">1</span>, <span class="hljs-comment">/* 1 to 8 */</span><br>    VIRTIO_COUNT = <span class="hljs-number">8</span>,<br>    PCIE_IRQ = <span class="hljs-number">0x20</span>, <span class="hljs-comment">/* 32 to 35 */</span><br>    VIRT_PLATFORM_BUS_IRQ = <span class="hljs-number">64</span>, <span class="hljs-comment">/* 64 to 95 */</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>0 预留不用</li></ul><h4 id="PLIC编程接口-寄存器"><a href="#PLIC编程接口-寄存器" class="headerlink" title="PLIC编程接口-寄存器"></a><strong>PLIC编程接口-寄存器</strong></h4><p><code>priority</code> 设置 某一路中断源的优先级</p><ul><li>内存映射地址：base + id * 4</li><li>每个 PLIC 中断源对应一个寄存器，用于配置该中断源的优先级</li><li>QEMU-virt 支持 7 个优先级。 0 表示对该中断源禁用中断。 其余优先级，1 最低，7 最高</li><li>如果两个中断源优先级相同，则根据中断源的 ID 值进一步 区分优先级，ID 值越小的优先级越高</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PLIC_PRIORITY(id) (PLIC_BASE + (id) * 4)</span><br><br><span class="hljs-comment">//plic_init() 设置 UART0_IRQ 这个中断源的优先级</span><br>*(<span class="hljs-type">uint32_t</span>*)PLIC_PRIORITY(UART0_IRQ) = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p><code>pending </code>：指示某一路中断源是否发生</p><ul><li>每个 PLIC 包含 2 个 32 位的 Pending 寄存器，每一个 bit 对应 一个中断源，如果为 1 表示该中断源上发生了中断（进入 Pending 状态），有待 hart 处理，否则表示该中断源上当前无 中断发生</li><li>claim 会清除掉 pending 寄存器某一位对应的状态</li><li>第一个 Pending 寄存器的第 0 位对应不存在的 0 号中断源，其 值永远为 0</li></ul><p><code>Enable</code>：针对某个 hart 开启或者关闭某一路中断源</p><ul><li>每个 Hart 有 2 个 Enable 寄存器 （Enable1 和 Enable2）用 于针对该 Hart 启动或者关闭某路中断源</li><li>每个中断源对应 Enable 寄存器的一个 bit，其中 Enable1 负责控制 1 ~ 31 号中断源；Enable2 负责控制 32 ~ 53 号中断源。 将对应的 bit 位设置为 1 表示使能该中断源，否则表示关闭该中断源</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PLIC_MENABLE(hart, id) (PLIC_BASE + 0x2000 + (hart) * 0x80 + ((id) / 32) * 4)</span><br>*(<span class="hljs-type">uint32_t</span>*)PLIC_MENABLE(hart, UART0_IRQ)= (<span class="hljs-number">1</span> &lt;&lt; (UART0_IRQ % <span class="hljs-number">32</span>));<br></code></pre></td></tr></table></figure><p><code>Threshold</code> ：针对某个 hart 设置中断源优先级的阈值</p><ul><li>每个 Hart 有 1 个 Threshold 寄存器用于设置中断优先级 的阈值</li><li>所有小于或者等于（&lt;=）该阈值的中断源即使发生了也会 被 PLIC 丢弃。特别地，当阈值为 0 时允许所有中断源上发 生的中断；当阈值为 7 时丢弃所有中断源上发生的中断</li></ul><p><code>Claim/Complete</code>：这两个是同一个寄存器， 每个 hart 一个</p><ul><li>Claim：对该寄存器执行读操作，获取当前 hart 发生的最高优先级的中断源 id，claim成功后会清除对应的 pending 位</li><li>Complete：对该寄存器执行写操作，通知 PLCI 这个中断处理已经结束，可以接受下一个了</li></ul><h4 id="uart-为例"><a href="#uart-为例" class="headerlink" title="uart 为例"></a>uart 为例</h4><p>以 uart 这个中断源为例，我们如果要处理一个中断源，应该怎么编程</p><ol><li><p>在 plic_init 阶段</p><ul><li>中断源：设置该中断源优先级、设置 enable 寄存器使能该终端源</li><li>hart：设置 threshold 阈值，使能 mie，mstatus</li></ul></li><li><p>具体 uart 的中断处理逻辑</p><ul><li>trap处理具体的 cause 时，加入一个外部中断的处理</li><li>在外部中断处理里面加入判断，首先通过 plic_claim 获取 irq，如果 irq 是 uart 的 id 就执行它的中断流程</li><li>然后完成之后记得调用 plic_complete</li></ul></li><li><p>注意在 uart_init 里面需要打开 uart 自身可以接受中断</p></li></ol><p>总结：编程时需要注意有的寄存器是 hart 级别的，有的寄存器是全局的，需要区别</p><h2 id="07定时器中断"><a href="#07定时器中断" class="headerlink" title="07定时器中断"></a><strong>07定时器中断</strong></h2><p>CLINT (Core Local INTerrupt)</p><h3 id="CLINT编程接口"><a href="#CLINT编程接口" class="headerlink" title="CLINT编程接口"></a>CLINT编程接口</h3><p><code>mtime</code> ：real-time 计时器</p><ul><li>系统保证该计数器的值始终按照一个固定的频率递增</li><li>上电复位时，硬件负责将mtime的值恢复为0</li></ul><p><code>mtimecmp</code> </p><ul><li>每个 hart 一个 mtimecmp 寄存器，64-bit</li><li>上电复位时，系统不负责设置 mtimecmp 的初值，所以要你自己来</li></ul><p>这个寄存器的用处就是用来触发时钟中断：</p><ul><li>当 mtime &gt;= mtimecmp 时，CLINT 会产生一个 timer 中断。 如果要使能该中断需要保证全局中断打开并且 mie.MTIE 标志位 置 1</li><li>当 timer 中断发生时，hart 会设置 mip.MTIP，程序可以在 mtimecmp 中写入新的值清除 mip.MTIP</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405102238360.png" alt="image-20240510223837290"></p><p>Tick：</p><ul><li>os 中最小的时间单位</li><li>Tick 的单位(周期)由硬件定时器的周期决定（通常为 1~ 100 ms）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>RISC-V trap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>完全搞懂二分</title>
    <link href="/2024/05/09/%E5%AE%8C%E5%85%A8%E6%90%9E%E6%87%82%E4%BA%8C%E5%88%86/"/>
    <url>/2024/05/09/%E5%AE%8C%E5%85%A8%E6%90%9E%E6%87%82%E4%BA%8C%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p>看完了灵神 20 分钟的二分讲解，把以前看了好多遍都没看懂的二分彻底理解了，开心~ </p><p>主题：红蓝染色法理解二分，力扣152,163</p><span id="more"></span><h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><h2 id="红蓝染色法理解二分"><a href="#红蓝染色法理解二分" class="headerlink" title="红蓝染色法理解二分"></a>红蓝染色法理解二分</h2><p>我们以寻找到 &gt;= x 的第一个下标来举例：</p><p>你的条件可以灵活定义</p><p>用<strong>红色</strong>表示不满足条件的，<strong>蓝色</strong>表示满足条件的，<strong>白色</strong>表示不确定</p><p><strong>核心</strong>：</p><ul><li>你要维护的区间内的都是没有染色的，<strong>区间的定义是未染色的范围，而不是答案的范围！！！</strong></li><li><strong>l 和 r 的初始值怎么定义？</strong>看你初始的不知道如何染色的区间范围（白色）是多少，以及你二分是使用闭区间 or 开区间 or 左闭右开 哪种策略编写的，据此定下来你的 l 和 r值</li><li><strong>循环条件如何终止？</strong>当你的区间不为空的时候循环</li><li>中间判断了之后 l，r 与 m 的关系应该怎么变化：看你想要寻找什么</li><li>最后答案应该怎么return：在找第一个 &gt;= x 的情况下你要return的应该是蓝色（true）的第一个</li></ul><p><strong>mid</strong> 表示正在询问的数 </p><p>闭区间写法下我们如何取得答案？</p><p>有一个循环不变量保持着：</p><ul><li>L-1始终是红色</li><li>R+1始终是蓝色</li><li>那么答案其实就是 蓝色的第一个，也就是L或者R+1</li></ul><h2 id="多种写法"><a href="#多种写法" class="headerlink" title="多种写法"></a>多种写法</h2><p>三种写法：推荐开区间，中间l,r,m之间的判断关系简单</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 找 &gt;= target 的第一个</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lower_bound</span>(<span class="hljs-params">nums,target</span>):<br>    l = -<span class="hljs-number">1</span><br>    r = <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-comment">#开区间写法</span><br>    <span class="hljs-keyword">while</span> l+<span class="hljs-number">1</span> &lt; r: <span class="hljs-comment">#区间不为空</span><br>        m = (l+r) // <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[m] &lt; target: <span class="hljs-comment">#false</span><br>            l =  m   <span class="hljs-comment">#(m,r)</span><br>        <span class="hljs-keyword">else</span>:<br>            r = m <span class="hljs-comment">#(l,m)</span><br>    <span class="hljs-keyword">return</span> r<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lower_bound2</span>(<span class="hljs-params">nums,target</span>):<br>    <span class="hljs-comment">#闭区间写法</span><br>    l = <span class="hljs-number">0</span><br>    r = <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> l&lt;=r: <span class="hljs-comment">#区间不为空</span><br>        m = (l+r) // <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[m] &lt; target: <span class="hljs-comment">#false</span><br>            l =  m+<span class="hljs-number">1</span>   <br>        <span class="hljs-keyword">else</span>:<br>            r = m-<span class="hljs-number">1</span> <br>    <span class="hljs-keyword">return</span> l<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lower_bound3</span>(<span class="hljs-params">nums,target</span>):<br>    l = <span class="hljs-number">0</span><br>    r = <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-comment">#左闭右开区间写法 </span><br>    <span class="hljs-keyword">while</span> l &lt; r: <span class="hljs-comment">#区间不为空</span><br>        m = (l+r) // <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[m] &lt; target: <span class="hljs-comment">#false</span><br>            l =  m+<span class="hljs-number">1</span>   <br>        <span class="hljs-keyword">else</span>:<br>            r = m <br>    <span class="hljs-keyword">return</span> r<br></code></pre></td></tr></table></figure><p>那么一共演变了四种题型：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm">&gt;<span class="hljs-operator">=</span> <span class="hljs-keyword">x</span> 这种是我们熟知的<br>&gt; <span class="hljs-keyword">x</span> 这种可以转化为 &gt;<span class="hljs-operator">=</span> <span class="hljs-keyword">x</span><span class="hljs-number">+1</span><br>&lt; <span class="hljs-keyword">x</span> 这种可以转为 &gt;<span class="hljs-operator">=</span><span class="hljs-keyword">x</span> 的下标 <span class="hljs-number">-1</span><br>&lt;<span class="hljs-operator">=</span> <span class="hljs-keyword">x</span>这种可以转为 &gt;<span class="hljs-keyword">x</span> 的下标 <span class="hljs-number">-1</span> 即 &gt;<span class="hljs-operator">=</span> <span class="hljs-keyword">x</span><span class="hljs-number">+1</span><br></code></pre></td></tr></table></figure><p>如果说target比所有的数都大的话：会返回数组最大下标的next</p><p>target比所有的数都小的话：会返回 0</p><p>target在最大最小范围内，但是没有target，会返回 &gt;= target 的第一个</p><p>python 写二分最好还是直接调用库，这样比较快，大概快一半</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bisect <span class="hljs-keyword">import</span> *<br>bisect_left(nums,target) <span class="hljs-comment">#返回 &gt;= target的第一个，行为与我自己写的完全一致</span><br></code></pre></td></tr></table></figure><h2 id="162"><a href="#162" class="headerlink" title="162"></a>162</h2><p><a href="https://leetcode.cn/problems/find-peak-element/">https://leetcode.cn/problems/find-peak-element/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#红色代表峰顶左边</span><br><span class="hljs-comment">#蓝色代表峰顶以及峰顶右边</span><br><span class="hljs-comment">#区间表示不知道染什么色的东西</span><br><span class="hljs-comment">#只需要比较mid和mid+1就行，找到第一个下坡？</span><br><span class="hljs-comment">#如果你往下坡方向走，也许可能遇到新的山峰，但是也许是一个一直下降的坡，最后到边界。</span><br><span class="hljs-comment">#但是如果你往上坡方向走，就算最后一直上的边界，由于最边界是负无穷，所以就一定能找到山峰</span><br><span class="hljs-comment">#总的一句话，往递增的方向上，二分，一定能找到，往递减的方向只是可能找到，也许没有</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lower_bound</span>(<span class="hljs-params">nums</span>):<br>    l = -<span class="hljs-number">1</span> <span class="hljs-comment">#[0,n-2]</span><br>    r = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> l+<span class="hljs-number">1</span>&lt;r:<br>        mid = (l+r) // <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[mid] &lt; nums[mid+<span class="hljs-number">1</span>]:<br>            l = mid <span class="hljs-comment">#染红色</span><br>        <span class="hljs-keyword">else</span>:<br>            r = mid <span class="hljs-comment">#染蓝色</span><br>    <span class="hljs-keyword">return</span> r<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findPeakElement</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> lower_bound(nums)<br></code></pre></td></tr></table></figure><h2 id="153"><a href="#153" class="headerlink" title="153"></a>153</h2><p>原题链接： <a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值 - 力扣（LeetCode）</a></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这题一共就两种情况，因为是对一个有序数组的旋转，看下面画的图</p><p>第一种情况很好解决，简单的二分，第二种情况需要分析一下</p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405091830658.png" alt="image-20240509180447566"></p><p>我们要找的相当于是谷底，也就是左右都比他大的</p><p><strong>红蓝染色法二分：</strong></p><ul><li>红色表示最小数的左边</li><li>蓝色表示最小数或者最小数的右边</li></ul><p>我们可以首先确定最后一个数一定是蓝色，所以开始的区间可以设为 [0,n-2]，这个区间是我们不知道要怎么染色的，接下来开始二分缩小这个区间</p><p>使用开区间来写的话，最初 l = -1，r = n-1</p><p><strong>那么我们怎么确定要染什么颜色？</strong></p><ul><li>通过已知条件来看，我们仿照上一题，让mid和mid+1来比较可以吗？显然是不行的，因为除了最小值旁边的元素其他位置都满足 num[mid] &lt; num[mid+1] ，无法根据这个来染色</li><li>可以根据 num[mid] 和 num[-1] (最后一个元素) 来比较<ul><li>如果 num[mid] &lt; num[-1]：由图可知，需要让 r = mid</li><li>如果 num[mid] &gt; num[-1]：由图可知：需要让 l = mid</li></ul></li></ul><p>最后返回值应该是什么呢，下标返回 r 即可</p><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这题不就是寻找谷值吗</span><br><span class="hljs-comment"># 红色表示谷左边</span><br><span class="hljs-comment"># 蓝色表示谷以及谷的右边</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">binsearch</span>(<span class="hljs-params">nums</span>):<br>    l = -<span class="hljs-number">1</span> <span class="hljs-comment"># [0,n-2]</span><br>    r = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> l+<span class="hljs-number">1</span> &lt; r:<br>        mid = (l+r) // <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[mid] &lt; nums[-<span class="hljs-number">1</span>]:<br>            r = mid <br>        <span class="hljs-keyword">else</span>:<br>            l = mid<br>    <span class="hljs-keyword">return</span> nums[r]<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findMin</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> binsearch(nums)<br></code></pre></td></tr></table></figure><p>思考：</p><p>边界条件，最小的在最右怎么办?</p><ul><li>这种情况由于一开始其实我们就给最右染色了，那么 r 一直是不会移动的，合理</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6-trap</title>
    <link href="/2024/04/28/xv6-trap/"/>
    <url>/2024/04/28/xv6-trap/</url>
    
    <content type="html"><![CDATA[<p>详细看看 xv6 trap：相关寄存器，trap流程，用户trap，内核trap</p><span id="more"></span><p>相关资料存档：</p><p><a href="https://xv6.dgs.zone/tranlate_books/book-riscv-rev1/c4/s1.html">4.1 RISC-V陷入机制 · 6.S081 All-In-One (dgs.zone)</a></p><p><a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec06-isolation-and-system-call-entry-exit-robert/6.1-trap">6.1 Trap机制 | MIT6.S081 (gitbook.io)</a></p><p>riscv 特权级手册</p><p>限制vmem：<a href="https://blog.csdn.net/Power_Blogger/article/details/128158694?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-128158694-blog-117143614.235%5Ev43%5Epc_blog_bottom_relevance_base7&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-128158694-blog-117143614.235%5Ev43%5Epc_blog_bottom_relevance_base7&utm_relevant_index=1">Vmmem进程(WSL)占用CPU或内存资源过高的解决办法-CSDN博客</a></p><h2 id="trap"><a href="#trap" class="headerlink" title="trap"></a>trap</h2><p>什么是 trap？</p><ul><li>用户空间和内核空间的切换通常被称为trap</li></ul><p>special！！：第一次trap的时候在哪里设置的uservec！是在forkret</p><p>forkret 调用了 usertrapret() 返回到了用户空间，在这里为第一次 trap 所需的东西，那么我认为冗余的部分，是不是就是因为这个地方没有设置呢</p><p><strong>首先介绍一下 S mode 和 U mode 的小区别：</strong></p><p>supervisor mode可以控制什么/特权是什么？</p><ul><li><p>读写控制寄存器：satp,stvec,sepc,sscratch</p></li><li><p>可以使用 PTE_U 标志位为 0 的 PTE。当 PTE_U 标志位为 1 的时候，表明用户代码可以使用这个页表；</p><p>如果这个标志位为 0，则只有 supervisor mode 可以使用这个页表</p><blockquote><p>比如用户空间最后两条pte，PTE_U 标志为 0，用户代码不能访问，S mode才可以访问</p><p>a 标志代表这条PTE是不是被代码访问过，是不是曾经有一个被访问过的地址包含在这个PTE的范围内</p><p>d标志位告诉内核，这个page最近被修改过</p></blockquote></li></ul><p>需要特别指出的是，supervisor mode 中的代码并不能读写任意物理地址。在 supervisor mode 中，就像普通的用户代码一样，也需要通过 page table 来访问内存。如果一个虚拟地址并不在当前由 SATP 指向的 page table 中，又或者 SATP 指向的 page table 中 PTE_U=1，那么 supervisor mode 不能使用那个地址。所以，即使我们在 supervisor mode，我们还是受限于当前 page table 设置的虚拟地址。</p><p>一个特殊的寄存器：mode标志位。这里的mode表明当前是user mode还是supervisor mode</p><h3 id="什么时候会产生-trap"><a href="#什么时候会产生-trap" class="headerlink" title="什么时候会产生 trap"></a><strong>什么时候会产生 trap</strong></h3><p>有三种事件会导致中央处理器搁置普通指令的执行，并强制将控制权转移到处理该事件的特殊代码上</p><p>包括</p><ul><li><p>exception：异常</p><ul><li>error:（用户或内核）指令做了一些非法的事情，例如除以零或使用无效的虚拟地址</li></ul></li><li><p>syscall: ecall （注意ecall并不会切换page table，所以这意味着，trap处理代码必须存在于每一个user page table中）</p><p>ecall之后就转到stevc寄存器指向的地址开始继续执行指令（trampoline page）</p></li><li><p>interrupt：设备中断，一个设备，例如当磁盘硬件完成读或写请求时，向系统表明它需要被关注。</p></li></ul><p>我们希望trap是<strong>透明的</strong>，也就是用户感觉不到发生 trap 了</p><p>通常的顺序是</p><ol><li>陷阱强制将控制权转移到内核</li><li>内核保存寄存器和其他状态，以便可以恢复执行</li><li>内核执行适当的处理程序代码（例如，系统调用接口或设备驱动程序）</li><li>内核恢复保存的状态并从陷阱中返回</li><li>原始代码从它停止的地方恢复。</li></ol><p>注意cpu不会保存除 <code>pc</code> 之外的任何寄存器，切换内核页表，切换内核栈，保存寄存器这些工作都需要内核软件自己来实现</p><h3 id="ecall时发生了什么"><a href="#ecall时发生了什么" class="headerlink" title="ecall时发生了什么"></a>ecall时发生了什么</h3><blockquote><p>注意 ecall 是从用户空间陷入的意思</p><p>ecall 并不会切换 page table 切记，由于 ecall 是 CPU 的指令，你在gdb中是看不到 ecall 指令具体干了啥</p></blockquote><p>第一，ecall将代码从user mode改到supervisor mode。</p><p>第二，ecall将程序计数器的值保存在了SEPC寄存器。</p><p>第三，ecall会跳转到STVEC寄存器指向的指令。</p><p>为什么 ecall 不多做点工作来将代码执行从用户空间切换到内核空间呢？</p><ul><li><a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec06-isolation-and-system-call-entry-exit-robert/6.4-ecall-zhi-ling-zhi-hou-de-zhuang-tai">6.4 ECALL指令之后的状态 | MIT6.S081 (gitbook.io)</a></li></ul><p>sscrath(S-mode sratch：S态下可以临时使用的寄存器) 这个寄存器用户是看不到的，在刚刚进入trap的时候操作系统把<strong>trapframe的地址</strong>放在了里面</p><p>satp (S-mode address translation and protection)</p><p>Trampoline(跳板)：</p><ul><li>对ecall瞬间的状态做快照<ul><li>填充 trapframe</li><li>利用 sscratch 保存所有寄存器</li></ul></li></ul><h3 id="trap-相关寄存器"><a href="#trap-相关寄存器" class="headerlink" title="trap 相关寄存器"></a>trap 相关寄存器</h3><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MK04CleJKuURh9XXWGG%2F-MK0Jg73bN-fwYa4_qZ_%2Fimage.png?alt=media&token=0c0df379-44cc-4f81-926e-8855fdcbe9c3" alt="img" style="zoom:33%;" /><p><code>stvec</code></p><ul><li>CSR</li><li>保存”Handler”代码的地址</li></ul><p><code>sstatus</code></p><ul><li>sie (interrupt enabled)<ul><li>0 -&gt; disabled</li><li>1 -&gt; enabled</li></ul></li><li>spie (previous interrupts enabled)</li><li>spp (previous priviledge )<ul><li>0 -&gt; user</li><li>1 -&gt; kernel</li></ul></li></ul><p><code>sepc</code>（Supervisor Exception Program Counter）：</p><ul><li>当发生陷阱时，RISC-V会在这里保存程序计数器<code>pc</code>（因为<code>pc</code>会被<code>stvec</code>覆盖）。<code>sret</code>（从陷阱返回）指令会将<code>sepc</code>复制到<code>pc</code>。内核可以写入<code>sepc</code>来控制<code>sret</code>的去向。</li></ul><p><code>scause</code>： RISC-V在这里放置一个描述陷阱原因的数字。</p><p><code>sscratch</code>：内核在这里放置了一个值，这个值在陷阱处理程序一开始就会派上用场。</p><p><code>mstatus</code></p><ul><li>大致和<code>sstatus</code>一样，但是<code>mpp</code>有三个状态：user,supervisor,machine</li></ul><h3 id="trap大致流程"><a href="#trap大致流程" class="headerlink" title="trap大致流程"></a>trap大致流程</h3><p>当需要强制执行陷阱时，<strong>RISC-V硬件</strong>对所有陷阱类型（计时器中断除外）执行以下操作：</p><blockquote><p>特别注意这里是硬件完成的，不需要我们手动来，我们也看不到具体的过程</p></blockquote><ol><li><p>如果陷阱是设备中断，并且 <code>sstatus.SIE</code> 位被清空，则不执行以下任何操作。</p></li><li><p>把<code> sstatus.SPIE = ssatus.SIE</code> (保存之前的SIE)，清除 <code>sstatus.SIE</code> 以禁用中断，</p></li><li><p>将<code>pc</code>复制到<code>sepc</code>，将<code>stvec</code>复制到<code>pc</code> </p><blockquote><p>看到这你是否有疑问，为什么pc改变了，执行流不应该也改变了吗，为什么接下来几条设置还能继续进行？</p><p>我的理解是这是硬件完成的，可能类似于原子指令吧，要执行完这些剩下的才会跳到另一个执行流来执行 pc</p></blockquote></li><li><p>设置<code>scause</code>以反映产生陷阱的原因 (1 = TIMER; 8 = syscall…) ，设置<code>stval</code>显示附加信息比如 bad Instruction之类的</p></li><li><p>将当前hart权限mode保存在 <code>sstatus.SPP</code>中 ，将 mode 设置为 S mode (0 =U ; 1 = S) </p></li><li><p>在新的<code>pc</code>上开始执行。</p></li></ol><h4 id="trampoline"><a href="#trampoline" class="headerlink" title="trampoline"></a>trampoline</h4><blockquote><p>trampoline page在user page table中的映射与kernel page table中的映射是完全一样的。这两个page table中其他所有的映射都是不同的，只有trampoline page的映射是一样的，因此我们在切换page table时，寻址的结果不会改变，我们实际上就可以继续在同一个代码序列中执行程序而不崩溃。这是trampoline page的特殊之处，它同时在user page table和kernel page table都有相同的映射关系。</p></blockquote><p>即使trampoline page是在用户地址空间的user page table完成的映射，用户代码不能写它，因为这些page对应的PTE并没有设置PTE_u标志位。这也是为什么trap机制是安全的。</p><p>之所以叫trampoline page，是因为你某种程度在它上面“弹跳”了一下，然后从用户空间走到了内核空间。</p><h4 id="TRAPFRAME"><a href="#TRAPFRAME" class="headerlink" title="TRAPFRAME"></a>TRAPFRAME</h4><p>trapframe page里面存放了什么</p><p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MLQ4bdT5ylb0H6aFAhT%2F-MLVsAYDqR92__T08g2L%2Fimage.png?alt=media&token=286cd987-8607-482d-a7e4-b37de5eb47ac" alt="img"></p><p>很多槽位空出来是为了保存32个寄存器</p><p>在最开始还有5个数据，这些是内核事先存放在 trapframe 中的数据。</p><p>所以如何保存用户寄存器？</p><ul><li><p>内核非常方便的将trapframe page映射到了每个user page table，这个空间可以用于保存用户寄存器</p></li><li><p>进入到user space之前，内核会将trapframe page的地址保存在这个寄存器<code>sscratch</code>中，也就是0x3fffffe000这个地址</p><p>我们使用<code>csrrw</code>指令来交换<code>a0</code>和<code>sscratch</code>的值</p></li></ul><blockquote><p>sfence.vma是清空页表缓存</p></blockquote><h3 id="【重要】从用户空间陷入"><a href="#【重要】从用户空间陷入" class="headerlink" title="【重要】从用户空间陷入"></a>【重要】从用户空间陷入</h3><blockquote><p>什么时候会从用户空间陷入？</p><p>用户 ecall or 做了一些非法事件 or 设备中断</p></blockquote><p>由于 RISC-V <strong>硬件</strong>在陷阱期间不会切换页表，所以用户页表必须包括 <code>uservec</code>（<strong>stvec</strong>指向的陷阱向量指令）的映射。<code>uservec</code>必须切换<code>satp</code>以指向内核页表；为了在切换后继续执行指令，<code>uservec</code>必须在内核页表中与用户页表中映射相同的地址。</p><p>因此才使用包含 <code>uservec</code> 的蹦床页面（trampoline page）来满足这些约束</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//proc.c</span><br><span class="hljs-comment">//为用户页表的trampoline和trapframe建立映射</span><br><span class="hljs-type">pagetable_t</span> <span class="hljs-title function_">proc_pagetable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> proc*p)</span>&#123;<br>    ...<br>  <span class="hljs-comment">// map the trampoline code (for system call return)</span><br>  <span class="hljs-comment">// at the highest user virtual address.</span><br>  <span class="hljs-comment">// only the supervisor uses it, on the way</span><br>  <span class="hljs-comment">// to/from user space, so not PTE_U.</span><br>   <span class="hljs-keyword">if</span>(mappages(pagetable, TRAMPOLINE, PGSIZE,<br>              (uint64)trampoline, PTE_R | PTE_X) &lt; <span class="hljs-number">0</span>)&#123;<br>    uvmfree(pagetable, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// map the trapframe page just below the trampoline page, for</span><br>  <span class="hljs-comment">// trampoline.S.</span><br>  <span class="hljs-keyword">if</span>(mappages(pagetable, TRAPFRAME, PGSIZE,<br>              (uint64)(p-&gt;trapframe), PTE_R | PTE_W) &lt; <span class="hljs-number">0</span>)&#123;<br>    uvmunmap(pagetable, TRAMPOLINE, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    uvmfree(pagetable, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202404212201089.png" alt="image-20240421220132965"></p><p>stvec 初始时指向 uservec</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">trap.c<br><span class="hljs-type">void</span> <span class="hljs-title function_">usertrapret</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    ...<br>  <span class="hljs-comment">// send syscalls, interrupts, and exceptions to uservec in trampoline.S</span><br>  uint64 trampoline_uservec = TRAMPOLINE + (uservec - trampoline);<br>  w_stvec(trampoline_uservec);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>trapframe 预先包含的内容：</p><ul><li><p>指向当前进程内核栈的指针、当前CPU的<code>hartid</code>、<code>usertrap</code>的地址和内核页表的地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">usertrapret()&#123;<br>    ...<br>  <span class="hljs-comment">// set up trapframe values that uservec will need when</span><br>  <span class="hljs-comment">// the process next traps into the kernel.</span><br>  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="hljs-comment">// kernel page table</span><br>  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="hljs-comment">// process&#x27;s kernel stack</span><br>  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;<br>  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="hljs-comment">// hartid for cpuid()</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>uservec</strong> 做的工作：</p><ul><li><p>利用 sscratch 做媒介，把 a0 原本的值存在 sscratch，sscratch里面是 TRAPFRAME 的地址（注意这里是否破坏了 sscratch 的值，破坏了无所谓，TRAPFRAME这个值是从外面的宏定义的）</p><blockquote><p>注意在 xv6-lab 和 xv6-riscv 这二者的实现上有区别，前者没有破坏 sscratch 的值</p></blockquote></li><li><p>保存寄存器：（在用户地址空间的TRAPFRAME处）</p><p>利用 a0 在 trapframe 保存所有的寄存器， a0 最后保存，此时所有的寄存器都保存完了，想用哪个用哪个，将 a0 从 sscratch 恢复然后保存到 trapframe</p></li><li><p>把上面提到的几个已知信息从内存加载到寄存器（LOAD）：设置当前进程内核栈、hart_id、usertrap地址、内核satp</p></li><li><p>切换到内核页表：根据 trapframe 原本保存的 kernel_satp，写入 satp </p></li><li><p>跳转到 usertrap()，不会返回</p></li></ul><p><strong>usertrap()：</strong>确定陷阱的原因，处理并返回</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// handle an interrupt, exception, or system call from user space.</span><br><span class="hljs-comment">// called from trampoline.S</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">usertrap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> which_dev = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;usertrap: not from user mode&quot;</span>);<br><br>  <span class="hljs-comment">// send interrupts and exceptions to kerneltrap(),</span><br>  <span class="hljs-comment">// since we&#x27;re now in the kernel.</span><br>  w_stvec((uint64)kernelvec);<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  <br>  <span class="hljs-comment">// save user program counter.</span><br>  p-&gt;trapframe-&gt;epc = r_sepc();<br>  <br>  <span class="hljs-keyword">if</span>(r_scause() == <span class="hljs-number">8</span>)&#123;<br>    <span class="hljs-comment">// system call</span><br><br>    <span class="hljs-keyword">if</span>(killed(p))<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br><br>    <span class="hljs-comment">// sepc points to the ecall instruction,</span><br>    <span class="hljs-comment">// but we want to return to the next instruction.</span><br>    p-&gt;trapframe-&gt;epc += <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">// an interrupt will change sepc, scause, and sstatus,</span><br>    <span class="hljs-comment">// so enable only now that we&#x27;re done with those registers.</span><br>    intr_on();<br><br>    syscall();<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((which_dev = devintr()) != <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// ok</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());<br>    setkilled(p);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(killed(p))<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br><br>  <span class="hljs-comment">// give up the CPU if this is a timer interrupt.</span><br>  <span class="hljs-keyword">if</span>(which_dev == <span class="hljs-number">2</span>)<br>    yield();<br><br>  usertrapret();<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><p>首先 assert 这是一个来自用户态的中断：看sstatus.SPP是否为0</p></li><li><p>stvec = kernelvec </p></li><li><p>保存sepc：<code>p-&gt;trapframe-&gt;epc = r_sepc()</code> </p><ul><li><p>为什么在这里我们又再次保存了sepc呢？</p><p>因为可能发生这种情况：当程序还在内核中执行时，我们可能切换到另一个进程，并进入到那个程序的用户空间，然后那个进程可能再调用一个系统调用进而导致SEPC寄存器的内容被覆盖。</p><blockquote><p>问题：此时中断被关闭的，什么东西会导致切换到另一个进程？</p></blockquote></li></ul></li><li><p>根据 <code>scause</code> 的值判断是什么引起的trap，跳转到自己的 trap 处理流程</p><p>主要依据 riscv 特权手册这张表来看 scause的值</p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405131556730.png" alt="image-20240513155645698"></p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405131555082.png" alt="image-20240513155533977"></p><ul><li>回想<a href="https://ywinh.github.io/2024/05/10/RVOS%E7%9A%84trap/">RVOS的trap - yinsist (ywinh.github.io)</a>，在这篇博客提到关于异常和中断对于 mepc 的设置是不同的，这里的 sepc 也是一样的设计</li><li>syscall ：<ul><li>第一件事情是检查是不是有其他的进程杀掉了当前进程</li><li>p-&gt;trapframe-&gt;epc += 4 返回到发生trap的下一条指令</li><li>打开中断【回想一下中断是在哪里关闭的，在ecall的时候硬件自动完成的】，为什么要打开中断？有的syscall需要中断，比如说write这种；中断可以更快的服务，有些系统调用需要许多时间处理</li><li>执行 syscall</li></ul></li><li>设备中断：<ul><li>devintr() 来处理</li><li>特殊：如果是时钟中断，处理了之后要 yield()</li></ul></li><li>其他：发生错误，打印寄存器信息，然后kill这个进程，exit</li></ul></li><li><p>scause 处理完之后再次检查当前用户进程是否被杀掉了，因为我们不想恢复一个被杀掉的进程</p></li><li><p>调用 usertrapret()</p></li></ul><p><strong>usertrapret():</strong> 未雨绸缪，为下一次 user trap 做准备</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">usertrapret</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-comment">// we&#x27;re about to switch the destination of traps from</span><br>  <span class="hljs-comment">// kerneltrap() to usertrap(), so turn off interrupts until</span><br>  <span class="hljs-comment">// we&#x27;re back in user space, where usertrap() is correct.</span><br>  intr_off();<br><br>  <span class="hljs-comment">// send syscalls, interrupts, and exceptions to uservec in trampoline.S</span><br>  uint64 trampoline_uservec = TRAMPOLINE + (uservec - trampoline);<br>  w_stvec(trampoline_uservec);<br><br>  <span class="hljs-comment">// set up trapframe values that uservec will need when</span><br>  <span class="hljs-comment">// the process next traps into the kernel.</span><br>  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="hljs-comment">// kernel page table</span><br>  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="hljs-comment">// process&#x27;s kernel stack</span><br>  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;<br>  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="hljs-comment">// hartid for cpuid()</span><br><br>  <span class="hljs-comment">// set up the registers that trampoline.S&#x27;s sret will use</span><br>  <span class="hljs-comment">// to get to user space.</span><br>  <br>  <span class="hljs-comment">// set S Previous Privilege mode to User.</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x = r_sstatus();<br>  x &amp;= ~SSTATUS_SPP; <span class="hljs-comment">// clear SPP to 0 for user mode</span><br>  x |= SSTATUS_SPIE; <span class="hljs-comment">// enable interrupts in user mode</span><br>  w_sstatus(x);<br><br>  <span class="hljs-comment">// set S Exception Program Counter to the saved user pc.</span><br>  w_sepc(p-&gt;trapframe-&gt;epc);<br><br>  <span class="hljs-comment">// tell trampoline.S the user page table to switch to.</span><br>  uint64 satp = MAKE_SATP(p-&gt;pagetable);<br><br>  <span class="hljs-comment">// jump to userret in trampoline.S at the top of memory, which </span><br>  <span class="hljs-comment">// switches to the user page table, restores user registers,</span><br>  <span class="hljs-comment">// and switches to user mode with sret.</span><br>  uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline);<br>  ((<span class="hljs-type">void</span> (*)(uint64))trampoline_userret)(satp);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>关闭中断：现在要从 kernel 返回 user，不希望被打断 (最后userret时 sret 会自动打开中断)<ul><li>原因：我们将要更新STVEC寄存器来指向用户空间的trap处理代码，而之前在内核中的时候，我们指向的是内核空间的trap处理代码（6.6）。我们关闭中断因为当我们将STVEC更新到指向用户空间的trap处理代码时，我们仍然在内核中执行代码。如果这时发生了一个中断，那么程序执行会走向用户空间的trap处理代码，即便我们现在仍然在内核中，出于各种各样具体细节的原因，这会导致内核出错。所以我们这里关闭中断。</li></ul></li><li>把 stvec  = uservec，方便下次trap，这个是从用户空间陷入的起点</li><li>写入一些 uservec 需要的 trapframe 信息（比如内核页表，内核栈，hartid）,也是为了方便下次</li><li>sstatus.SPP = 0 （转回user mode）,  sstatusSPIE = 1 （user mode可以中断）</li><li>sepc = p-&gt;trapfreame-&gt;epc（这个epc是在usertrap里面设置好的），sret 要通过 sepc 返回，提前设置好</li><li>调用 userret ()，这里传入了 satp（用户页表）</li></ul><p>问题：为什么这里需要自己来设置 sstatus 相关值，sret 不是会在硬件自动设置吗</p><p><strong>userret</strong>：从kernel返回到user</p><ul><li><p>将用户页表写入 satp</p><blockquote><p>蹦床页面映射在用户和内核页表中的同一个虚拟地址上的事实允许用户在更改<code>satp</code>后继续执行</p></blockquote></li><li><p>从 TRAPFRAME 地址恢复所有寄存器的值</p></li><li><p>sret 返回用户态（这里要利用spec ）</p></li></ul><p>sret是我们在kernel中的最后一条指令，当我执行完这条指令：</p><ul><li>程序会切换回user mode</li><li>SEPC寄存器的数值会被拷贝到PC寄存器（程序计数器）</li><li>重新打开中断</li></ul><p>When executing an x RET instruction, supposing xPP holds the value y, x IE is set to xPIE; the privilege mode is changed to y; xPIE is set to 1; and xPP is set to U (or M if user-mode is not supported).</p><h3 id="从内核空间陷入"><a href="#从内核空间陷入" class="headerlink" title="从内核空间陷入"></a>从内核空间陷入</h3><p>stvec 事先指向的是 kernelvec</p><p>kernelvec：</p><ul><li>保存寄存器（在被中断的内核线程的栈上）</li><li>跳转到kerneltrap()，会返回</li></ul><p>kerneltrap()：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// interrupts and exceptions from kernel code go here via kernelvec,</span><br><span class="hljs-comment">// on whatever the current kernel stack is.</span><br><span class="hljs-type">void</span> <br><span class="hljs-title function_">kerneltrap</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> which_dev = <span class="hljs-number">0</span>;<br>  uint64 sepc = r_sepc();<br>  uint64 sstatus = r_sstatus();<br>  uint64 scause = r_scause();<br>  <br>  <span class="hljs-keyword">if</span>((sstatus &amp; SSTATUS_SPP) == <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;kerneltrap: not from supervisor mode&quot;</span>);<br>  <span class="hljs-keyword">if</span>(intr_get() != <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;kerneltrap: interrupts enabled&quot;</span>);<br><br>  <span class="hljs-keyword">if</span>((which_dev = devintr()) == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;scause %p\n&quot;</span>, scause);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());<br>    panic(<span class="hljs-string">&quot;kerneltrap&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// give up the CPU if this is a timer interrupt.</span><br>  <span class="hljs-keyword">if</span>(which_dev == <span class="hljs-number">2</span> &amp;&amp; myproc() != <span class="hljs-number">0</span> &amp;&amp; myproc()-&gt;state == RUNNING)<br>    yield();<br><br>  <span class="hljs-comment">// the yield() may have caused some traps to occur,</span><br>  <span class="hljs-comment">// so restore trap registers for use by kernelvec.S&#x27;s sepc instruction.</span><br>  w_sepc(sepc);<br>  w_sstatus(sstatus);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>检查是什么类型的trap<ul><li>设备中断</li><li>异常</li></ul></li><li>返回到被 trap 中断的代码</li></ul><p>思考问题：为什么要保存 sepc，sstatus？如果是在时钟中断中发生了 yield，是怎么做的？</p>]]></content>
    
    
    
    <tags>
      
      <tag>trap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6-in-openSBI</title>
    <link href="/2024/04/15/xv6-in-openSBI/"/>
    <url>/2024/04/15/xv6-in-openSBI/</url>
    
    <content type="html"><![CDATA[<p>最近完成操作系统大赛，需要为 xv6 实现一个 SBI 来完成指定的引导</p><p>TODO：理一下 xv6 原本的引导过程</p><span id="more"></span><h1 id="引导过程"><a href="#引导过程" class="headerlink" title="引导过程"></a>引导过程</h1><h2 id="OpenSBI"><a href="#OpenSBI" class="headerlink" title="OpenSBI"></a>OpenSBI</h2><p>OpenSBI的主要功能就是在M态初始化硬件，然后以S态跳转到内核的位置，完成整个启动过程。此外，OpenSBI作为S态内核的执行环境（EEI），可以以 <code>ecall</code> 的方式为S态内核提供一些只有M态才能实现的功能</p><p>每个cpu启动时，都在M态。在将控制权交给操作系统时，转换为 S 态</p><p>qemu 自带一个 opensbi</p><blockquote><p>指定 -bios default 这个选项</p></blockquote><p>由于 opensbi 占据了 0x80000000 到 0x80200000 这段区域，因此我们需要把 xv6 原本这段区域（Kernel）迁移到 0x80200000</p><p>加入opensbi后的内存布局</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c">PHYSICAL_MEMORY_TOP-&gt; +----------------------------+----<br>                      |                            |     <br>                      |    Free Physical memory    |    <br>                      |                            |                         <br>   kernelEnd   -----&gt; +----------------------------+----<br>                      |                            |                         <br>                      |          Kernel            |    <br>                      |                            |                           <br> <span class="hljs-number">0x8020</span> <span class="hljs-number">0000</span>   -----&gt; +----------------------------+----<br>                      |                            |                           <br>                      |         Open SBI           |    <br>                      |                            |                 <br> <span class="hljs-number">0x8000</span> <span class="hljs-number">0000</span>  -----&gt;  +----------------------------+----<br>                      |                            |                           <br>                      |                            |                           <br>                      |                            |                           <br>                      +----------------------------+---<br>                      |                            |                           <br>                      |           MMIO             |                <br>                      |                            |                           <br>                      +----------------------------+----<br>                      |                            |                           <br>                      |                            |                           <br>                      |                            |                           <br>                      +----------------------------+                           <br></code></pre></td></tr></table></figure><p>为了加入 SBI，需要更改的地方</p><ol><li><code>kernel.ld</code>  里面的内核起始地址</li><li><code>entry.s</code> 里面，<ul><li>由于 sbi 把 hart id 放在了 a0 寄存器，xv6 是从 tp 寄存器读出 hart id 的，因此这里需要一个 mv 指令</li><li>然后在这里要设置好对应核的 stack，每个核开了 4096 byte，需要设置好 sp 寄存器</li></ul></li><li>然后更改 xv6 的时钟中断实现<ul><li>因为 xv6 的时钟中断是在 m 态实现的，要实现 sbi 我们一直都会在 S 态，所以利用sbi提供的接口在 s 态实现了时钟中断</li><li>更改 <code>trap.c</code> 中 <code>scause</code> 为时钟中断时的动作</li></ul></li></ol><h2 id="多核启动流程"><a href="#多核启动流程" class="headerlink" title="多核启动流程"></a>多核启动流程</h2><p>由于 qemu 启动时的启动核不一定是 0，可能是随机的，目前采用的方式是</p><blockquote><p>注意这种启动方式可能启动核不是 0，而是其他，后期可能需要更改</p></blockquote><ul><li><p>设置了一个共享变量 <code>volatile static int boot_hart = -1;</code></p></li><li><p>启动核进入 if 判断，初始化自己，然后更改这个共享变量，利用 sbi 来唤醒其他核</p><p>初始化流程：</p><ul><li><p>更改 boot hart</p></li><li><p>初始化 printf (采用uart)</p></li><li><p>打印启动信息</p></li><li><p>初始化物理内存分配</p></li><li><p>初始化 kernel page table</p></li><li><p>开启分页</p></li><li><p>初始化进程</p></li><li><p>初始化根文件系统 (在proc.c里面)</p></li><li><p>初始化 trap 并设置好 kernelvec</p></li><li><p>初始化中断代理 PLIC</p></li><li><p>初始化 buffer cache</p></li><li><p>初始化 File table</p></li><li><p>初始化 virtio 驱动</p></li><li><p>开启 init 进程</p></li><li><p>使用 <code>SBI_HART_START</code> 启动其他核</p><p>初始化根文件系统</p><p><strong>开启 <code>init</code> 进程</strong></p></li></ul></li><li><p>其他核进入else，初始化自己，调用那些 <code>*inithart</code>的 函数</p><p>初始化流程</p><ul><li>开启分页</li><li>设置 kernelvec</li><li>PLIC 中断代理开启</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">volatile</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> boot_hart = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> _entry();<br><span class="hljs-type">void</span> <span class="hljs-title function_">start_harts</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// start() jumps here in supervisor mode on all CPUs.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-keyword">if</span>(boot_hart == <span class="hljs-number">-1</span>)&#123;<br>    boot_hart = cpuid();<br>    consoleinit();<br>    printfinit();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xv6 kernel is booting\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    kinit();         <span class="hljs-comment">// physical page allocator</span><br>    kvminit();       <span class="hljs-comment">// create kernel page table</span><br>    kvminithart();   <span class="hljs-comment">// turn on paging</span><br>    procinit();      <span class="hljs-comment">// process table</span><br>    trapinit();      <span class="hljs-comment">// trap vectors</span><br>    trapinithart();  <span class="hljs-comment">// install kernel trap vector</span><br>    plicinit();      <span class="hljs-comment">// set up interrupt controller</span><br>    plicinithart();  <span class="hljs-comment">// ask PLIC for device interrupts</span><br>    binit();         <span class="hljs-comment">// buffer cache</span><br>    <span class="hljs-comment">// iinit();         // inode table</span><br>    fileinit();      <span class="hljs-comment">// file table</span><br>    virtio_disk_init(); <span class="hljs-comment">// emulated hard disk</span><br>    userinit();      <span class="hljs-comment">// first user process</span><br>    <span class="hljs-comment">//started = 1;</span><br>    __sync_synchronize();<br>    <span class="hljs-comment">//启动其他核</span><br>    start_harts();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// while(started == 0)</span><br>    <span class="hljs-comment">//   ;</span><br>    __sync_synchronize();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hart %d starting\n&quot;</span>, cpuid());<br>    kvminithart();    <span class="hljs-comment">// turn on paging</span><br>    trapinithart();   <span class="hljs-comment">// install kernel trap vector</span><br>    plicinithart();   <span class="hljs-comment">// ask PLIC for device interrupts</span><br>  &#125;<br><br>  set_next_trigger();<br>  scheduler();        <br>&#125;<br><br><span class="hljs-type">void</span> <br><span class="hljs-title function_">start_harts</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; NCPU; i++ )&#123;<br>    <span class="hljs-keyword">if</span>(sbi_hart_get_status(i) == SBI_HSM_STATE_STOPPED)&#123;<br>      sbi_hart_start(i,(uint64)_entry,<span class="hljs-number">0</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>摘自FarmOs:</p><p>虽然说一个核就能完成大部分初始化工作，但因为架构要求，多核还是有一些需要各自初始化的代码。多核环境下需要注意这些事项：</p><ul><li>每个核需要设置独立的页表。允许各个核在运行阶段使用不同的页表</li><li>每个核有独立的核内时钟，为每个核单独计时</li><li>每个核有独立的中断处理向量，我们一般将其设为同一个位置</li><li>每个核有独立的外部中断控制器</li><li>当一个核与其他核访问同一个变量或同一块内存时，为了缓存能够及时同步，需要加 <code>fence</code> 指令，保证之前的所有读写指令在fence之后都已同步到内存。对应gcc的语法为 <code>__sync_synchronize()</code></li></ul><h2 id="SBI和BIOS和BOOTLOADER的关系"><a href="#SBI和BIOS和BOOTLOADER的关系" class="headerlink" title="SBI和BIOS和BOOTLOADER的关系"></a>SBI和BIOS和BOOTLOADER的关系</h2><blockquote><p>摘自 rCore</p></blockquote><p>SBI 是 RISC-V Supervisor Binary Interface 规范的缩写，OpenSBI 是RISC-V官方用C语言开发的SBI参考实现；RustSBI 是用Rust语言实现的SBI。</p><p>BIOS 是 Basic Input/Output System，作用是引导计算机系统的启动以及硬件测试，并向OS提供硬件抽象层。</p><p>机器上电之后，会从ROM中读取引导代码，引导整个计算机软硬件系统的启动。而整个启动过程是分为多个阶段的，现行通用的多阶段引导模型为：</p><p>ROM -&gt; LOADER -&gt; RUNTIME -&gt; BOOTLOADER -&gt; OS</p><ul><li>Loader 要干的事情，就是内存初始化，以及加载 Runtime 和 BootLoader 程序。而Loader自己也是一段程序，常见的Loader就包括 BIOS 和 UEFI，后者是前者的继任者。</li><li>Runtime 固件程序是为了提供运行时服务（runtime services），它是对硬件最基础的抽象，对OS提供服务，当我们要在同一套硬件系统中运行不同的操作系统，或者做硬件级别的虚拟化时，就离不开Runtime服务的支持。SBI就是RISC-V架构的Runtime规范。</li><li>BootLoader 要干的事情包括文件系统引导、网卡引导、操作系统启动配置项设置、操作系统加载等等。常见的 BootLoader 包括GRUB，U-Boot，LinuxBoot等。</li></ul><p>而 BIOS/UEFI 的大多数实现，都是 Loader、Runtime、BootLoader 三合一的，所以不能粗暴的认为 SBI 跟 BIOS/UEFI 有直接的可比性。</p><p>如果把BIOS当做一个泛化的术语使用，而不是指某个具体实现的话，那么可以认为 SBI 是 BIOS 的组成部分之一。</p><p>也可参考这份文稿《<a href="https://riscv.org/wp-content/uploads/2019/12/Summit_bootflow.pdf">An Introduction to RISC-V Boot Flow</a>》的P5, P7, P9-11。</p><p>题外话：<br>计算机最重要的思想之一就是分层抽象，在任意两层之间，还可以按照设计者的意愿再次添加抽象层。而软件架构的设计和实现，是为了解决现实世界的具体问题，会面临资源、财力、物力、人力、时间等多种因素的掣肘，就会诞生一些“不那么规矩”、“不那么单纯”的架构或组件/软件，它们往往会跨层次，跨模块，大模块拆小，小模块合并，甚至打破一些“金科玉律”等等。</p><p>所以，相比于弄懂一个名词，更多的精力应该放在理解事物的本质上，只要把解决问题的流程和方法弄明白了，解决问题的过程中所用到的子流程、工具、方法，你爱怎么叫怎么叫，甚至自己发明名词也可以（只是与外人沟通可能会不太顺畅）。</p>]]></content>
    
    
    
    <tags>
      
      <tag>xv6 openSBI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零到一的makefile</title>
    <link href="/2024/03/07/makefile/"/>
    <url>/2024/03/07/makefile/</url>
    
    <content type="html"><![CDATA[<p>笔者上手一些大型项目时，常常会看不懂Makefile而造成一些困难，因此参考资料形成了一篇文章，从完全零基础过来的，用时也不多。文末附上一个笔者最近学习的rCore的Makefile，看完全篇文章后一定可以看懂的，本文也可用于一个简单的中文手册查询。</p><span id="more"></span><p>一些好的学习资料：</p><p><a href="https://link.zhihu.com/?target=https://makefiletutorial.com/">Makefile Tutorial By Example</a></p><p>【从零开始学Makefile】 <a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/BV1Bv4y1J7QT/?p=35&share_source=copy_web&vd_source=576f3acb9c32919142fdca9c8e59711e">从零开始学Makefile_哔哩哔哩_bilibili</a></p><p><a href="https://link.zhihu.com/?target=https://gitee.com/yanmu_ym/cpp/blob/master/Make/make.md">Make/make.md · 岩木/CPP - Gitee.com</a></p><p><a href="https://seisman.github.io/how-to-write-makefile/">跟我一起写Makefile — 跟我一起写Makefile 1.0 文档 (seisman.github.io)</a></p><p>makefile有点像跟手动编译过程反着来，一步步去找依赖项</p><h1 id="规则的构成"><a href="#规则的构成" class="headerlink" title="规则的构成"></a><strong>规则</strong>的构成</h1><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">targets: prerequisites</span><br>command<br>command<br>command<br></code></pre></td></tr></table></figure><ul><li><p>targets（目标）：是文件名，通常一个规则只有一个targets</p></li><li><p>command（命令/方法）：创建目标的一系列步骤，需要用tab开头，</p></li><li><p>prerequisites（依赖）：也是文件名，可以有多个，用空格分隔，在运行目标的命令之前，这些文件需要存在。</p></li></ul><h1 id="命令和执行"><a href="#命令和执行" class="headerlink" title="命令和执行"></a>命令和执行</h1><h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><p>command其实就是执行shell的指令，默认一个command都是<strong>一个独立的shell</strong>来执行，如果需要所有command都在一个shell执行，需要<code>.ONESHELL</code></p><p>一个例子</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">all: </span><br>cd ..<br><span class="hljs-comment">#上面的cd不会影响这个echo，因为每行命令都在一个独立的shell里面运行</span><br>echo `pwd`<br><br><span class="hljs-comment"># 这个cd会影响echo，因为他们都在同一行，因此会打印出上级目录的路径</span><br>cd ..;echo `pwd`<br><br><span class="hljs-comment"># 和第二个一样，\表示在同一行</span><br>cd ..; \<br>echo `pwd`<br></code></pre></td></tr></table></figure><h2 id="command回显"><a href="#command回显" class="headerlink" title="command回显"></a><strong>command回显</strong></h2><p>command默认是先打印出语句，再执行内容，如果不需要先打印语句，在command前面加上<code>@</code></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">a: a.o</span><br>@echo hello<br></code></pre></td></tr></table></figure><p>也可以使用<code>.SILENT + 文件名</code>，表示直接执行不打印</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>如果一条规则当中包含多条Shell指令，每条指令执行完之后make都会检查返回状态，如果返回状态是0，则执行成功，继续执行下一条指令，直到最后一条指令执行完成之后，一条规则也就结束了。</p><p>如果过程中发生了错误，即某一条指令的返回值不是0，那么make就会终止执行当前规则中剩下的Shell指令。</p><p>例如</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">clean:</span><br>    rm main.o hello.o<br>    rm main.exe<br></code></pre></td></tr></table></figure><p>这时如果第一条rm main.o hello.o出错，第二条rm main.exe就不会执行。类似情况下，希望make忽视错误继续下一条指令。在指令开头<code>-</code>可以达到这种效果。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">clean:</span><br>    -rm main.o hello.o<br>    -rm main.exe<br></code></pre></td></tr></table></figure><p>也可以<code>make -k</code>，即使遇到错误也能继续执行，如果想一次查看Make的所有错误，可以使用<code>-k</code></p><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>在终端执行命令时，如果没有将目标作为 <code>make</code> 参数提供给命令，将运行第一个目标</p><p>make只会在这两种情况运行targets及其命令</p><ul><li>targets不存在，还未被创建</li><li>targets的依赖项更新了 （使用文件系统时间戳作为代理来确定是否有任何变化）</li></ul><p>一个示例</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">blah: blah.o</span><br>cc blah.o -o blah <span class="hljs-comment"># Runs third</span><br><br><span class="hljs-section">blah.o: blah.c</span><br>cc -c blah.c -o blah.o <span class="hljs-comment"># Runs second</span><br><br><span class="hljs-comment"># Typically blah.c would already exist, but I want to limit any additional required files</span><br><span class="hljs-section">blah.c:</span><br>echo <span class="hljs-string">&quot;int main() &#123; return 0; &#125;&quot;</span> &gt; blah.c <span class="hljs-comment"># Runs first</span><br></code></pre></td></tr></table></figure><p>以下 Makefile 最终运行所有三个目标。当您在终端中运行时 <code>make</code> ，它将构建一个按一系列步骤调用 <code>blah</code> 的程序：</p><ul><li>Make 选择目标，因为第一个目标是默认目标 <code>blah</code></li><li><code>blah</code> 需要 <code>blah.o</code> ，因此搜索 <code>blah.o</code> 目标</li><li><code>blah.o</code> 需要 <code>blah.c</code> ，因此搜索 <code>blah.c</code> 目标</li><li><code>blah.c</code> 没有依赖项，因此运行命令 <code>echo</code></li><li>然后运行该 <code>cc -c</code> 命令，因为所有 <code>blah.o</code> 依赖项都已完成</li><li>将运行 顶部 <code>cc</code> 命令，因为所有 <code>blah</code> 依赖项都已完成</li><li>就是这样： <code>blah</code> 是一个编译好的c程序</li></ul><p>可以看出targets会事先搜索依赖项是否已经创建，如果一个targets没有依赖项，那么会直接运行</p><p><strong>all</strong></p><p>运行all后面的所有目标</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">all: one two three</span><br><br><span class="hljs-section">one:</span><br>touch one<br><span class="hljs-section">two:</span><br>touch two<br><span class="hljs-section">three:</span><br>touch three<br><br><span class="hljs-section">clean:</span><br>rm -f one two three<br></code></pre></td></tr></table></figure><h2 id="一个规则多个目标"><a href="#一个规则多个目标" class="headerlink" title="一个规则多个目标"></a><strong>一个规则多个目标</strong></h2><p>当一个规则有多个目标时，将针对每个目标运行，<code>$@</code>是包含目标名称的<strong>auto</strong> 变量</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">all: f1.o f2.o</span><br><br>f1.o f2.o:<br>echo <span class="hljs-variable">$@</span><br><span class="hljs-comment"># Equivalent to:</span><br><span class="hljs-comment"># f1.o:</span><br><span class="hljs-comment"># echo f1.o</span><br><span class="hljs-comment"># f2.o:</span><br><span class="hljs-comment"># echo f2.o</span><br></code></pre></td></tr></table></figure><h2 id="同一目标多条规则"><a href="#同一目标多条规则" class="headerlink" title="同一目标多条规则"></a><strong>同一目标多条规则</strong></h2><p>同一目标可以对应多条规则。同一目标的所有规则中的依赖会被<strong>合并</strong>。但如果同一目标对应的多条规则都写了更新的command，则会使用最新的一条更新方法，并且会输出警告信息。</p><p>同一目标多规则通常用来给多个目标添加依赖而不用改动已写好的部分。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">input.o: input.cpp utility.inl</span><br>    g++ -c input.cpp<br><span class="hljs-section">main.o: main.cpp scene.h input.h test.h</span><br>    g++ -c main.cpp<br><span class="hljs-section">scene.o: scene.cpp scene.h utility.inl</span><br>    g++ -c scene.cpp<br><br>input.o main.o scene.o : common.h<br></code></pre></td></tr></table></figure><p>同时给三个目标添加了一个依赖common.h，但是不用修改上面已写好的部分。</p><p>作用是可以在后面给目标添加依赖</p><h2 id="为特定目标-模式-设置变量"><a href="#为特定目标-模式-设置变量" class="headerlink" title="为特定目标/模式 设置变量"></a>为特定目标/模式 设置变量</h2><p><strong>特定目标</strong></p><p>makefile的变量一般都是全局的，我们可以给特定目标设置只能他使用的变量</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">all: one = cool</span><br><br><span class="hljs-section">all: </span><br>echo one is defined: <span class="hljs-variable">$(one)</span><br><br><span class="hljs-section">other:</span><br>echo one is nothing: <span class="hljs-variable">$(one)</span><br></code></pre></td></tr></table></figure><ul><li>other目标看到的<code>$one</code>会打印一个空串</li></ul><p><strong>特定模式</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">%.c: one = cool</span><br><br><span class="hljs-section">blah.c: </span><br>echo one is defined: <span class="hljs-variable">$(one)</span><br><br><span class="hljs-section">other:</span><br>echo one is nothing: <span class="hljs-variable">$(one)</span><br></code></pre></td></tr></table></figure><h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><h2 id="普通依赖"><a href="#普通依赖" class="headerlink" title="普通依赖"></a><strong>普通依赖</strong></h2><p>前面说过的这种形式都是普通依赖。直接列在目标后面。普通依赖有两个特点：</p><ol><li>如果这一依赖是由其他规则生成的文件，那么执行到这一目标<strong>前</strong>会先执行生成依赖的那一规则</li><li>如果任何一个依赖文件修改时间比目标晚（更新了），那么就重新生成目标文件</li></ol><h2 id="order-only依赖"><a href="#order-only依赖" class="headerlink" title="order-only依赖"></a><strong>order-only依赖</strong></h2><p>依赖文件不存在时，会执行对应的方法生成，但<strong>依赖文件更新并不会导致目标文件的更新</strong></p><p>如果目标文件已存在，order-only依赖中的文件即使修改时间比目标文件晚，目标文件也不会更新。</p><p>定义方法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">targets : normal<span class="hljs-operator">-</span>prerequisites <span class="hljs-operator">|</span> <span class="hljs-keyword">order</span><span class="hljs-operator">-</span><span class="hljs-keyword">only</span><span class="hljs-operator">-</span>prerequisites<br></code></pre></td></tr></table></figure><p>normal-prerequisites部分可以为空</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><blockquote><p>变量定义类似C语言里的宏展开，只是字符串替换，因此变量只有一种类型：字符串</p></blockquote><p>变量只能是字符串。使用<code>:=</code> 或 <code>=</code></p><p><code>$(x)</code>就是用x这个字符串变量的值来替换<code>$(x)</code></p><p><code>$&#123;x&#125;</code>与<code>$(x)</code>等价</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">files := file1 file2<br><span class="hljs-section">some_file: </span><br>echo <span class="hljs-string">&quot;Look at this variable: &quot;</span> <span class="hljs-variable">$(files)</span><br></code></pre></td></tr></table></figure><p>会打印出<code>Look at this variable:  file1 file2</code></p><p>双<code>$</code>符号</p><p>如果想表示<code>$</code>这个符号</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># a 是 $b 这个字符串</span><br>a = $$b<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile">make_var = I am a make variable<br><span class="hljs-section">all:</span><br><span class="hljs-comment"># Same as running &quot;sh_var=&#x27;I am a shell variable&#x27;; echo $sh_var&quot; in the shell</span><br>sh_var=&#x27;I am a shell variable&#x27;; echo $$sh_var<br><br><span class="hljs-comment"># Same as running &quot;echo I am a make variable&quot; in the shell</span><br>echo <span class="hljs-variable">$(make_var)</span><br></code></pre></td></tr></table></figure><ul><li>对于<code>echo $$sh_var</code>，实际上等价于<code>echo $sh_var</code></li><li>而<code>echo $(make_var)</code>，实际上等价于<code>echo I am a make variable</code></li></ul><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>wildcard(通配符)</p><p><code>wildcard</code>函数：用于匹配文件名模式，可与<code>*</code>或<code>?</code>配合使用</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 查找当前目录下所有的 .c 文件</span><br>C_FILES := <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.c)</span><br><br><span class="hljs-comment"># 打印找到的 .c 文件列表</span><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-string">&quot;C files: <span class="hljs-variable">$(C_FILES)</span>&quot;</span><br></code></pre></td></tr></table></figure><p><code>*</code>：在文件系统中搜索匹配的文件名，匹配0或多个字符</p><ul><li>注意不要在变量定义中使用<code>*</code></li><li>当<code>*</code>没有匹配任何文件时，它将保持原样（除非在<code>wildcard</code>函数中运行）</li><li>建议<code>*</code>永远与wildcard配合使用</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs makefile">thing_wrong := *.o <span class="hljs-comment"># Don&#x27;t do this! &#x27;*&#x27; will not get expanded</span><br>thing_right := <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.o)</span><br><br><span class="hljs-section">all: one two three four</span><br><br><span class="hljs-comment"># Fails, because $(thing_wrong) is the string &quot;*.o&quot;</span><br><span class="hljs-section">one: <span class="hljs-variable">$(thing_wrong)</span></span><br><br><span class="hljs-comment"># Stays as *.o if there are no files that match this pattern :(</span><br><span class="hljs-section">two: *.o </span><br><br><span class="hljs-comment"># Works as you would expect! In this case, it does nothing.</span><br><span class="hljs-section">three: <span class="hljs-variable">$(thing_right)</span></span><br><br><span class="hljs-comment"># Same as rule three</span><br><span class="hljs-section">four: $(wildcard *.o)</span><br></code></pre></td></tr></table></figure><p><code>%</code></p><ul><li>当在匹配模式下使用时，会匹配字符串中的一个或多个字符</li><li>当在替换模式下使用时，会采用匹配的结果并将其替换在字符串中</li><li>常用于规则定义和特定函数</li></ul><h2 id="auto自动变量"><a href="#auto自动变量" class="headerlink" title="auto自动变量"></a>auto自动变量</h2><p><code>$@</code>：本条规则的目标名</p><p><code>$?</code>：依赖中修改过的文件名</p><p><code>$^</code>：所有依赖文件名，文件名不会重复，不包含order-only依赖 (就是<code>|</code>右边的)</p><p><code>$\*</code>：(简单理解)目标文件名的主干部分(即<u>不包括后缀名</u>)</p><h2 id="伪目标-PHONY"><a href="#伪目标-PHONY" class="headerlink" title="伪目标 .PHONY"></a><strong>伪目标 .PHONY</strong></h2><p>如果一个目标并不是一个文件，则这个目标就是伪目标。例如前面的clean目标。如果说在当前目录下有一个文件名称和这个目标名称冲突了，则这个目标就没法执行。这时候需要用到一个特殊的目标 .PHONY，将上面的clean目标改写如下</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: clean</span><br><span class="hljs-section">clean:</span><br>    rm block.o command.o input.o main.o scene.o test.o<br>    rm sudoku.exe<br></code></pre></td></tr></table></figure><p>这样即使当前目录下存在与目标同名的文件，该目标也能正常执行。</p><p><strong>伪目标的其他应用方式</strong></p><p>如果一条规则的依赖文件没有改动，则不会执行对应的更新方法。如果需要每次不论有没有改动都执行某一目标的更新方法，可以把对应的目标添加到.PHONY的依赖中，例如下面这种方式，则每次执行make都会更新test.o，不管其依赖文件有没有改动</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">test</span>.o: <span class="hljs-keyword">test</span>.cpp <span class="hljs-keyword">test</span>.h<br>        g++ -c <span class="hljs-keyword">test</span>.cpp<br><br>.PHONY: clean <span class="hljs-keyword">test</span>.o<br></code></pre></td></tr></table></figure><h2 id="Makefile读取过程"><a href="#Makefile读取过程" class="headerlink" title="Makefile读取过程"></a><strong>Makefile读取过程</strong></h2><p>GNU make分两个阶段来执行Makefile，第一阶段(读取阶段)：</p><ul><li>读取Makefile文件的所有内容</li><li>根据Makefile的内容在程序内建立起变量</li><li>在程序内构建起显式规则、隐式规则</li><li>建立目标和依赖之间的依赖图</li></ul><p>第二阶段(目标更新阶段)：</p><ul><li>用第一阶段构建起来的数据确定哪个目标需要更新然后执行对应的更新方法</li></ul><p>变量和函数的<strong>展开</strong>（针对<code>$</code>符号）如果发生在第一阶段，就称作<strong>立即展开</strong>（第一阶段读到的时候就展开），否则称为<strong>延迟展开</strong>。立即展开的变量或函数在第一个阶段，也就是Makefile被读取解析的时候就进行展开。延迟展开的变量或函数将会到用到的时候才会进行展开，有以下两种情况：</p><ul><li>在一个立即展开的表达式中用到</li><li>在第二个阶段中用到</li></ul><p><strong>显式规则中，目标和依赖部分都是立即展开，在更新方法中延迟展开</strong></p><p>一个例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile">a = ok<br><br><span class="hljs-comment">#file是=,所以延迟展开</span><br>file = <span class="hljs-variable">$(a)</span><br><br><span class="hljs-section">all:</span><br>@echo <span class="hljs-variable">$(file)</span><br><span class="hljs-comment"># a在第一阶段被覆盖为no，最后echo出no</span><br>a = no<br></code></pre></td></tr></table></figure><h2 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h2><h3 id="递归展开赋值（延迟展开）"><a href="#递归展开赋值（延迟展开）" class="headerlink" title="递归展开赋值（延迟展开）"></a><strong>递归展开赋值（延迟展开）</strong></h3><p>第一种方式就是直接使用=，这种方式如果赋值的时候右边是其他变量引用或者函数调用之类的，将不会做处理，直接保留原样，在使用到该变量的时候再来进行处理得到变量值（Makefile执行的第二个阶段再进行变量展开得到变量值）</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile">bar2 = ThisIsBar2No.1<br>foo = <span class="hljs-variable">$(bar)</span><br>foo2 = <span class="hljs-variable">$(bar2)</span><br><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(foo)</span>  <span class="hljs-comment"># Huh?</span><br>    @echo <span class="hljs-variable">$(foo2)</span>  <span class="hljs-comment"># ThisIsBar2No.2</span><br>    @echo <span class="hljs-variable">$(ugh)</span>   <span class="hljs-comment"># Huh?</span><br><br>bar = <span class="hljs-variable">$(ugh)</span><br>ugh = Huh?<br>bar2 = ThisIsBar2No.2<br></code></pre></td></tr></table></figure><h3 id="简单赋值-立即展开"><a href="#简单赋值-立即展开" class="headerlink" title="简单赋值(立即展开)"></a><strong>简单赋值(立即展开)</strong></h3><p>简单赋值使用:=或::=，这种方式如果等号右边是其他变量或者引用的话，将会在赋值的时候就进行处理得到变量值。（Makefile执行第一阶段进行变量展开）</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile">bar2 := ThisIsBar2No.1<br>foo := <span class="hljs-variable">$(bar)</span><br>foo2 := <span class="hljs-variable">$(bar2)</span><br><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(foo)</span>    <span class="hljs-comment"># 空串，没有内容 ！！</span><br>    @echo <span class="hljs-variable">$(foo2)</span>    <span class="hljs-comment"># ThisIsBar2No.1</span><br>    @echo <span class="hljs-variable">$(ugh)</span>    <span class="hljs-comment"># </span><br><br>bar := <span class="hljs-variable">$(ugh)</span><br>ugh := Huh?<br>bar2 := ThisIsBar2No.2<br></code></pre></td></tr></table></figure><h3 id="条件赋值"><a href="#条件赋值" class="headerlink" title="条件赋值"></a>条件赋值</h3><p>条件赋值使用?=，如果变量已经定义过了（即已经有值了），那么就保持原来的值，如果变量还没赋值过，就把右边的值赋给变量。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">var1 = 100<br>var1 ?= 200<br><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(var1)</span> <span class="hljs-comment"># 100 注释var1 = 100之后为200</span><br></code></pre></td></tr></table></figure><h3 id="Shell运行赋值"><a href="#Shell运行赋值" class="headerlink" title="Shell运行赋值"></a>Shell运行赋值</h3><p>使用<code>!=</code>，运行一个Shell指令后将返回值赋给一个变量</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">gcc_version != gcc --version<br>files != ls .<br></code></pre></td></tr></table></figure><h3 id="追加"><a href="#追加" class="headerlink" title="追加"></a>追加</h3><p> 使用 <code>+=</code> 用于追加</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">foo := start<br>foo += more<br><span class="hljs-comment"># foo变为 start more，中间有个空格</span><br><span class="hljs-section">all: </span><br>echo <span class="hljs-variable">$(foo)</span><br></code></pre></td></tr></table></figure><h2 id="取消变量"><a href="#取消变量" class="headerlink" title="取消变量"></a>取消变量</h2><p>如果想清除一个变量，用以下方法，变量就会变为空</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">undefine</span> &lt;变量名&gt;   如 <span class="hljs-keyword">undefine</span> files,  <span class="hljs-keyword">undefine</span> obj<br></code></pre></td></tr></table></figure><h2 id="变量替换引用"><a href="#变量替换引用" class="headerlink" title="变量替换引用"></a>变量替换引用</h2><p>语法：**$(var:a=b)<strong>，意思是将变量var的值当中每一项</strong>结尾**的a替换为b，直接上例子</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">files = main.cpp hello.cpp<br>objs := $(files:.cpp=.o) <span class="hljs-comment"># main.o hello.o</span><br><span class="hljs-comment"># 另一种写法</span><br>objs := $(files:%.cpp=%.o)<br></code></pre></td></tr></table></figure><h2 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h2><p>所有在Makefile中的变量，都可以在执行make时能过指定参数的方式进行覆盖。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">OverridDemo := ThisIsInMakefile<br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(OverridDemo)</span><br></code></pre></td></tr></table></figure><p>如果直接执行</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">make</span><br></code></pre></td></tr></table></figure><p>则上面的输出内容为<em>ThisIsInMakefile</em>，但可以在执行make时指定参数：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">make <span class="hljs-attribute">OverridDemo</span>=ThisIsFromOutShell # 等号两边不能有空格 !!<br><span class="hljs-comment"># 如果变量值中有空格，需要用引号</span><br>make <span class="hljs-attribute">OverridDemo</span>=“This Is <span class="hljs-keyword">From</span> Out Shell”<br></code></pre></td></tr></table></figure><p>则输出OverridDemo的值是ThisIsFromOutShell或This Is From Out Shell。</p><p>用这样的命令参数会覆盖Makefile中对应变量的值，如果不想被覆盖，可以在变量前加上<strong>override</strong>指令，override具有较高优先级，不会被命令参数覆盖</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">override</span> OverridDemo := ThisIsInMakefile<br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(OverridDemo)</span><br></code></pre></td></tr></table></figure><p>这样即使命令行指定参数，也只会为<code>ThisIsInMakefile</code></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">make <span class="hljs-attribute">OverridDemo</span>=ThisIsFromOutShell<br></code></pre></td></tr></table></figure><h2 id="绑定目标的变量"><a href="#绑定目标的变量" class="headerlink" title="绑定目标的变量"></a>绑定目标的变量</h2><p>Makefile中的变量一般是全局变量。也就是说定义之后在Makefile的任意位置都可以使用。但也可以将变量指定在某个目标的范围内，这样这个变量就只能在这个目标对应的规则里面保用</p><p>语法</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada">target … : <span class="hljs-type">variable</span>-assignment<br>target … : <span class="hljs-type">prerequisites</span><br>    recipes<br>    …<br></code></pre></td></tr></table></figure><p>例</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile">var1 = Global Var<br><br><span class="hljs-section">first: all t2</span><br><br><span class="hljs-section">all: var2 = Target All Var</span><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(var1)</span><br>    @echo <span class="hljs-variable">$(var2)</span><br><br><span class="hljs-section">t2:</span><br>    @echo <span class="hljs-variable">$(var1)</span><br>    @echo <span class="hljs-variable">$(var2)</span><br></code></pre></td></tr></table></figure><h1 id="静态模式规则"><a href="#静态模式规则" class="headerlink" title="静态模式规则"></a>静态模式规则</h1><p>静态模式就是用<code>%</code>进行文件匹配来推导出对应的依赖。</p><p><strong>语法</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">targets …: <span class="hljs-built_in">target-pattern</span>(目标模式): <span class="hljs-built_in">prereq-patterns</span>(依赖模式) …<br>        recipe<br>        …<br></code></pre></td></tr></table></figure><p>一个例子</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objects = foo.o bar.o all.o<br><span class="hljs-section">all: <span class="hljs-variable">$(objects)</span></span><br><br><span class="hljs-comment"># These files compile via implicit rules</span><br><span class="hljs-comment"># Syntax - targets ...: target-pattern: prereq-patterns ...</span><br><span class="hljs-comment"># In the case of the first target, foo.o, the target-pattern matches foo.o and sets the &quot;stem&quot; to be &quot;foo&quot;.</span><br><span class="hljs-comment"># It then replaces the &#x27;%&#x27; in prereq-patterns with that stem</span><br><span class="hljs-variable">$(objects)</span>: %.o: %.c<br><br><span class="hljs-section">all.c:</span><br>echo <span class="hljs-string">&quot;int main() &#123; return 0; &#125;&quot;</span> &gt; all.c<br><br><span class="hljs-section">%.c:</span><br>touch <span class="hljs-variable">$@</span><br><br><span class="hljs-section">clean:</span><br>rm -f *.c *.o all<br></code></pre></td></tr></table></figure><h1 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h1><h2 id="ifeq判断两个值是否相等"><a href="#ifeq判断两个值是否相等" class="headerlink" title="ifeq判断两个值是否相等"></a>ifeq判断两个值是否相等</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs makefile">version = 3.0<br><br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(version)</span>,1.0)            <span class="hljs-comment"># ifeq后一定要一个空格</span><br>    msg := 版本太旧了，请更新版本<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(version)</span>, 3.0)<br>    msg := 版本太新了，也不行<br><span class="hljs-keyword">else</span><br>    msg := 版本可以用<br><span class="hljs-keyword">endif</span><br><br><br><span class="hljs-comment"># 另外的写法</span><br>msg = Other<br><span class="hljs-keyword">ifeq</span> <span class="hljs-string">&quot;<span class="hljs-variable">$(OS)</span>&quot;</span> <span class="hljs-string">&quot;Windows_NT&quot;</span><br>    msg = This is a Windows Platform<br><span class="hljs-keyword">endif</span><br><br><span class="hljs-keyword">ifeq</span> &#x27;<span class="hljs-variable">$(OS)</span>&#x27; &#x27;Windows_NT&#x27;<br><br><span class="hljs-keyword">ifeq</span> &#x27;<span class="hljs-variable">$(OS)</span>&#x27; <span class="hljs-string">&quot;Windows_NT&quot;</span><br></code></pre></td></tr></table></figure><p>还有<code>ifneq</code>，用法相同，只是结果相反</p><h2 id="ifdef判断变量是否已经定义"><a href="#ifdef判断变量是否已经定义" class="headerlink" title="ifdef判断变量是否已经定义"></a>ifdef判断变量是否已经定义</h2><p><code>ifdef</code>不展开变量，他只是查看是否定义了变量</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile">bar =<br>foo = <span class="hljs-variable">$(bar)</span><br><br><span class="hljs-section">all:</span><br><span class="hljs-keyword">ifdef</span> foo<br>echo <span class="hljs-string">&quot;foo is defined&quot;</span><br><span class="hljs-keyword">endif</span><br><span class="hljs-keyword">ifndef</span> bar<br>echo <span class="hljs-string">&quot;but bar is not&quot;</span><br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><h2 id="ifndef-判断一个变量是否没被定义"><a href="#ifndef-判断一个变量是否没被定义" class="headerlink" title="ifndef 判断一个变量是否没被定义"></a><strong>ifndef</strong> 判断一个变量是否没被定义</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">ifndef</span> FLAGS<br>    FLAGS = -finput-charset=utf-8<br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p><strong>调用函数的语法</strong></p><p><code>$(fn, arguments)</code> 或 <code>$&#123;fn, arguments&#125;</code>，注意参数之间不要有空格，如果有空格的话将视为参数的一部分    </p><h2 id="字符替换与分析"><a href="#字符替换与分析" class="headerlink" title="字符替换与分析"></a>字符替换与分析</h2><h4 id="subst"><a href="#subst" class="headerlink" title="subst"></a><strong>subst</strong></h4><p>文本替换函数，返回替换后的文本</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">subst</span> target,replacement,text)</span><br>        --- 在text中，把target替换为replacement<br>        --- target 需要替换的内容<br>        --- replacement 替换为的内容<br>        --- text 需要处理的内容，可以是任意字符串<br><br><br><br>objs = main.o hello.o<br>srcs = <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> .o,.cpp,<span class="hljs-variable">$(objs)</span>)</span><br>headers = <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> .cpp,.h,<span class="hljs-variable">$(srcs)</span>)</span><br><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(srcs)</span><br>    @echo <span class="hljs-variable">$(headers)</span><br></code></pre></td></tr></table></figure><ul><li><p>如果要替换空格或者逗号，使用变量</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile">comma := ,<br>empty:=<br>space := <span class="hljs-variable">$(empty)</span> <span class="hljs-variable">$(empty)</span><br>foo := a b c<br>bar := <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> <span class="hljs-variable">$(space)</span>,<span class="hljs-variable">$(comma)</span>,<span class="hljs-variable">$(foo)</span>)</span><br><br><span class="hljs-section">all: </span><br>@echo <span class="hljs-variable">$(bar)</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="patsubst"><a href="#patsubst" class="headerlink" title="patsubst"></a><strong>patsubst</strong></h4><p>模式替换， 返回替换后的文本</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> pattern,replacement,text)</span><br>        --- pattern 需要替换的模式<br>        --- replacement 需要替换为<br>        --- text 待处理内容，各项内容需要用空格隔开<br><br><br>foo := a.o b.o l.a c.o<br>one := <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.o,%.c,<span class="hljs-variable">$(foo)</span>)</span><br><span class="hljs-comment"># This is a shorthand for the above</span><br>two := $(foo:%.o=%.c)<br><span class="hljs-comment"># This is the suffix-only shorthand, and is also equivalent to the above.</span><br>three := $(foo:.o=.c)<br><br><span class="hljs-section">all:</span><br>echo <span class="hljs-variable">$(one)</span><br>echo <span class="hljs-variable">$(two)</span><br>echo <span class="hljs-variable">$(three)</span>   <br></code></pre></td></tr></table></figure><ul><li>注意上面<code>two</code>和<code>three</code>的简写，也很常用</li></ul><h4 id="strip"><a href="#strip" class="headerlink" title="strip"></a><strong>strip</strong></h4><p>去除字符串头部和尾部的空格，中间如果连续有多个空格，则用一个空格替换，返回去除空格后的文本</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">strip</span> string)</span><br>        --- string 需要去除空格的字符串<br><br><br>files =     hello.cpp      main.cpp     test.cpp<br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">strip</span> <span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="findstring"><a href="#findstring" class="headerlink" title="findstring"></a>findstring</h4><p>查找字符串，如果找到了，则返回对应的字符串，如果没找到，则反回空串</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">findstring</span> find,string)</span><br>        --- find 需要查找的字符串<br>        --- string 用来查找的内容<br><br>files = hello.cpp main.cpp test.cpp<br><span class="hljs-comment">#返回&quot;hel&quot;</span><br>find = <span class="hljs-variable">$(<span class="hljs-built_in">findstring</span> hel,<span class="hljs-variable">$(files)</span>)</span> <br><span class="hljs-comment">#返回空串</span><br>find = <span class="hljs-variable">$(<span class="hljs-built_in">findstring</span> HEL,<span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>从文本中筛选出符合模式的内容并返回</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">filter</span> pattern…,text)</span><br>        --- pattern 模式，可以有多个，用空格隔开<br>        --- text 用来筛选的文本，多项内容需要用空格隔开，否则只会当一项来处理<br><br>files = hello.cpp main.cpp test.cpp main.o hello.o hello.h<br><span class="hljs-comment">#files2:main.o hello.o hello.h</span><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">filter</span> %.o %.h,<span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="filter-out"><a href="#filter-out" class="headerlink" title="filter-out"></a>filter-out</h4><p>与filter相反，过滤掉符合模式的，返回剩下的内容</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">filter</span>-out pattern…,text)</span><br>        --- pattern 模式，可以有多个，用空格隔开<br>        --- text 用来筛选的文本，多项内容需要用空格隔开，否则只会当一项来处理<br><br><br>files = hello.cpp main.cpp test.cpp main.o hello.o hello.h<br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">filter</span>-out %.o %.cpp,<span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>将文本内的各项按字典顺序排列，并且移除重复项</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">sort</span> list)</span><br>        --- list 需要排序内容<br><br><br>files = hello.cpp main.cpp test.cpp main.o hello.o hello.h main.cpp hello.cpp<br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">sort</span> <span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="word"><a href="#word" class="headerlink" title="word"></a>word</h4><p>用于返回文本中第n个单词 (注意下标从1开始的，不是0)</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">word</span> n,text)</span><br>        --- n 第n个单词，从1开始，如果n大于总单词数，则返回空串<br>        --- text 待处理文本<br><br>files = hello.cpp main.cpp test.cpp main.o hello.o hello.h main.cpp hello.cpp<br><span class="hljs-comment">#files2:test.cpp</span><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">word</span> 3,<span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="wordlist"><a href="#wordlist" class="headerlink" title="wordlist"></a>wordlist</h4><p>用于返回文本指定范围内的单词列表</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">wordlist</span> start,end,text)</span><br>        --- start 起始位置，如果大于单词总数，则返回空串<br>        --- end 结束位置，如果大于单词总数，则返回起始位置之后全部，如果start &gt; end，什么都不返回<br><br>files = hello.cpp main.cpp test.cpp main.o hello.o hello.h main.cpp hello.cpp<br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">wordlist</span> 3,6,<span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="words"><a href="#words" class="headerlink" title="words"></a>words</h4><p>返回文本中单词数</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(words text)</span><br>        --- text 需要处理的文本<br><br><br>files = hello.cpp main.cpp test.cpp main.o hello.o hello.h main.cpp hello.cpp<br>nums = <span class="hljs-variable">$(words <span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="firstword"><a href="#firstword" class="headerlink" title="firstword"></a>firstword</h4><p>返回第一个单词</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">firstword</span> <span class="hljs-params">text</span>)</span><br></code></pre></td></tr></table></figure><h4 id="lastword"><a href="#lastword" class="headerlink" title="lastword"></a>lastword</h4><p>返回最后一个单词</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">lastword</span> <span class="hljs-params">text</span>)</span><br></code></pre></td></tr></table></figure><h2 id="文件名处理函数"><a href="#文件名处理函数" class="headerlink" title="文件名处理函数"></a>文件名处理函数</h2><h4 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h4><p>返回文件目录</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">dir</span> files)</span><br>        --- files 需要返回目录的文件名，可以有多个，用空格隔开<br><br>files = src/hello.cpp main.cpp<br><span class="hljs-comment">#files2:src/ ./</span><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">dir</span> <span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="notdir"><a href="#notdir" class="headerlink" title="notdir"></a>notdir</h4><p>返回除目录部分的文件名</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">notdir</span> files)</span><br>        --- files 需要返回文件列表，可以有多个，用空格隔开<br><br>files = src/hello.cpp main.cpp<br><span class="hljs-comment">#files2:hello.cpp main.cpp</span><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">notdir</span> <span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="suffix"><a href="#suffix" class="headerlink" title="suffix"></a>suffix</h4><p>返回文件后缀名，如果没有后缀返回空</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">suffix</span> files)</span><br>        --- files 需要返回后缀的文件名，可以有多个，用空格隔开<br><br><br>files = src/hello.cpp main.cpp hello.o hello.hpp hello<br><span class="hljs-comment">#files2:.cpp .cpp .o .hpp</span><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">suffix</span> <span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="basename"><a href="#basename" class="headerlink" title="basename"></a>basename</h4><p>返回文件名除后缀的部分</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">basename</span> files)</span><br>        --- files 需要返回的文件名，可以有多个，用空格隔开<br><br><br>files = src/hello.cpp main.cpp hello.o hello.hpp hello<br><span class="hljs-comment">#files2:src/hello main hello hello hello</span><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">basename</span> <span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="addsuffix"><a href="#addsuffix" class="headerlink" title="addsuffix"></a>addsuffix</h4><p>给文件名添加后缀</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">addsuffix</span> <span class="hljs-built_in">suffix</span>,files)</span><br>        --- suffix 需要添加的后缀<br>        --- files 需要添加后缀的文件名，可以有多个，用空格隔开<br><br>files = src/hello.cpp main.cpp hello.o hello.hpp hello<br><span class="hljs-comment">#files2:src/hello.cpp.exe main.cpp.exe hello.o.exe hello.hpp.exe hello.exe</span><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">addsuffix</span> .exe,<span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="addprefix"><a href="#addprefix" class="headerlink" title="addprefix"></a>addprefix</h4><p>给文件名添加前缀</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> prefix,files)</span><br>        --- prefix 需要添加的前缀<br>        --- files 需要添加前缀的文件名，可以有多个，用空格隔开<br><br>files = src/hello.cpp main.cpp hello.o hello.hpp hello<br><span class="hljs-comment">#files2:make/src/hello.cpp make/main.cpp make/hello.o make/hello.hpp make/hello</span><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> make/,<span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p>将两个列表中的内容一对一连接，如果两个列表内容数量不相等，则多出来的部分原样返回，注意是有顺序之分的，比如下面这个例子如果改为<code>files2 = $(join $(f2),$(f1))</code>，结果是相反的</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">join</span> list1,list2)</span><br>        --- list1 第一个列表<br>        --- list2 需要连接的第二个列表<br><br><br>f1 = hello main test<br>f2 = .cpp .hpp<br><span class="hljs-comment">#files2:hello.cpp main.hpp test</span><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">join</span> <span class="hljs-variable">$(f1)</span>,<span class="hljs-variable">$(f2)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="wildcard"><a href="#wildcard" class="headerlink" title="wildcard"></a>wildcard</h4><p>返回符合通配符的文件列表</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> pattern)</span><br>        --- pattern 通配符<br><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.cpp)</span><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *)</span><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> src/*.cpp)</span><br></code></pre></td></tr></table></figure><h4 id="realpath"><a href="#realpath" class="headerlink" title="realpath"></a>realpath</h4><p>返回文件的绝对路径</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">realpath</span> files)</span><br>        --- files 需要返回绝对路径的文件，可以有多个，用空格隔开<br><br>f3 = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> src/*)</span><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">realpath</span> <span class="hljs-variable">$(f3)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="abspath"><a href="#abspath" class="headerlink" title="abspath"></a>abspath</h4><p>返回绝对路径，用法同realpath，如果一个文件名不存在，realpath不会返回内容，abspath则会返回一个当前文件夹一下的绝对路径</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">abspath</span> <span class="hljs-params">files</span>)</span><br></code></pre></td></tr></table></figure><h2 id="条件函数"><a href="#条件函数" class="headerlink" title="条件函数"></a>条件函数</h2><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><p><code>if</code> 检查第一个参数是否为<strong>非空</strong>。如果是这样，则运行第二个参数，否则运行第三个参数</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">if</span> condition,then-part[,else-part])</span><br>        --- condition 条件部分<br>        --- then-part 条件为真时执行的部分<br>        --- else-part 条件为假时执行的部分，如果省略则为假时返回空串<br><br>files = src/hello.cpp main.cpp hello.o hello.hpp hello<br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">if</span> <span class="hljs-variable">$(files)</span>,有文件,没有文件)</span><br></code></pre></td></tr></table></figure><h4 id="or"><a href="#or" class="headerlink" title="or"></a>or</h4><p>返回条件中第一个不为空的部分</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">or</span> condition1[,condition2[,condition3…]])</span><br><br>f1 = <br>f2 = <br>f3 = hello.cpp<br>f4 = main.cpp<br><span class="hljs-comment">#files2:hello.cpp</span><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">or</span> <span class="hljs-variable">$(f1)</span>,<span class="hljs-variable">$(f2)</span>,<span class="hljs-variable">$(f3)</span>,<span class="hljs-variable">$(f4)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="and"><a href="#and" class="headerlink" title="and"></a>and</h4><p>如果条件中有一个为空串，则返回空，如果全都不为空，则返回最后一个条件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">and</span> condition1[,condition2[,condition3…]])</span><br><br>f1 = 12<br>f2 = 34<br>f3 = hello.cpp<br>f4 = main.cpp<br><span class="hljs-comment">#files2:main.cpp</span><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">and</span> <span class="hljs-variable">$(f1)</span>,<span class="hljs-variable">$(f2)</span>,<span class="hljs-variable">$(f3)</span>,<span class="hljs-variable">$(f4)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="intcmp"><a href="#intcmp" class="headerlink" title="intcmp"></a>intcmp</h4><p>比较两个整数大小，并返回对应操作结果（GNU make 4.4以上版本）</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(intcmp lhs,rhs[,lt-part[,eq-part[,gt-part]]])</span> <br>        --- lhs 第一个数<br>        --- rhs 第二个数<br>        --- lt-part  lhs &lt; rhs时执行<br>        --- eq-part  lhs = rhs时执行<br>        --- gt-part  lhs &gt; rhs时执行<br>        --- 如果只提供前两个参数，则lhs == rhs时返回数值，否则返回空串<br>            参数为lhs,rhs,lt-part时，当lhs &lt; rhs时返回lt-part结果，否则返回空<br>            参数为lhs,rhs,lt-part,eq-part，lhs &lt; rhs返回lt-part结果，否则都返回eq-part结果<br>            参数全时，lhs &lt; rhs返回lt-part，lhs == rhs返回eq-part, lhs &gt; rhs返回gt-part<br><br><br><br>@echo <span class="hljs-variable">$(intcmp 2,2,-1,0,1)</span><br></code></pre></td></tr></table></figure><h2 id="file"><a href="#file" class="headerlink" title="file"></a>file</h2><p>读写文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">file</span> op filename[,text])</span><br>        --- op 操作<br>                &gt; 覆盖<br>                &gt;&gt; 追加<br>                &lt; 读<br>        --- filename 需要操作的文件名<br>        --- text 写入的文本内容，读取是不需要这个参数<br><br><br>files = src/hello.cpp main.cpp hello.o hello.hpp hello<br>write = <span class="hljs-variable">$(<span class="hljs-built_in">file</span> &gt; makewrite.txt,<span class="hljs-variable">$(files)</span>)</span><br>read = <span class="hljs-variable">$(<span class="hljs-built_in">file</span> &lt; makewrite.txt)</span><br></code></pre></td></tr></table></figure><h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><p>对一列用空格隔开的字符序列中每一项进行处理，并返回处理后的列表（将一个单词列表（用空格分隔）转换为另一个单词列表）</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> each,list,process)</span><br>        --- each list中的每一项<br>        --- list 需要处理的字符串序列，用空格隔开<br>        --- process 需要对每一项进行的处理<br><br>foo := who are you<br><span class="hljs-comment"># For each &quot;word&quot; in foo, output that same word with an exclamation after</span><br>bar := <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> wrd,<span class="hljs-variable">$(foo)</span>,<span class="hljs-variable">$(wrd)</span>!)</span><br><span class="hljs-section">all:</span><br><span class="hljs-comment"># Output is &quot;who! are! you!&quot;</span><br>@echo <span class="hljs-variable">$(bar)</span><br><br>list = 1 2 3 4 5<br>result = <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> each,<span class="hljs-variable">$(list)</span>,$(<span class="hljs-built_in">addprefix</span> cpp,$(<span class="hljs-built_in">addsuffix</span> .cpp,<span class="hljs-variable">$(each)</span>)</span>))<br></code></pre></td></tr></table></figure><p>第二个例子作用类似C/C++中的循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> list[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span> result[<span class="hljs-number">5</span>];<br><span class="hljs-type">int</span> each;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>&#123;<br>    each = list[i];<br>    result[i] = <span class="hljs-built_in">process</span>(each);<br>&#125;<br><span class="hljs-comment">// 此时result即为返回结果</span><br></code></pre></td></tr></table></figure><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><ul><li>Make支持创建函数，可以通过创建变量来定义函数，但使用参数 <code>$(0)</code> 、 <code>$(1)</code> 等，<code>$(0)</code> 是变量，而 <code>$(1)</code> 、 <code>$(2)</code> 等是参数</li></ul><p>将一些复杂的表达式写成一个变量，用call可以像调用函数一样进行调用。类似于编程语言中的自定义函数。在函数中可以用$(n)来访问第n个参数</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">call</span> funcname,param1,param2,…)</span><br>        --- funcname 自定义函数（变量名）<br>        --- 参数至少一个，可以有多个，用逗号隔开<br><br>sweet_new_fn = Variable Name: $(0) First: $(1) Second: $(2) Empty Variable: $(3)<br><br><span class="hljs-section">all:</span><br><span class="hljs-comment"># Outputs &quot;Variable Name: sweet_new_fn First: go Second: tigers Empty Variable:&quot;</span><br>@echo <span class="hljs-variable">$(<span class="hljs-built_in">call</span> sweet_new_fn, go, tigers)</span><br></code></pre></td></tr></table></figure><h2 id="value"><a href="#value" class="headerlink" title="value"></a>value</h2><p>对于不是立即展开的变量，可以查看变量的原始定义；对于立即展开的变量，直接返回变量值</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">value</span> variable)</span><br><br>var = value function test<br>var2 = <span class="hljs-variable">$(var)</span><br>var3 := <span class="hljs-variable">$(var)</span><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">value</span> var2)</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">value</span> var3)</span><br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>查看一个变量定义来源</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">origin</span> variable)</span><br><br><br>var2 = origin function <br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">origin</span> var1)</span>    <span class="hljs-comment"># undefined 未定义</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">origin</span> CC)</span>        <span class="hljs-comment"># default 默认变量</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">origin</span> JAVA_HOME)</span> <span class="hljs-comment"># environment 环境变量</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">origin</span> var2)</span>    <span class="hljs-comment"># file 在Makefile文件中定义的变量</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">origin</span> @)</span>        <span class="hljs-comment"># automatic 自动变量</span><br></code></pre></td></tr></table></figure><h2 id="flavor"><a href="#flavor" class="headerlink" title="flavor"></a>flavor</h2><p>查看一个变量的赋值方式</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">flavor</span> variable)</span><br><br>var2 = flavor function<br>var3 := flavor funciton<br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">flavor</span> var1)</span>    <span class="hljs-comment"># undefined 未定义</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">flavor</span> var2)</span>    <span class="hljs-comment"># recursive 递归展开赋值</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">flavor</span> var3)</span>    <span class="hljs-comment"># simple 简单赋值</span><br></code></pre></td></tr></table></figure><h2 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h2><p>可以将一段文本生成Makefile的内容</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">eval</span> text)</span><br><br><span class="hljs-keyword">define</span> eval_target = <br><span class="hljs-section">eval:</span><br>    @echo Target Eval Test<br><span class="hljs-keyword">endef</span><br><br><span class="hljs-variable">$(<span class="hljs-built_in">eval</span> <span class="hljs-variable">$(eval_target)</span>)</span><br></code></pre></td></tr></table></figure><p>以上，运行make时将会执行eval目标，输出<code>Target Eval Test</code></p><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>用于执行Shell命令</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">files = <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> ls *.cpp)</span><br><span class="hljs-variable">$(<span class="hljs-built_in">shell</span> echo This is from <span class="hljs-built_in">shell</span> function)</span><br></code></pre></td></tr></table></figure><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p>将一个字符串序列中的项拆开放入多个变量中，并对各个变量进行操作（GNU make 4.4以上版本），有点像rust里的解构</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(let var1 [var2 ...],[list],proc)</span><br>        --- var 变量，可以有多个，用空格隔开<br>        --- list 待处理字符串，各项之间空格隔开<br>        --- proc 对变量进行的操作，结果为let的返回值<br>            将list中的值依次一项一项放到var中，如果var的个数多于list项数，那多出来的var是空串。如果<br>            var的个数小于list项数，则先依次把前而的项放入var中，剩下的list所有项都放入最后一个var中<br><br><br>list = a b c d<br>letfirst = <span class="hljs-variable">$(let first second rest,<span class="hljs-variable">$(list)</span>,<span class="hljs-variable">$(first)</span>)</span><br>letrest = <span class="hljs-variable">$(let first second rest,<span class="hljs-variable">$(list)</span>,<span class="hljs-variable">$(rest)</span>)</span><br><br><br><span class="hljs-comment"># 结合call可以对所有项进行递归处理</span><br>reverse = <span class="hljs-variable">$(let first rest,$(1)</span>,<span class="hljs-variable">$(<span class="hljs-built_in">if</span> <span class="hljs-variable">$(rest)</span>,$(<span class="hljs-built_in">call</span> reverse,<span class="hljs-variable">$(rest)</span>)</span> )<span class="hljs-variable">$(first)</span>)<br><span class="hljs-section">all: ; @echo $(call reverse,d c b a)</span><br></code></pre></td></tr></table></figure><h2 id="信息提示函数"><a href="#信息提示函数" class="headerlink" title="信息提示函数"></a>信息提示函数</h2><h4 id="error"><a href="#error" class="headerlink" title="error"></a>error</h4><p>提示错误信息并终止make执行</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">error</span> text)</span><br>        --- text 提示信息<br><br>EXIT_STATUS = -1<br><span class="hljs-keyword">ifneq</span> (0, <span class="hljs-variable">$(EXIT_STATUS)</span>)<br>    <span class="hljs-variable">$(<span class="hljs-built_in">error</span> An <span class="hljs-built_in">error</span> occured! make stopped!)</span><br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><h4 id="warning"><a href="#warning" class="headerlink" title="warning"></a>warning</h4><p>提示警告信息，make不会终止</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">warning</span> text)</span><br><br><span class="hljs-keyword">ifneq</span> (0, <span class="hljs-variable">$(EXIT_STATUS)</span>)<br>    <span class="hljs-variable">$(<span class="hljs-built_in">warning</span> This is a <span class="hljs-built_in">warning</span> message)</span><br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><h4 id="info"><a href="#info" class="headerlink" title="info"></a>info</h4><p>输出一些信息</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(info text…)</span><br><br><span class="hljs-variable">$(info 编译开始.......)</span><br><span class="hljs-variable">$(info 编译结束)</span><br></code></pre></td></tr></table></figure><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>试试分析一下这个rust的makefile把，来自rCore</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs makefile">TARGET := riscv64gc-unknown-none-elf<br>MODE := release<br>APP_DIR := src/bin<br>TARGET_DIR := target/<span class="hljs-variable">$(TARGET)</span>/<span class="hljs-variable">$(MODE)</span><br>BUILD_DIR := build<br>OBJDUMP := rust-objdump --arch-name=riscv64<br>OBJCOPY := rust-objcopy --binary-architecture=riscv64<br>PY := python3<br><br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(MODE)</span>, release)<br>MODE_ARG := --release<br><span class="hljs-keyword">endif</span><br><br>BASE ?= 0<br>CHAPTER ?= 0<br>TEST ?= <span class="hljs-variable">$(CHAPTER)</span><br><br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(TEST)</span>, 0) <span class="hljs-comment"># No test, deprecated, previously used in v3</span><br>APPS :=  <span class="hljs-variable">$(<span class="hljs-built_in">filter</span>-out $(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(APP_DIR)</span>/ch*.rs)</span>, <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(APP_DIR)</span>/*.rs)</span>)<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(TEST)</span>, 1) <span class="hljs-comment"># All test</span><br>APPS :=  <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(APP_DIR)</span>/ch*.rs)</span><br><span class="hljs-keyword">else</span><br>TESTS := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> seq <span class="hljs-variable">$(BASE)</span> <span class="hljs-variable">$(TEST)</span>)</span><br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(BASE)</span>, 0) <span class="hljs-comment"># Normal tests only</span><br>APPS := <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> T, <span class="hljs-variable">$(TESTS)</span>, $(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(APP_DIR)</span>/ch<span class="hljs-variable">$(T)</span>_*.rs)</span>)<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(BASE)</span>, 1) <span class="hljs-comment"># Basic tests only</span><br>APPS := <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> T, <span class="hljs-variable">$(TESTS)</span>, $(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(APP_DIR)</span>/ch<span class="hljs-variable">$(T)</span>b_*.rs)</span>)<br><span class="hljs-keyword">else</span> <span class="hljs-comment"># Basic and normal</span><br>APPS := <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> T, <span class="hljs-variable">$(TESTS)</span>, $(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(APP_DIR)</span>/ch<span class="hljs-variable">$(T)</span>*.rs)</span>)<br><span class="hljs-keyword">endif</span><br><span class="hljs-keyword">endif</span><br><br>ELFS := <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> <span class="hljs-variable">$(APP_DIR)</span>/%.rs, <span class="hljs-variable">$(TARGET_DIR)</span>/%, <span class="hljs-variable">$(APPS)</span>)</span><br><br><span class="hljs-section">binary:</span><br>@echo <span class="hljs-variable">$(ELFS)</span><br>@if [ $&#123;CHAPTER&#125; -gt 3 ]; then \<br>cargo build <span class="hljs-variable">$(MODE_ARG)</span> ;\<br><span class="hljs-keyword">else</span> \<br>CHAPTER=<span class="hljs-variable">$(CHAPTER)</span> python3 build.py ;\<br>fi<br>@<span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> elf, <span class="hljs-variable">$(ELFS)</span>, \</span><br><span class="hljs-variable"><span class="hljs-variable">$(OBJCOPY)</span> <span class="hljs-variable">$(elf)</span> --<span class="hljs-built_in">strip</span>-all -O binary $(<span class="hljs-built_in">patsubst</span> <span class="hljs-variable">$(TARGET_DIR)</span>/%, <span class="hljs-variable">$(TARGET_DIR)</span>/%.bin, <span class="hljs-variable">$(elf)</span>)</span>; \<br>cp <span class="hljs-variable">$(elf)</span> <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> <span class="hljs-variable">$(TARGET_DIR)</span>/%, <span class="hljs-variable">$(TARGET_DIR)</span>/%.elf, <span class="hljs-variable">$(elf)</span>)</span>;)<br><br><span class="hljs-section">disasm:</span><br>@<span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> elf, <span class="hljs-variable">$(ELFS)</span>, \</span><br><span class="hljs-variable"><span class="hljs-variable">$(OBJDUMP)</span> <span class="hljs-variable">$(elf)</span> -S &gt; $(<span class="hljs-built_in">patsubst</span> <span class="hljs-variable">$(TARGET_DIR)</span>/%, <span class="hljs-variable">$(TARGET_DIR)</span>/%.asm, <span class="hljs-variable">$(elf)</span>)</span>;)<br>@<span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> t, <span class="hljs-variable">$(ELFS)</span>, cp <span class="hljs-variable">$(t)</span>.asm <span class="hljs-variable">$(BUILD_DIR)</span>/asm/;)</span><br><br><span class="hljs-section">pre:</span><br>@mkdir -p <span class="hljs-variable">$(BUILD_DIR)</span>/bin/<br>@mkdir -p <span class="hljs-variable">$(BUILD_DIR)</span>/elf/<br>@mkdir -p <span class="hljs-variable">$(BUILD_DIR)</span>/app/<br>@mkdir -p <span class="hljs-variable">$(BUILD_DIR)</span>/asm/<br>@<span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> t, <span class="hljs-variable">$(APPS)</span>, cp <span class="hljs-variable">$(t)</span> <span class="hljs-variable">$(BUILD_DIR)</span>/app/;)</span><br><br><span class="hljs-section">build: clean pre binary</span><br>@<span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> t, <span class="hljs-variable">$(ELFS)</span>, cp <span class="hljs-variable">$(t)</span>.bin <span class="hljs-variable">$(BUILD_DIR)</span>/bin/;)</span><br>@<span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> t, <span class="hljs-variable">$(ELFS)</span>, cp <span class="hljs-variable">$(t)</span>.elf <span class="hljs-variable">$(BUILD_DIR)</span>/elf/;)</span><br><br><span class="hljs-section">clean:</span><br>@cargo clean<br>@rm -rf <span class="hljs-variable">$(BUILD_DIR)</span><br><br><span class="hljs-section">all: build</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: elf binary build clean all</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Makefile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rCore-Blog</title>
    <link href="/2023/12/02/rCore-Blog/"/>
    <url>/2023/12/02/rCore-Blog/</url>
    
    <content type="html"><![CDATA[<p>2023 秋 rCore 训练营个人存档：二三阶段优秀</p><span id="more"></span><h1 id="二阶段实验总结"><a href="#二阶段实验总结" class="headerlink" title="二阶段实验总结"></a>二阶段实验总结</h1><h2 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a>lab1</h2><p>目的就是实现三个信息的统计</p><h3 id="status-TaskStatus"><a href="#status-TaskStatus" class="headerlink" title="status: TaskStatus"></a>status: TaskStatus</h3><ul><li>按照提示直接设置为running</li></ul><h3 id="syscall-times-u32-MAX-SYSCALL-NUM"><a href="#syscall-times-u32-MAX-SYSCALL-NUM" class="headerlink" title="[syscall_times: [u32; MAX_SYSCALL_NUM]"></a>[syscall_times: [u32; MAX_SYSCALL_NUM]</h3><ul><li>第一次尝试直接在sys_task_info来加载，发现好像不行，因为不知道传入的ti: *mut TaskInfo，这个参数到底在哪里被初始化的，而且每个任务都需要有一个syscall_times数组</li><li>由此我在<code>TaskControBlock</code>中维护一个<code>pub task_syscall_times: [u32; MAX_SYSCALL_NUM]</code>数组，这样通过全局遍历TASK_MANAGER可以很好的在每次系统调用时更新</li><li>更新位置在<code>trap_handler</code>进入<code>syscall之前</code>，读取x17寄存器为syscall id</li></ul><h3 id="time-usize"><a href="#time-usize" class="headerlink" title="time: usize"></a>time: usize</h3><ul><li><p>需要得到的是从第一次运行到现在的时间，现在的时间可以通过<code>get_time_ms</code>直接获得</p></li><li><p>第一次运行开始的时间，需要在应用第一次变成Running态的时候记载，因此我们为每个</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">TaskControBlock</span><br></code></pre></td></tr></table></figure><p>中维护</p><ul><li><code>pub task_start: usize,</code> 记录任务第一次开始的时间</li><li><code>pub task_flag: bool,</code> 标志是否为第一次，如果是就是false，然后我们更新<code>task_start</code>，并且将该变量置为false，保证只记录一次start time</li></ul></li></ul><h2 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h2><p>直接&lt;&lt;12直接这样会报错overflow，但是那个函数确实就是干了这个事情，只是我帮他弄了一把，很奇怪，还是最后用函数了</p><p>taskInfo报错，按照群里大佬这样修改，但不知道为什么这样修改</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//原</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_time_us</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>    time::<span class="hljs-title function_ invoke__">read</span>() / (CLOCK_FREQ / MICRO_PER_SEC)<br>&#125;<br><span class="hljs-comment">//修改为</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_time_us</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>    time::<span class="hljs-title function_ invoke__">read</span>() * MICRO_PER_SEC / CLOCK_FREQ<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><ol><li><code>vpn_end</code>计算有问题，len需要/8吗：不需要，因为VA就是取最低39位，不会左移右移啥的</li><li>上取整，如果已经对齐的情况下还会上取整吗：回答，不会的</li></ol><h3 id="bug与问题"><a href="#bug与问题" class="headerlink" title="bug与问题"></a>bug与问题</h3><ol><li>对于判断是否mapped过，只考虑了<code>find_pte</code>不能为<code>None</code>，没有考虑<code>find_pte</code>存在，但是<code>pte.is_valid()</code>不合法这件事，卡了很久，也不好调试</li><li>MapPermission不好进行零初始化，那么就用match，但是match要解决穷尽匹配，我们先把不合法的删去，然后最后一个_只代表<code>6</code>的情况</li><li>对题意理解有问题，在mmap中，我以为如果start和end之间有已经被映射的页，我们还是需要分配len这么长，也就是不error，映射一段不连续的虚拟内存，写了比较复杂，后面才知道直接error</li><li>这章很难debug，看样子甚至是多线程跑测试，所以花费很多时间</li></ol><h2 id="lab3"><a href="#lab3" class="headerlink" title="lab3"></a>lab3</h2><h3 id="继承上一章修改"><a href="#继承上一章修改" class="headerlink" title="继承上一章修改"></a>继承上一章修改</h3><p>今天上下午一直在移植代码，尝试了<code>git cherry-pick</code>试了很久，重置过去重置过来，问了gpt，看了b站，csdn都无果，就是没有合并，只显示reports文件夹有冲突，主要的os没有，遂还是采用<code>git diff</code>打patch的笨方法，冲突太多了，合并了小一个小时。</p><h3 id="修理waitpid"><a href="#修理waitpid" class="headerlink" title="修理waitpid"></a>修理waitpid</h3><p>移植好之后，<code>make run</code>确实能跑了，但是随便输一个就报错，说<code>waitpid</code>清除僵尸进程的引用计数有错，本来应该是1，结果是2，多了一个，debug找不出来，println也没看出来在哪里。仔细想想，找了跟<code>Arc</code>有关的所有代码，可以肯定一件事，模板代码一定没问题，那问题就出在我自己移植过来的代码，最后一个个注释排除法，找到了原来是我自己用了一个Arc没有drop，我以为drop了inner的RefMut就可以了，没想到这个也要drop。为啥这个不会自动drop呢？</p><p>目前还有usertest卡住的问题，再看看。</p><h3 id="spawn"><a href="#spawn" class="headerlink" title="spawn"></a>spawn</h3><p>通过注释发现卡住的原因是spawn的实现有问题，重点在维护父子关系，注意<code>drop</code>的位置</p><ul><li>spawn就是新建一个进程而已，不要想着用fork+exec，之前直接调用fork()和exec()会出问题，也不好调试，于是自己仿照fork内容与exec自己实现</li></ul><h3 id="stride"><a href="#stride" class="headerlink" title="stride"></a>stride</h3><p>stride感觉倒是很简单，根据提示BIG_STRIDE需要大一点，于是把BIG_STRIDE设置为了0x100000，然后每次调度的时候，都要fetch_task，于是在这里找出最小的stride返回，pass的维护在set_piro里面实现，因为prio只会在这里修改</p><h2 id="lab4"><a href="#lab4" class="headerlink" title="lab4"></a>lab4</h2><p>这章我真的心累了，调试了两天，目前还是有一个神奇的bug，我觉得不是我代码的问题</p><p>在<code>ch6_file2</code>里面：我做了如下修改，//后的就是新加入的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust">   <span class="hljs-keyword">let</span> <span class="hljs-variable">test_str</span> = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br>   <span class="hljs-keyword">let</span> <span class="hljs-variable">fname</span> = <span class="hljs-string">&quot;fname2\0&quot;</span>;<br>   <span class="hljs-keyword">let</span> (lname0, lname1, lname2) = (<span class="hljs-string">&quot;linkname0\0&quot;</span>, <span class="hljs-string">&quot;linkname1\0&quot;</span>, <span class="hljs-string">&quot;linkname2\0&quot;</span>);<br>   <span class="hljs-keyword">let</span> <span class="hljs-variable">fd</span> = <span class="hljs-title function_ invoke__">open</span>(fname, OpenFlags::CREATE | OpenFlags::WRONLY) <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>;<br><span class="hljs-comment">//</span><br>   <span class="hljs-keyword">let</span> <span class="hljs-variable">fd1</span> = <span class="hljs-title function_ invoke__">open</span>(lname0, OpenFlags::CREATE | OpenFlags::WRONLY) <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>;<br><span class="hljs-comment">//</span><br>   <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;ok1&quot;</span>);<br>   <span class="hljs-comment">//此处传入的lname0是0x0，为什么</span><br>   <span class="hljs-title function_ invoke__">link</span>(fname, lname0);<br><span class="hljs-comment">//</span><br>   <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;ok2&quot;</span>);<br>...<br></code></pre></td></tr></table></figure><p>发现在 link(fname, lname0);   //此处传入的lname0是<strong>0x0</strong>，为什么，看运行结果(在open系统调用和link加入了println!打印传入str的地址)，部分结果如下</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">open</span>:<span class="hljs-type">path</span>  <span class="hljs-keyword">is</span> <span class="hljs-number">0x42cd</span><br><span class="hljs-keyword">open</span>:<span class="hljs-type">path</span>  <span class="hljs-keyword">is</span> <span class="hljs-number">0x42d4</span><br>ok1<br>link:<span class="hljs-built_in">old</span> <span class="hljs-type">name</span> addr <span class="hljs-keyword">is</span> <span class="hljs-number">0x42cd</span><br>link:<span class="hljs-built_in">new</span> <span class="hljs-type">name</span> addr is0x0<br>old_name is6 ,new_name is45 <br>[kernel] Panicked at /root/<span class="hljs-number">2023</span>a-rcore-Ywinh/easy-fs/src/layout.rs:<span class="hljs-number">419</span> range <span class="hljs-keyword">end</span> <span class="hljs-keyword">index</span> <span class="hljs-number">45</span> <span class="hljs-keyword">out</span> <span class="hljs-keyword">of</span> range <span class="hljs-keyword">for</span> <span class="hljs-keyword">slice</span> <span class="hljs-keyword">of</span> length <span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><p>可以看到<code>lname</code>对应的<code>new name</code>在open里面的地址是<code>0x42d4</code>,但是在link里面是<code>0x0</code>，就是这个bug让我以为我的<code>link</code>出错了，改了一整天，后面copy别人的代码也不行，真的心累了。。请教了群里的一位大佬，还没回我，希望能解决…</p><p>解决！syscall 陷入时参数写错了，这个是 git cherry pick的时候自动覆盖掉了，很坑爹</p><p><strong>自己对于rust的理解还是不够，还是要在实践中多用，但很感谢能通过这个机会锻炼自己~~</strong></p><h1 id="三阶段总结"><a href="#三阶段总结" class="headerlink" title="三阶段总结"></a>三阶段总结</h1><p><strong>调试技巧：使用用户态 qemu 进行对拍</strong></p><p>测例库里编译的测例都是完全符合规范的 <code>RISC-V</code> 可执行程序，所以它当然可以在其他内核上运行。</p><p>如果你还记得，在 <code>rCore-Tutorial</code>的 <code>ch0</code>配环境的时候，安装了 <code>qemu-riscv64</code> 和 <code>qemu-system-riscv64</code>。后者用于运行实验，而前者实际上是一个用户态模拟器。换而言之，它可以直接运行用户态的 <code>RISC-V</code> 程序，我们可以直接把测例文件扔给它。</p><p>例如在 <code>testcases/</code> 目录下执行 <code>qemu-riscv64 ./build/hello</code>，就可以获取正确输出（可以打开 <code>testcases/src/hello.c</code> 看看正确输出长什么样）。</p><p>同样地，也可以执行 <code>qemu-riscv64 ./build/42</code>。这个用户程序在退出时返回了一个 <code>42</code>，不过没有打印输出。但我们可以在上面的命令之后立即执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> $?<br></code></pre></td></tr></table></figure><p>就可以看到返回值 <code>42</code></p><blockquote><p><code>$?</code> 是一个shell的变量，表示上一条命令的返回值。</p><p>在这个例子中，具体来说是 <code>qemu</code> 的返回值。它执行了我们要求的用户程序，然后把用户程序的返回值作为自己的返回值，推给宿主机。</p></blockquote><p>如此一来，后续我们每次遇到一个新的应用程序，就可以用 <code>qemu-riscv64</code> 进行检查，看看正常的“内核”运行它应该是什么样的，然后来推测我们的内核运行同一个测例时出了什么错。</p><p>我们把这种调试方式叫做“对拍”。</p><h2 id="lab1-1"><a href="#lab1-1" class="headerlink" title="lab1"></a>lab1</h2><h3 id="修改hello测例"><a href="#修改hello测例" class="headerlink" title="修改hello测例"></a>修改hello测例</h3><p>首先运行hello后，发现输出<code>Incorrect argc</code>，点进hello.c里面查看，发现是<code>argc</code>传入不对，结合实验书测例库里面，对于c语言和rCore的用户栈排布不一样，推测应该是这个原因，造成c语言里面传入的argc不是想要的参数</p><p>于是阅读ch7的命令行参数这一章节，了解了sys_exec是如何把命令行参数压入用户栈，以及用户库如何从用户栈上还原命令行参数</p><p>那么接下来就是找出C语言规定栈和rCore栈的区别了，为了方便把指导书上栈展示的顺序从低到高改为从高到低</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs prolog">position            content                     size (bytes)<br>  ------------------------------------------------------------------------<br>  stack pointer -&gt;  [ argc = number of args ]     <span class="hljs-number">8</span><br>                    [ argv[<span class="hljs-number">0</span>] (pointer) ]         <span class="hljs-number">8</span> (program name)<br>                    [ argv[<span class="hljs-number">1</span>] (pointer) ]         <span class="hljs-number">8</span><br>                    [ argv[..] (pointer) ]        <span class="hljs-number">8</span> * x<br>                    [ argv[n - <span class="hljs-number">1</span>] (pointer) ]     <span class="hljs-number">8</span><br>                    [ argv[n] (pointer) ]         <span class="hljs-number">8</span>   (= <span class="hljs-symbol">NULL</span>)<br><br>                    [ argv[<span class="hljs-number">0</span>] ]                   &gt;=<span class="hljs-number">0</span> (program name)<br>                    [ <span class="hljs-string">&#x27;\0&#x27;</span> ]                      <span class="hljs-number">1</span><br>                    [ argv[..] ]                  &gt;=<span class="hljs-number">0</span><br>                    [ <span class="hljs-string">&#x27;\0&#x27;</span> ]                      <span class="hljs-number">1</span><br>                    [ argv[n - <span class="hljs-number">1</span>] ]               &gt;=<span class="hljs-number">0</span><br>                    [ <span class="hljs-string">&#x27;\0&#x27;</span> ]                      <span class="hljs-number">1</span><br><br>  ------------------------------------------------------------------------<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202312031458613.png" alt="image-20231203145758498"></p><img src="https://rcore-os.cn/rCore-Tutorial-Book-v3/_images/user-stack-cmdargs.png" alt="../_images/user-stack-cmdargs.png" style="zoom: 67%;" /><p>可以发现<strong>黄色部分和蓝色部分顺序是反的</strong>，因此我们思路就有了，找到方法交换这两部分</p><p>修改后代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//首先预留好所有的位置,从后往前预留,其实顺序无关紧要，减去的总数都是一样的</span><br>      <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">0</span>..args.<span class="hljs-title function_ invoke__">len</span>()).<span class="hljs-title function_ invoke__">rev</span>() &#123;<br>          user_sp -= args[i].<span class="hljs-title function_ invoke__">len</span>() + <span class="hljs-number">1</span>;<br>      &#125;<br>      <span class="hljs-keyword">let</span> <span class="hljs-variable">argv_end</span> = user_sp;<br>      user_sp -= (args.<span class="hljs-title function_ invoke__">len</span>() + <span class="hljs-number">1</span>) * core::mem::size_of::&lt;<span class="hljs-type">usize</span>&gt;();<br>      <span class="hljs-comment">//准备写入，user_sp目前指向argv数组的起始地址</span><br>      <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">argv</span>: <span class="hljs-type">Vec</span>&lt;_&gt; = (<span class="hljs-number">0</span>..=args.<span class="hljs-title function_ invoke__">len</span>())<br>          .<span class="hljs-title function_ invoke__">map</span>(|arg| &#123;<br>              <span class="hljs-title function_ invoke__">translated_refmut</span>(<br>                  new_token,<br>                  (user_sp + arg * core::mem::size_of::&lt;<span class="hljs-type">usize</span>&gt;()) <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-type">usize</span>,<br>              )<br>          &#125;)<br>          .<span class="hljs-title function_ invoke__">collect</span>();<br>      *argv[args.<span class="hljs-title function_ invoke__">len</span>()] = <span class="hljs-number">0</span>;<br><br>      <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">temp_ptr</span> = argv_end;<br>      <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..args.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>          *argv[i] = temp_ptr;<br>          <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">p</span> = temp_ptr;<br>          <span class="hljs-keyword">for</span> <span class="hljs-variable">c</span> <span class="hljs-keyword">in</span> args[i].<span class="hljs-title function_ invoke__">as_bytes</span>() &#123;<br>              *<span class="hljs-title function_ invoke__">translated_refmut</span>(new_token, p <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-type">u8</span>) = *c;<br>              p += <span class="hljs-number">1</span>;<br>          &#125;<br>          *<span class="hljs-title function_ invoke__">translated_refmut</span>(new_token, p <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-type">u8</span>) = <span class="hljs-number">0</span>;<br>          temp_ptr += args[i].<span class="hljs-title function_ invoke__">len</span>() + <span class="hljs-number">1</span>;<br>      &#125;<br><br>      <span class="hljs-comment">//写入argc</span><br>      user_sp -= core::mem::size_of::&lt;<span class="hljs-type">usize</span>&gt;();<br>      *<span class="hljs-title function_ invoke__">translated_refmut</span>(new_token, user_sp <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-type">isize</span>) = args.<span class="hljs-title function_ invoke__">len</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">isize</span>;<br>...<br>...<br><span class="hljs-comment">// trap_cx.x[11] = argv_base;</span><br>      trap_cx.x[<span class="hljs-number">11</span>] = user_sp + core::mem::size_of::&lt;<span class="hljs-type">usize</span>&gt;();<br></code></pre></td></tr></table></figure><p>有一个很重要的点是，不要对齐user_sp，如果对齐了user_sp，那么在传入a1的时候，就不能这样赋值<code>user_sp + core::mem::size_of::&lt;usize&gt;()</code>，对齐后user_sp已经不是最初的版本了，会出现错误，一个解决方式是事先保存，不过rCore上面说不对齐对qemu没有影响，我就先不管了。</p><p><strong>实验结果</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202311142342402.png" alt="image-20231114234248317"></p><h3 id="问答题：elf与bin的区别"><a href="#问答题：elf与bin的区别" class="headerlink" title="问答题：elf与bin的区别"></a>问答题：elf与bin的区别</h3><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smali">ch6_file0.elf: ELF 64-bit LSB executable, UCB RISC-V, RVC,<span class="hljs-built_in"> double-float </span>ABI, version 1 (SYSV),<span class="hljs-keyword"> static</span>ally linked, stripped<br>ch6_file0.bin: data<br></code></pre></td></tr></table></figure><p> ELF 格式执行文件经过 <code>objcopy</code> 工具丢掉所有 ELF header 和符号变为二进制镜像文件bin</p><p>elf里面含有不少其他信息，程序头之类的，但是bin里面只有纯数据</p><p>如何使用反汇编：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">riscv64-linux-musl-objdump <span class="hljs-tag">&lt;<span class="hljs-name">path</span>&gt;</span> -ld &gt; <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>.S<br></code></pre></td></tr></table></figure><h2 id="lab2-1"><a href="#lab2-1" class="headerlink" title="lab2"></a>lab2</h2><h3 id="编程作业1：跟着教程做"><a href="#编程作业1：跟着教程做" class="headerlink" title="编程作业1：跟着教程做"></a>编程作业1：跟着教程做</h3><p>主要是要用引入的mod里的用户栈初始函数来替换lab1写的，具体如下，调用几个引入的mod里的api</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">elf</span> = ElfLoader::<span class="hljs-title function_ invoke__">new</span>(elf_data).<span class="hljs-title function_ invoke__">unwrap</span>();<br>user_sp = elf.<span class="hljs-title function_ invoke__">init_stack</span>(new_token, user_sp, args.<span class="hljs-title function_ invoke__">clone</span>());<br></code></pre></td></tr></table></figure><h3 id="编程作业2：添加syscall"><a href="#编程作业2：添加syscall" class="headerlink" title="编程作业2：添加syscall"></a>编程作业2：添加syscall</h3><p>根据教程，每步出现<code>Unsupported syscall_id: 29</code>这种报错，我们采用以下步骤初步处理</p><ol><li>在<code>syscall/mod.rs</code>里添加对应的<code>syscall_id</code>常量</li><li>查询对应id的syscall，通过<a href="https://jborza.com/post/2021-05-11-riscv-linux-syscalls/">此网页</a></li><li>重点关注<code>DESCRIPTION</code>,<code>RETURN VALUE</code>,<code>ERROR</code>，适当取舍实现</li></ol><p>通过报错我们依次处理了三个syscall</p><h4 id="29-sys-ioctl"><a href="#29-sys-ioctl" class="headerlink" title="29 sys_ioctl"></a>29 sys_ioctl</h4><p>尝试直接0返回，但是没有输出<code>hellostd</code>，尝试直接搬过来sys_write，但是失败（不知道怎么实现）</p><p>进汇编看一下调用ioctl的时候，传了哪些参数，因为翻看手册对里面写的<code>request</code>参数感觉很模糊，不知道要干嘛</p><p>在ecall前，传入的参数为</p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202311151404589.png" alt="image-20231115140405483"></p><p>后来发现这个地方<strong>直接0返回就行</strong>，因为我把<code>writev</code>看成了<code>readv</code>，因此输出<code>hellostd</code>这个活应该是在<code>writev</code>这里干的</p><h4 id="66-sys-writev"><a href="#66-sys-writev" class="headerlink" title="66 sys_writev"></a>66 sys_writev</h4><blockquote><p>这里一开始看错了，把66看成了readv，导致全部syscall改完之后，以为唯一需要更改的是ioctl这个，但是无从下手，事实上readv,writev这两个对应的手册就是一样的…</p></blockquote><h5 id="思考过程"><a href="#思考过程" class="headerlink" title="思考过程"></a>思考过程</h5><p>发现直接调用<code>sys_write</code>好像不行，报错</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">xrzr</span>|r~r[kernel] Panicked at src/fs/stdio.rs:<span class="hljs-number">55</span> called `Result::unwrap()` <span class="hljs-literal">on</span> an `Err` value: Utf8Error &#123; valid_up_to: <span class="hljs-number">0</span>, error_len: Some(<span class="hljs-number">1</span>) &#125;<br></code></pre></td></tr></table></figure><p>转回去看手册，<code>writev</code>就是从几个地址写入<code>fd</code>，写入<code>iovcnt</code>次，因此思路就是调用<code>iovcnt</code>次<code>sys_write</code>，但是为了保险起见，我还是没有使用嵌套的系统调用，复制粘贴修改了一下<code>sys_write</code>写到<code>sys_writev</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">writev</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> iovec *iov, <span class="hljs-type">int</span> iovcnt)</span>;<br></code></pre></td></tr></table></figure><p>去查阅了一下<code>musl</code>源码，全局搜索<code>iovec</code>，得到<code>iovec</code>结构体的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">STRUCT iovec &#123; <span class="hljs-type">void</span> *iov_base; <span class="hljs-type">size_t</span> iov_len; &#125;;<br></code></pre></td></tr></table></figure><p>改写到rust中</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust">/os/src/syscall/<span class="hljs-keyword">mod</span>.rs<br><br><span class="hljs-comment">/// Iovec</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Iovec</span> &#123;<br>    <span class="hljs-comment">/// base addr</span><br>    <span class="hljs-keyword">pub</span> iov_base: *<span class="hljs-keyword">const</span> <span class="hljs-type">u8</span>,<br>    <span class="hljs-comment">/// len</span><br>    <span class="hljs-keyword">pub</span> iov_len: <span class="hljs-type">usize</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// writev syscall</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sys_writev</span>(fd: <span class="hljs-type">usize</span>, buf: *<span class="hljs-keyword">const</span> Iovec, iovcnt: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">isize</span> &#123;<br>    <span class="hljs-comment">// println!(&quot;fd is &#123;&#125;&quot;, fd);</span><br>    <span class="hljs-comment">// println!(&quot;buf is &#123;:?&#125;&quot;, buf);</span><br>    <span class="hljs-comment">// println!(&quot;iovcnt is &#123;&#125;&quot;, iovcnt);</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">token</span> = <span class="hljs-title function_ invoke__">current_user_token</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">process</span> = <span class="hljs-title function_ invoke__">current_process</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">inner</span> = process.<span class="hljs-title function_ invoke__">inner_exclusive_access</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">write_num</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> fd &gt;= inner.fd_table.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(file) = &amp;inner.fd_table[fd] &#123;<br>        <span class="hljs-keyword">if</span> !file.<span class="hljs-title function_ invoke__">writable</span>() &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">file</span> = file.<span class="hljs-title function_ invoke__">clone</span>();<br>        <span class="hljs-comment">// release current task TCB manually to avoid multi-borrow</span><br>        <span class="hljs-title function_ invoke__">drop</span>(inner);<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..iovcnt &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">iov_ptr</span> = <span class="hljs-title function_ invoke__">translated_ref</span>(token, buf.<span class="hljs-title function_ invoke__">wrapping_add</span>(i));<br>            write_num += file.<span class="hljs-title function_ invoke__">write</span>(UserBuffer::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">translated_byte_buffer</span>(<br>                token,<br>                (*iov_ptr).iov_base,<br>                (*iov_ptr).iov_len,<br>            ))) <span class="hljs-keyword">as</span> <span class="hljs-type">isize</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    write_num<br>&#125;<br></code></pre></td></tr></table></figure><p>自己第一次没思考清晰的地方</p><ul><li>在这个函数里面传入了<code>Iovec</code>结构体的指针，这是个虚拟地址，需要先得到它的物理地址才能访问这个结构体里面存的东西，对应<code>translated_ref</code></li><li>结构体内存的是一个虚拟地址和一个usize，因此这个虚拟地址还需要再次翻译才能正确写入，对应<code>translated_byte_buffer</code></li></ul><p><strong>最终结果</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202311151608600.png" alt="image-20231115160854543"></p><h4 id="94-sys-exitgroup"><a href="#94-sys-exitgroup" class="headerlink" title="94 sys_exitgroup"></a>94 sys_exitgroup</h4><blockquote><p>退出一个进程的所有线程</p></blockquote><p>尝试直接0返回，成功</p><h4 id="问答作业"><a href="#问答作业" class="headerlink" title="问答作业"></a>问答作业</h4><p>options，调用可直接按位或</p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202311151710134.png" alt="image-20231115171046087"></p><h2 id="lab3-1"><a href="#lab3-1" class="headerlink" title="lab3"></a>lab3</h2><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p><strong>思考题1.1</strong></p><p>cargo缓存比如log库的代码在：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/root/</span>.cargo<span class="hljs-regexp">/registry/</span>src<span class="hljs-regexp">/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/</span>log-<span class="hljs-number">0.4</span>.<span class="hljs-number">20</span>/src<br></code></pre></td></tr></table></figure><p><strong>思考题1.2</strong>：如果忘记 <code>make clean</code> 会发生什么？</p><p>不会panic，而是make run成功</p><p><strong>思考题2</strong>：在<a href="https://scpointer.github.io/rcore2oscomp/docs/lab3/before.html">部分往届内核及运行指引</a> 一节提到的内核中挑选一个，描述它在默认情况下启动后会执行哪些测例（抑或是直接启动终端）。</p><p>选择的<a href="https://github.com/greenhandzpx/Titanix">Titanix</a></p><p>首先看了下readme，得知<code>make run</code>之后会进入busybox的shell，因此第一个应该就是busybox</p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202311191437705.png" alt="image-20231119143736590"></p><p>测试用例</p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202311191438324.png" alt="image-20231119143810275"></p><p><strong>思考题3.1</strong>：为什么要在开头结尾各输出一句，会不会太过重复？（提示：考虑执行出错的情况，或者 <code>sys_exit</code> ）</p><p>开头的是必须的，可以看到<code>exitgroup</code>每次都是直接退出，没有输出返回值，对比一下图中的两个框</p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202311211756068.png" alt="image-20231121175645028"></p><p><strong>思考题3.2</strong>：为什么要结尾还要输出一遍 <code>syscall</code> 的完整参数，只输出返回值行不行？（提示：考虑像 <code>sys_yield</code> 这样的 <code>syscall</code>）</p><p>yield用于切换进程，让出当前进程的执行权，如果切换到其他进程，参数是会改变的，因此结尾要再输出一遍完整参数</p><h3 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h3><p>使用方法：直接把<code>strace</code>加在要运行的命令之前，就能看到执行命令过程中执行的所有<code>syscall</code></p><p>注意执行strace的路径应该要有执行命令的elf或文件</p><p><code>strace</code> 也可以加一些参数，常用的有</p><ul><li><code>-c</code> 按种类统计 <code>syscall</code> 的执行时间、次数和报错次数。注意，“报错”只是代表返回小于 0 的错误码，不代表用户程序出错。例如检查文件是否不存在时也可以用 <code>sys_openat</code> ，得到 <code>ENOENT</code>（没有此文件）的结果属于“报错”，但这就是我们预期的结果。</li><li><code>-p &lt;PID&gt;</code> 表示指定追踪的进程ID。如果想调试一个大的应用程序，可能会有许多进程共同协作，我们可以指定关心某一个</li><li><code>-t</code> 输出时间信息；<code>-T</code> 显示每次调用的时间</li><li><code>-f</code> 追踪 <code>fork</code>；<code>-F</code> 追踪 <code>fork</code> 和 <code>vfork</code></li><li><code>-e [!]value[,value2]</code>指定要追踪的<code>syscall</code><ul><li>如<code>-e clone,read</code>就是只看<code>sys_clone</code>和<code>sys_read</code></li><li><code>-e \!read</code>表示不看<code>sys_read</code></li></ul></li></ul><h3 id="实验3-1-修复busybox-mv"><a href="#实验3-1-修复busybox-mv" class="headerlink" title="实验3.1 修复busybox mv"></a>实验3.1 修复busybox mv</h3><p>首先捋一下教程里面修复<code>ls</code>的过程</p><ul><li>修改启动侧例，单独分析有问题的<code>ls</code>的输出</li><li>在<code>syscall</code>函数里面，写上<code>error!</code>输出信息（包括：<code>syscall id</code>，<code>args</code>），方便调试</li><li>make run获取错误答案</li><li>调试往届内核错误，应该找Linux的syscall对拍，使用<code>strace</code>，采用在本机调试（涉及具体文件操作？）</li><li>strace获取“标准答案”</li><li>对照找不同，可以依据linux文档找syscall定义</li></ul><p><strong>实验</strong></p><p>首先获取标准答案：</p><p><code>strace busybox mv abc bin/</code></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">...                            <br><span class="hljs-function"><span class="hljs-title">newfstatat</span><span class="hljs-params">(AT_FDCWD, <span class="hljs-string">&quot;bin/&quot;</span>, &#123;st_mode=S_IFDIR|<span class="hljs-number">0755</span>, st_size=<span class="hljs-number">4096</span>, ...&#125;, <span class="hljs-number">0</span>)</span></span> = <span class="hljs-number">0</span><br><span class="hljs-function"><span class="hljs-title">newfstatat</span><span class="hljs-params">(AT_FDCWD, <span class="hljs-string">&quot;bin/abc&quot;</span>, <span class="hljs-number">0</span>x7ffd45e76cc8, <span class="hljs-number">0</span>)</span></span> = -<span class="hljs-number">1</span> ENOENT (No such file or directory)<br><span class="hljs-function"><span class="hljs-title">rename</span><span class="hljs-params">(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;bin/abc&quot;</span>)</span></span>                = <span class="hljs-number">0</span><br>...<br></code></pre></td></tr></table></figure><p><code>make run</code>，题目说是<code>mv</code>的问题，因此只截取了<code>mv</code>片段：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs inform7">...<br><span class="hljs-comment">[syscall]</span> id = FSTATAT, args = <span class="hljs-comment">[18446744073709551516, 1073741382, 1073740160, 0, 1073741382, 18446744073709551516]</span>, entry<br><span class="hljs-keyword">Is</span> a directory<br><span class="hljs-comment">[syscall]</span> id = 79, args = <span class="hljs-comment">[18446744073709551516, 1073741382, 1073740160, 0, 1073741382, 18446744073709551516]</span>, return 0<br><span class="hljs-comment">[syscall]</span> id = BRK, args = <span class="hljs-comment">[0, 64, 1458528, 0, 1457024, 4096]</span>, entry<br><span class="hljs-comment">[syscall]</span> id = 214, args = <span class="hljs-comment">[0, 64, 1458528, 0, 1457024, 4096]</span>, return 1067450368<br><span class="hljs-comment">[syscall]</span> id = MMAP, args = <span class="hljs-comment">[0, 4096, 3, 34, 18446744073709551615, 0]</span>, entry<br><span class="hljs-comment">[syscall]</span> id = 222, args = <span class="hljs-comment">[0, 4096, 3, 34, 18446744073709551615, 0]</span>, return 4096<br><br><span class="hljs-comment">[syscall]</span> id = FSTATAT, args = <span class="hljs-comment">[18446744073709551516, 4128, 1073740160, 0, 4128, 18446744073709551516]</span>, entry<br><span class="hljs-comment">[syscall]</span> id = 79, args = <span class="hljs-comment">[18446744073709551516, 4128, 1073740160, 0, 4128, 18446744073709551516]</span>, return -64<br><br><span class="hljs-comment">[syscall]</span> id = WRITE, args = <span class="hljs-comment">[2, 1073740112, 47, 0, 0, 0]</span>, entry<br>mv: can&#x27;t stat &#x27;bin/abc&#x27;: No error information<br><span class="hljs-comment">[syscall]</span> id = 64, args = <span class="hljs-comment">[2, 1073740112, 47, 0, 0, 0]</span>, return 47<br>...<br></code></pre></td></tr></table></figure><ul><li>可以看到中间有个<code>FSTATAT</code>返回了<code>-64</code>，阅读<code>deal_result</code>知道返回值的处理是添加一个<code>-</code>号，因此实际是返回一个64</li></ul><p>make run LOG=debug得到一个error：<code>get stat error: ENONET</code></p><p>应该就是<code>fstatat</code>有问题吧</p><p>根据fstat的debug信息查看一下调用了哪些函数 </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[syscall] id = FSTATAT, args = [<span class="hljs-number">18446744073709551516</span>, <span class="hljs-number">4128</span>, <span class="hljs-number">1073740160</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4128</span>, <span class="hljs-number">18446744073709551516</span>], entry<br>path : <span class="hljs-regexp">/bin/</span>abc<br><span class="hljs-keyword">Into</span> function new_fd, path: <span class="hljs-regexp">/bin/</span>abc<br>open <span class="hljs-keyword">file</span>: <span class="hljs-regexp">/bin/</span>abc <span class="hljs-keyword">READ</span><br>lookup at root: <span class="hljs-regexp">/bin/</span>abc<br>lookup at fatfs: bin/abc<br>get stat error: ENONET<br>[syscall] id = <span class="hljs-number">79</span>, args = [<span class="hljs-number">18446744073709551516</span>, <span class="hljs-number">4128</span>, <span class="hljs-number">1073740160</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4128</span>, <span class="hljs-number">18446744073709551516</span>], <span class="hljs-keyword">return</span> -<span class="hljs-number">64</span><br></code></pre></td></tr></table></figure><p><code>get_stat_in_fs</code>一定返回一个err，全局搜索<code>ENONET</code>定位了错误位置，在此修改即可，注意根据调试信息可以知道<code>get stat error</code>出现的位置，防止混淆（因为有多个<code>get stat error</code>）</p><p>依据strace得到正确的返回值应该是<code>-1</code>，但是<code>ENOENT</code>在<code>LinuxError</code>对应的是<code>2</code>呀，根据语义修改为<code>ENOENT</code></p><p>修改后返回值可以对上了，但是<code>mv</code>报错：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">mv: can<span class="hljs-symbol">&#x27;t</span> rename <span class="hljs-symbol">&#x27;abc</span>&#x27;: Operation <span class="hljs-keyword">not</span> permitted<br></code></pre></td></tr></table></figure><p>翻译一下<code>renameat(2)</code>的内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">renameat2</span><span class="hljs-params">(<span class="hljs-type">int</span> olddirfd, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *oldpath,</span><br><span class="hljs-params">                    <span class="hljs-type">int</span> newdirfd, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *newpath, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span>;<br></code></pre></td></tr></table></figure><p><strong>描述</strong></p><ul><li>用于重命名文件，如果需要，可以将文件移动到其他目录。对文件创建的硬链接（使用<code>link(2)</code>创建）不受影响。对于<code>oldpath</code>的打开文件描述符也不受影响。</li><li>如果<code>newpath</code>已经存在，它将被原子性地替换，因此在访问<code>newpath</code>时不会找不到文件的情况。但是，可能存在一个时间窗口，其中<code>oldpath</code>和<code>newpath</code>都引用正在被重命名的文件。</li><li>如果<code>oldpath</code>和<code>newpath</code>是引用同一文件的现有硬链接，则<code>rename()</code>不执行任何操作，并返回成功状态。</li><li>如果<code>newpath</code>存在但由于某种原因操作失败，<code>rename()</code>保证保留<code>newpath</code>的一个实例。</li><li><code>oldpath</code>可以指定一个目录。在这种情况下，<code>newpath</code>要么不存在，要么必须指定为空目录。这个有疑问</li><li>如果<code>oldpath</code>是符号链接，则重命名该链接；如果<code>newpath</code>是符号链接，则将覆盖该链接。</li><li>如果<code>oldpath</code>中给定的路径是相对路径，则它相对于由文件描述符<code>olddirfd</code>引用的目录进行解释（而不是相对于调用进程的当前工作目录，如<code>rename()</code>对于相对路径所做的那样）。如果<code>oldpath</code>是相对路径且<code>olddirfd</code>是特殊值<code>AT_FDCWD</code>，则<code>oldpath</code>相对于调用进程的当前工作目录进行解释</li></ul><p><strong>flags</strong></p><ul><li><p><code>RENAME_EXCHANGE</code>：原子地交换<code>oldpath</code>和<code>newpath</code>。这两个路径必须存在，但可以是不同类型的（例如，一个可能是非空目录，另一个可能是符号链接）。</p></li><li><p><code>RENAME_NOREPLACE</code>：不要覆盖<code>rename</code>的<code>newpath</code>。如果<code>newpath</code>已经存在，则返回错误。<code>RENAME_NOREPLACE</code>不能与<code>RENAME_EXCHANGE</code>一起使用。</p></li><li><p><code>RENAME_WHITEOUT</code>（自Linux 3.18起）：此操作仅对overlay/union文件系统实现有意义。指定<code>RENAME_WHITEOUT</code>会在重命名的源文件同时创建一个”whiteout”对象。整个操作是原子的，因此如果重命名成功，则”whiteout”也将已创建。”Whiteout”是在union/overlay文件系统结构中具有特殊含义的对象。在这些结构中，存在多个层，只有顶层会被修改。在上层的”whiteout”将有效地隐藏下层的匹配文件，使其看起来好像文件不存在。当重命名存在于下层的文件时，首先将文件复制到上层（如果尚未在上层），然后在上层以读写方式重命名。同时，源文件需要被”whiteout”（以使下层的源文件版本变得不可见）。整个操作需要原子执行。在非union/overlay中，”whiteout”显示为带有{0,0}设备号的字符设备。<code>RENAME_WHITEOUT</code>需要与创建设备节点相同的特权（即<code>CAP_MKNOD</code>能力）。<code>RENAME_WHITEOUT</code>不能与<code>RENAME_EXCHANGE</code>一起使用。<code>RENAME_WHITEOUT</code>需要底层文件系统的支持。支持它的文件系统包括tmpfs（自Linux 3.18起）、ext4（自Linux 3.18起）、XFS（自Linux 4.1起）、f2fs（自Linux 4.2起）、btrfs（自Linux 4.7起）和ubifs（自Linux 4.9起）。</p></li></ul><p>把oldpath复制到newpath这里，如果newpath是一个目录，那么就移动到目录下面，如果newpath不是目录，就重命名（可以执行统一的语义：移到 ./newpath ），最后删除oldpath</p><p>看了下<code>rename</code>，如果new存在的话会remove他，代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">rename_flags</span> = RenameFlags::<span class="hljs-title function_ invoke__">from_bits</span>(flags <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br> error!(<br>     <span class="hljs-string">&quot;old_path is &#123;&#125;,new_path is &#123;&#125;&quot;</span>,<br>     old_path.<span class="hljs-title function_ invoke__">path</span>(),<br>     new_path.<span class="hljs-title function_ invoke__">path</span>()<br> );<br><br> <span class="hljs-comment">//如果路径不存在，old-&gt;error,new-&gt;分情况讨论</span><br> <span class="hljs-keyword">if</span> !<span class="hljs-title function_ invoke__">path_exists</span>(old_path.<span class="hljs-title function_ invoke__">path</span>()) &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(SyscallError::EPERM);<br> &#125;<br><br> <span class="hljs-comment">//如果`oldpath`和`newpath`是引用同一文件的现有硬链接，则`rename()`不执行任何操作，并返回成功状态。</span><br> <span class="hljs-keyword">if</span> old_path.<span class="hljs-title function_ invoke__">path</span>() == new_path.<span class="hljs-title function_ invoke__">path</span>() &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-number">0</span>);<br> &#125;<br><br> <span class="hljs-comment">//如果`newpath`存在但由于某种原因操作失败，`rename()`保证保留`newpath`的一个实例。</span><br><br> <span class="hljs-comment">//一共四种情况 [file,dir] [file file] [dir file] [dir dir]</span><br> <span class="hljs-comment">//old_path必须存在，new_path有些情况可以不存在，因此old_data不存在直接err</span><br> <span class="hljs-keyword">let</span> <span class="hljs-variable">old_data</span> = <span class="hljs-title function_ invoke__">metadata</span>(old_path.<span class="hljs-title function_ invoke__">path</span>())?;<br> <span class="hljs-keyword">if</span> old_data.<span class="hljs-title function_ invoke__">is_dir</span>() &#123;<br>     <span class="hljs-comment">//`oldpath`可以指定一个目录。在这种情况下，`newpath`要么不存在，要么必须指定为(空)目录。</span><br>     <span class="hljs-keyword">if</span> !<span class="hljs-title function_ invoke__">path_exists</span>(new_path.<span class="hljs-title function_ invoke__">path</span>()) &#123;<br>         <span class="hljs-keyword">let</span> <span class="hljs-variable">_</span> = <span class="hljs-title function_ invoke__">rename</span>(old_path.<span class="hljs-title function_ invoke__">path</span>(), new_path.<span class="hljs-title function_ invoke__">path</span>());<br>     &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Ok</span>(new_data) = <span class="hljs-title function_ invoke__">metadata</span>(new_path.<span class="hljs-title function_ invoke__">path</span>()) &#123;<br>         <span class="hljs-comment">//todo,空目录如何表达？,考虑flag</span><br>         <span class="hljs-keyword">if</span> new_data.<span class="hljs-title function_ invoke__">is_dir</span>() &#123;<br>             <span class="hljs-keyword">let</span> <span class="hljs-variable">_</span> = <span class="hljs-title function_ invoke__">rename</span>(old_path.<span class="hljs-title function_ invoke__">path</span>(), new_path.<span class="hljs-title function_ invoke__">path</span>());<br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>             <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(SyscallError::EPERM);<br>         &#125;<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(SyscallError::EPERM);<br>     &#125;<br> &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> old_data.<span class="hljs-title function_ invoke__">is_file</span>() &#123;<br>     <span class="hljs-keyword">let</span> <span class="hljs-variable">_</span> = <span class="hljs-title function_ invoke__">rename</span>(old_path.<span class="hljs-title function_ invoke__">path</span>(), new_path.<span class="hljs-title function_ invoke__">path</span>());<br> &#125;<br><br> <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>flag还没有实现，有时间再补上</p><p>得到正确答案：</p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202311211725497.png" alt="image-20231121172459332"></p><h3 id="实验3-2"><a href="#实验3-2" class="headerlink" title="实验3.2"></a>实验3.2</h3><p>还是老样子首先和本机标准答案对照：</p><p><code>strace busybox mv bin def</code></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">...<br><span class="hljs-function"><span class="hljs-title">newfstatat</span><span class="hljs-params">(AT_FDCWD, <span class="hljs-string">&quot;bin&quot;</span>, &#123;st_mode=S_IFDIR|<span class="hljs-number">0755</span>, st_size=<span class="hljs-number">4096</span>, ...&#125;, <span class="hljs-number">0</span>)</span></span> = <span class="hljs-number">0</span><br><span class="hljs-function"><span class="hljs-title">newfstatat</span><span class="hljs-params">(AT_FDCWD, <span class="hljs-string">&quot;bin/def&quot;</span>, <span class="hljs-number">0</span>x7ffe00dec808, <span class="hljs-number">0</span>)</span></span> = -<span class="hljs-number">1</span> ENOENT (No such file or directory)<br><span class="hljs-function"><span class="hljs-title">rename</span><span class="hljs-params">(<span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;bin/def&quot;</span>)</span></span><br>...<br></code></pre></td></tr></table></figure><p>Starry内核：</p><p>为了方便调试在<code>renameat2</code>里面加了一句:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust">error!(<br>    <span class="hljs-string">&quot;old_path is &#123;&#125;,new_path is &#123;&#125;&quot;</span>,<br>    old_path.<span class="hljs-title function_ invoke__">path</span>(),<br>    new_path.<span class="hljs-title function_ invoke__">path</span>()<br>);<br></code></pre></td></tr></table></figure><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[syscall]</span> id = FSTATAT, args = <span class="hljs-comment">[18446744073709551516, 1073741383, 1073740160, 0, 1073741383, 18446744073709551516]</span>, entry<br><span class="hljs-keyword">Is</span> a directory<br><span class="hljs-comment">[syscall]</span> id = 79, args = <span class="hljs-comment">[18446744073709551516, 1073741383, 1073740160, 0, 1073741383,18446744073709551516]</span>, return 0<br><span class="hljs-comment">[syscall]</span> id = FACCESSAT, args = <span class="hljs-comment">[18446744073709551516, 1073741383, 2, 0, 16384, 1073741383]</span>, entry<br><span class="hljs-keyword">Is</span> a directory<br><span class="hljs-comment">[syscall]</span> id = 48, args = <span class="hljs-comment">[18446744073709551516, 1073741383, 2, 0, 16384, 1073741383]</span>, return 0<br><span class="hljs-comment">[syscall]</span> id = RENAMEAT2, args = <span class="hljs-comment">[18446744073709551516, 1073741387, 18446744073709551516, 1073741383, 0, 1073741387]</span>, entry<br>old_path <span class="hljs-keyword">is</span> /def,new_path <span class="hljs-keyword">is</span> /bin<br><span class="hljs-keyword">Is</span> a directory<br>dst file already exist, now remove it<br><span class="hljs-keyword">Is</span> a directory<br><span class="hljs-comment">[AxError::IsADirectory]</span><br><span class="hljs-comment">[syscall]</span> id = 276, args = <span class="hljs-comment">[18446744073709551516, 1073741387, 18446744073709551516, 1073741383, 0, 1073741387]</span>, return 0<br></code></pre></td></tr></table></figure><p>可以看到出问题了，应该是错把dir当成file的错误</p><p>与实验<code>3.1</code>的答案对照一下看看</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vim">[syscall] id = FSTATAT, <span class="hljs-keyword">args</span> = [<span class="hljs-number">18446744073709551516</span>, <span class="hljs-number">4128</span>, <span class="hljs-number">1073740160</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4128</span>, <span class="hljs-number">18446744073709551516</span>], entry<br>[syscall] id = <span class="hljs-number">79</span>, <span class="hljs-keyword">args</span> = [<span class="hljs-number">18446744073709551516</span>, <span class="hljs-number">4128</span>, <span class="hljs-number">1073740160</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4128</span>, <span class="hljs-number">18446744073709551516</span>], <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>[syscall] id = FACCESSAT, <span class="hljs-keyword">args</span> = [<span class="hljs-number">18446744073709551516</span>, <span class="hljs-number">4128</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">16384</span>, <span class="hljs-number">4128</span>], entry<br>[syscall] id = <span class="hljs-number">48</span>, <span class="hljs-keyword">args</span> = [<span class="hljs-number">18446744073709551516</span>, <span class="hljs-number">4128</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">16384</span>, <span class="hljs-number">4128</span>], <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>[syscall] id = RENAMEAT2, <span class="hljs-keyword">args</span> = [<span class="hljs-number">18446744073709551516</span>, <span class="hljs-number">1073741387</span>, <span class="hljs-number">18446744073709551516</span>, <span class="hljs-number">4128</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1073741387</span>], entry<br>old_path <span class="hljs-keyword">is</span> /<span class="hljs-keyword">abc</span>,new_path <span class="hljs-keyword">is</span> /bin/<span class="hljs-keyword">abc</span><br>dst <span class="hljs-keyword">file</span> already exist, now <span class="hljs-built_in">remove</span> it<br>[syscall] id = <span class="hljs-number">276</span>, <span class="hljs-keyword">args</span> = [<span class="hljs-number">18446744073709551516</span>, <span class="hljs-number">1073741387</span>, <span class="hljs-number">18446744073709551516</span>, <span class="hljs-number">4128</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1073741387</span>], <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>对比发现<code>deal_with_path</code>会预先处理好<code>new_path</code>，对于上一小节实验给出<code>old_path is /abc,new_path is /bin/abc</code>，而对于这节实验给出<code>old_path is /def,new_path is /bin</code></p><p>由于我error!的位置在处理的最前面，因此，就只有<code>deal_with_path</code>会出现这个问题，进入函数，开始修正</p><ul><li><p>首先做了一个小test，发现不可能存在同名的file和dir</p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202311211725553.png" alt="image-20231121172532515"></p></li><li><p>那么是怎么分辨一个没有以<code>/</code>是dir还是file呢，我的想法是首先获取<code>metadata</code>，利用里面的<code>is_dir</code>和<code>is_file</code>来判断，如果满足是目录而且没有以<code>/</code>结尾，手动给他添上</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Ok</span>(new_data) = <span class="hljs-title function_ invoke__">metadata</span>(path.<span class="hljs-title function_ invoke__">as_str</span>()) &#123;<br>    <span class="hljs-keyword">if</span> new_data.<span class="hljs-title function_ invoke__">is_dir</span>() &amp;&amp; !path.<span class="hljs-title function_ invoke__">ends_with</span>(<span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>        path = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;/&quot;</span>, path);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>可以正确输出</p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202311211739021.png" alt="image-20231121173905954"></p></li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>项目二是ArceOs宏内核，当时选项目二的原因是</p><ol><li>想参加大赛</li><li>从第二阶段的rCore tutorial学习之后，还有一些疑问，想借这个项目巩固一下，同时跨越从教程到自己写内核的鸿沟</li></ol><p>个人觉得收获很大的是调试技巧方面：</p><p>gdb：</p><p>gdb 不支持跨地址空间的查找。它只知道当前能不能访问某个地址（虚拟地址），不会管现在的页表在哪，所以内核调试时经常会遇到因为地址当前无法访问而打不上断点的情况。这时可分为以下情况处理：</p><ol><li><p>把断点打在内核入口，也即 <code>0x80200000</code> 处，然后使用 <code>c</code> 命令跳过去。之后就可以打大部分内核符号的断点了。</p></li><li><p>把断点打在 <code>mm::init()</code> （页表初始化函数）然后使用 <code>c</code> 命令跳过去，再用 <code>n</code> 指令跳过这段流程，就可以打页表中有映射的地址的断点了，例如跳板页 <code>TRAMPOLINE</code>。</p></li><li><p>一般来说，如果想打用户程序的断点，先使用 <code>c</code> 命令，等待程序运行到 <code>user_shell</code> 等待输出的时候，再 <code>ctrl+C</code>，就可以打用户地址空间的断点了。但缺点是此时无法打内核的断点</p></li></ol><p>总的说来，训练营收获很大，从一开始的只是了解了OS的皮毛，或者说书本上的OS知识，再经过第一阶段，从零开始学习了rust的基础，第二阶段亲自上手体验五个实验，细致地体会OS各种核心的概念，中断、虚拟内存、进程切换、多线程、信号等等，然后第三阶段通过AecOS宏内核的学习，了解到OS大赛所需要的部分知识，我的认知确实有短暂地螺旋上升，很谢谢有这样一个平台能学习OS，感谢。</p>]]></content>
    
    
    
    <tags>
      
      <tag>rust os</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数论</title>
    <link href="/2023/04/03/%E6%95%B0%E8%AE%BA/"/>
    <url>/2023/04/03/%E6%95%B0%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>欧几里得算法 筛法求素数（埃氏筛、欧拉筛） 裴蜀定理板子</p><span id="more"></span><h1 id="欧几里得-辗转相除法"><a href="#欧几里得-辗转相除法" class="headerlink" title="欧几里得(辗转相除法)"></a>欧几里得(辗转相除法)</h1><p>求a，b的最大公因数</p><p>gcd(a,b) = gcd(b,a%b) = ….. 直到(a,b)中b为0，那么结果就为a</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> b?<span class="hljs-built_in">gcd</span>(a,b):a ;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="筛法求素数"><a href="#筛法求素数" class="headerlink" title="筛法求素数"></a>筛法求素数</h1><h2 id="埃氏筛"><a href="#埃氏筛" class="headerlink" title="埃氏筛"></a>埃氏筛</h2><p>从2开始的 x ，划掉每个x的倍数，优化一下可以从x^2^开始划</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> primes[N],cnt;<br><span class="hljs-type">bool</span> st[N];<span class="hljs-comment">//初始为false，true表示被筛掉了，最后为false的都是质数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>; i&lt;=n ;i++)&#123;<br>    <span class="hljs-keyword">if</span>(!st[i])&#123;<br>        primes[cnt++] = i;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i*i; j&lt;=n; j++) st[i]=<span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h2><ul><li>每个合数只被划掉一次，而且是被它的最小质因子划掉的 (原理是：每个合数都有一个&lt;= sqrt(x) 的质因子 )<ul><li>由于被它的最小质因子划掉的，因此还可以求每个数的最小质因子</li></ul></li><li>筛的过程，为了避免重复筛<ul><li>对于每个数x，乘上 &lt;= x的最小质因子的质数，就可以保证不重复筛</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> primes[N],cnt;<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>; i&lt;=n; i++)&#123;<br>        <span class="hljs-keyword">if</span>(!st[i]) primes[cnt++] = i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; primes[j]*i&lt;=n;j++ )&#123;<span class="hljs-comment">//此时primes[]数组里面的都是 &lt;= i的</span><br>            <span class="hljs-type">int</span> t = primes[j]*i ;<br>            st[t] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//筛掉</span><br>            <span class="hljs-keyword">if</span>(i % primes[j] == <span class="hljs-number">0</span> ) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//primes[j]就是最小质因子，因为前面两行代码已经实现了乘primes[j],直接退出</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="裴蜀定理-扩展欧几里得算法"><a href="#裴蜀定理-扩展欧几里得算法" class="headerlink" title="裴蜀定理(扩展欧几里得算法)"></a>裴蜀定理(扩展欧几里得算法)</h1><p>(a,b) = d   </p><p>裴蜀定理可以求出一组x，y 使得 d = ax<del>0</del> + by<del>0</del></p><p>并且只要求出满足的一组解x，y，就可以求出所有解</p><p>a’ = a/d  b’ = b/d</p><p>x = x<del>0</del> + k<em>b’    y = y<del>0</del> - k</em>a’</p><p><strong>运用</strong></p><p>(a,b) = (b,a%b) =… = d</p><p>因此 b*y + (a % b) * x = d</p><p>即    b<em>y + (a - a/b * b ) * x = a</em>x + (y-a/b * x ) * b = d</p><p>=&gt;   x’ = x    y’ = y - a/b*x  (b = 0 时停止)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//exgcd可以找出满足的 d = ax + by 中的x，y并且返回d</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!b)&#123;<br>        x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-type">int</span> d = <span class="hljs-built_in">exgcd</span>(b, a%b, y, x);<br>    y -= a / b * x;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>欧几里得算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树状数组</title>
    <link href="/2023/03/23/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    <url>/2023/03/23/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p>树状数组和线段树的实现</p><span id="more"></span><p>如何推导？查看本人的知乎这篇文章：<a href="https://zhuanlan.zhihu.com/p/585460026">前缀和改进之树状数组 - 知乎 (zhihu.com)</a></p><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul><li><p>单点修改，区间求和  O(logN)</p></li><li><p>可以在，O(logN)的时间内，动态求前缀和 ( 对比前缀和，修改的话需要O(N) )</p></li></ul><p>注意：树状数组下标一定要<strong>从1开始</strong></p><h4 id="树状数组初始化"><a href="#树状数组初始化" class="headerlink" title="树状数组初始化"></a>树状数组初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span> ; i&lt;=n ; i++) <span class="hljs-built_in">add</span>(i,a[i]);<br></code></pre></td></tr></table></figure><p>小小地解释一下原理：</p><ul><li><p>树状数组中奇数下标和原数组相等</p></li><li><p><code>c[x] = 原数组中下标从(x-lowbit(x)，x]的和</code> 左开右闭</p></li></ul><h4 id="三个基本操作："><a href="#三个基本操作：" class="headerlink" title="三个基本操作："></a>三个基本操作：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[N],c[N];<span class="hljs-comment">//a[N]为原数组，c[N]为树状数组</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; -x;<br>&#125;<br><br><span class="hljs-comment">//一般情况下只支持add，如果要实现修改某一个数，可以add他们的差值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x , <span class="hljs-type">int</span> v )</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i&lt;=n;i+=<span class="hljs-built_in">lowbit</span>(i)) c[i] += v;    <br>&#125;<br><br><span class="hljs-comment">//查询</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x ; i&gt;=<span class="hljs-number">1</span> ; i-=<span class="hljs-built_in">lowbit</span>(i) )  res += c[i];<span class="hljs-comment">//for循环截止条件写成 i!=0 即 i也可以</span><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><p>每个结点都是一个结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> L,R;<br>    <span class="hljs-type">int</span> sum;<br>&#125;tr[N*<span class="hljs-number">4</span>];<br></code></pre></td></tr></table></figure><p>线段树存储</p><p>注意结点个数要开 <code>4n</code> 其中n是有多少个数</p><p>类似于堆的存储方式，存在一维数组，对于一个序号为x的节点</p><ul><li>父节点为 x/2 (下取整) <code>x&gt;&gt;1</code></li><li>左子节点为 x*2  <code>x&lt;&lt;1</code></li><li>右子节点为 x*2+1  <code>x&lt;&lt; 1 | 1</code></li></ul><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><ul><li><p>单点修改 O(logN)</p></li><li><p>区间查询 O(logN)</p></li></ul><p>四个函数</p><p>pushup 用子节点信息更新当前节点信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    tr[u].sum = tr[u&lt;&lt;<span class="hljs-number">1</span>].sum + tr[u&lt;&lt;<span class="hljs-number">1</span> | <span class="hljs-number">1</span>].sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>build  在一段区间上初始化线段树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l == r) tr[u] = &#123;l,r,w[r]&#125;;<br>    <span class="hljs-keyword">else</span>&#123;<br>        tr[u] = &#123;l,r&#125;;<br>        <span class="hljs-type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">build</span>(u&lt;&lt;<span class="hljs-number">1</span>,l,mid), <span class="hljs-built_in">build</span>(u&lt;&lt;<span class="hljs-number">1</span> | <span class="hljs-number">1</span> , mid+<span class="hljs-number">1</span> ,r);<br>        <span class="hljs-built_in">pushup</span>(u);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>modify  修改某个点的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> v)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(tr[u].l == tr[u].r ) tr[u].sum += v;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(x &lt;= mid) <span class="hljs-built_in">modify</span>(u&lt;&lt;<span class="hljs-number">1</span>, x , v);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span> , x , v);<br>        <span class="hljs-built_in">pushup</span>(u);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>query   查询</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(tr[u].l&gt;=l &amp;&amp; tr[u].r&lt;=r) <span class="hljs-keyword">return</span> tr[u].sum;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(l &lt;= mid) sum += <span class="hljs-built_in">query</span>(u&lt;&lt;<span class="hljs-number">1</span> , l ,mid);<br>        <span class="hljs-keyword">if</span>(r &gt; mid)  sum += <span class="hljs-built_in">query</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,l,r);<br>        <span class="hljs-keyword">return</span> sum<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>dp</title>
    <link href="/2023/03/17/dp/"/>
    <url>/2023/03/17/dp/</url>
    
    <content type="html"><![CDATA[<p>介绍简单dp： 01 背包一维二维实现</p><span id="more"></span><h1 id="DP-动态规划-背包"><a href="#DP-动态规划-背包" class="headerlink" title="DP(动态规划)-背包"></a>DP(动态规划)-背包</h1><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><ul><li><p>题目</p><p>有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。第 i 件物品的体积是 v<del>i</del>，价值是 w<del>i</del>。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。</p></li><li><p>为什么称作01背包，因为对于每个物品，只对应选或者不选两种状态，因此称为01背包</p></li></ul><p><strong>主要思想：</strong></p><ul><li>状态表示: 我们用<code>f[i][j]</code>来表示，前<code>i</code>个物品，最大容量是<code>j</code>，可以得到的最大价值</li><li>状态计算:<ul><li>对于<code>f[i][j]</code>，第 i 个物品，我们有两种选择<ul><li>不选他: <code>f[i][j]=f[i-1][j]</code>，将第 i 个物品剔除然后选最大</li><li>选他: <code>f[i][j]=f[i-1][j-v[i]]+w[i]</code>，先将第 i 个物品放入背包，然后在前 i-1 个物品，容量为 j -v[i]的状态下找最大</li></ul></li><li>因此得出状态方程: <code> f[i][j] = max(f[i-1][j],f[i-1][j-v[i]]+w[i])</code></li></ul></li></ul><img src="https://img-blog.csdnimg.cn/119dcd0622ed424783892acdc976a3f5.png" alt="img" style="zoom: 50%;" /><h3 id="二维朴素版"><a href="#二维朴素版" class="headerlink" title="二维朴素版"></a>二维朴素版</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> v[N],w[N];<br><span class="hljs-type">int</span> f[N][N];<br><span class="hljs-comment">//对于f[i][j]，当i或者j为0时，f[i][j] = 0</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i++) cin&gt;&gt;v[i]&gt;&gt;w[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n; i++ )&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt;= m ;j++)&#123;<br>            <span class="hljs-comment">// 当前背包容量装不进第i个物品，则价值等于前i-1个物品</span><br>            <span class="hljs-keyword">if</span>(j &lt; v[i]) f[i][j] = f[i<span class="hljs-number">-1</span>][j];<br>            <span class="hljs-comment">// 可以装第i个物品，决策是否选他，用max来比较</span><br>            <span class="hljs-keyword">else</span> f[i][j] = <span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j],f[i<span class="hljs-number">-1</span>][j-v[i]]+w[i]);<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;f[n][m]&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="一维终极版"><a href="#一维终极版" class="headerlink" title="一维终极版"></a>一维终极版</h3><p>可以看做我们将 i-1 层的拷贝下来</p><p>01背包从大到小</p><p>完全背包从小到大</p>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从BST到高维数据search</title>
    <link href="/2022/02/02/%E4%BB%8EBST%E5%88%B0%E9%AB%98%E7%BB%B4%E6%95%B0%E6%8D%AEsearch/"/>
    <url>/2022/02/02/%E4%BB%8EBST%E5%88%B0%E9%AB%98%E7%BB%B4%E6%95%B0%E6%8D%AEsearch/</url>
    
    <content type="html"><![CDATA[<p>quadTree，kdTree</p><span id="more"></span><h1 id="Lecture-19-Multi-Dimensional-Data"><a href="#Lecture-19-Multi-Dimensional-Data" class="headerlink" title="Lecture 19: Multi-Dimensional Data"></a>Lecture 19: Multi-Dimensional Data</h1><h2 id="Range-Finding-and-Nearest-1D-Data"><a href="#Range-Finding-and-Nearest-1D-Data" class="headerlink" title="Range-Finding and Nearest (1D Data)"></a>Range-Finding and Nearest (1D Data)</h2><p>BST中可添加的operation：</p><ul><li>select(int i): Returns the ith smallest item in the set.</li><li>rank(T x): Returns the “rank” of x in the set (opposite of select).</li><li>subSet(T from, T to): Returns all items between from and to.</li><li>nearest(T x): Returns the value closest to x.<ul><li>实现：Just search for N and record closest item seen</li></ul></li></ul><p>直到现在，我们总是在一维数据中比较，但是不是所有的item都能只在一个维度中完成比较的</p><h2 id="Multi-dimensional-Data"><a href="#Multi-dimensional-Data" class="headerlink" title="Multi-dimensional Data"></a><strong>Multi-dimensional Data</strong></h2><p>我们想在二维空间中实现</p><ul><li>2D Range Searching: How many objects are in the highlighted rectangle(矩形)?  注意这个操作其实就是上面一维数据中的subset的推广</li><li>Nearest</li></ul><p>Ideally, we’d like to store our data in a format (like a BST) that allows more efficient approaches than just iterating over all objects.</p><p><strong>BST of 2D</strong></p><p>我们需要做出选择，是以x坐标比较(X-Based Tree)，还是以y坐标(Y-Based Tree)比较来建立我们的BST，无论哪一种，我们都会丢失掉一些信息，这会让我们的search变慢</p><h3 id="QuadTrees"><a href="#QuadTrees" class="headerlink" title="QuadTrees"></a><strong>QuadTrees</strong></h3><p>类似x，y坐标系，我们将2D空间分出四部分，NW(西北)，NE(东北)，SW(西南)，SE(东南)</p><p>Every Node has four children:</p><ul><li>Top left, a.k.a. northwest.</li><li>Top right, a.k.a. northeast.</li><li>Bottom left, a.k.a. southwest.</li><li>Bottom right, a.k.a. southeast. </li></ul><p>注意，在插入生成QuadTrees时，我们也需要沿着root出发，再依次顺着树枝往下走，直到找到合适的地方插入</p><p><a href="https://docs.google.com/presentation/d/1vqAJkvUxSh-Eq4iIJZevjpY29nagNTjx-4N3HpDi0UQ/pub?start=false&loop=false&delayms=3000">QuadTrees Insertion Demo</a></p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081113875.png" alt="image-20230218204014098" style="zoom:67%;" /><p><a href="https://docs.google.com/presentation/d/1ZVvh_Q15Lh2D1_NnzZ4PR_aDsLBwvAU9JYQAwlSuXSM/edit?usp=sharing">Range Search Demo</a></p><p>以上是2D情况，对于3D，我们可以用8叉树来表示空间并进行高效地search，以此类推，来表示更高维度(大于3 dimensions的数据真的存在吗，有什么用？You may want to organize data on a large number of dimensions.Example: Want to find songs with the following features:Length between 3 minutes and 6 minutes.Between 1000 and 20,000 listens.Between 120 to 150 BPM.Were recorded after 2004.)</p><p>我们可以简单地增加子结点的个数，但这会显得臃肿，因此我们引出一种简洁但是对任何维度都适用的——k-d Tree</p><h3 id="k-d-Tree"><a href="#k-d-Tree" class="headerlink" title="k-d Tree"></a>k-d Tree</h3><p>有点类似于我们最早提出BST的X-Based Tree and Y-Based Tree，但是有所改进，对于2D，我们对于每一层比较的标准是按照顺序x-y-x-y…，3D(x-y-z-x-y-z…)</p><p>k-d tree example for 2-d:</p><ul><li>Basic idea, root node partitions entire space into left and right (by x).</li><li>All depth 1 nodes partition subspace into up and down (by y).</li><li>All depth 2 nodes partition subspace into left and right (by x).</li></ul><p><a href="https://docs.google.com/presentation/d/1WW56RnFa3g6UJEquuIBymMcu9k2nqLrOE1ZlnTYFebg/edit?usp=sharing">K-d tree insertion demo</a>.</p><p>k-d Tree对待比较中的平局，可以看做大于 or 小于，选定了就不能再改变了。</p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081109939.png" alt="image-20230218205046614" style="zoom:67%;" /><p>k-d nearest (始终是沿着建立好的k-d Tree来搜索)</p><ul><li>You always explore the good side [the old version performed an unnecessary check!</li><li>You only explore the bad side if there’s a chance that it could contain something better.</li></ul><p>k-d nearest，先看好的一方，在判断坏的一方是否值得一看</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">nearest(Node n, Point goal, Node <span class="hljs-keyword">best):</span><br><span class="hljs-keyword"></span>If n is null, return <span class="hljs-keyword">best</span><br><span class="hljs-keyword"></span>If n.<span class="hljs-keyword">distance(goal) </span>&lt; <span class="hljs-keyword">best.distance(goal), </span><span class="hljs-keyword">best </span>= n<br>If goal &lt; n (according to n’s comparator):<br>goodSide = n.”left”Child<br><span class="hljs-keyword">badSide </span>= n.”right”Child<br><span class="hljs-symbol">else:</span><br>goodSide = n.”right”Child<br><span class="hljs-keyword">badSide </span>= n.”left”Child<br><span class="hljs-keyword">best </span>= nearest(goodSide, goal, <span class="hljs-keyword">best)</span><br><span class="hljs-keyword"></span>If <span class="hljs-keyword">bad </span>side could still have something useful<br><span class="hljs-keyword">best </span>= nearest(<span class="hljs-keyword">badSide, </span>goal, <span class="hljs-keyword">best)</span><br><span class="hljs-keyword"></span>return <span class="hljs-keyword">best</span><br></code></pre></td></tr></table></figure><h3 id="Uniform-partitioning"><a href="#Uniform-partitioning" class="headerlink" title="Uniform partitioning"></a>Uniform partitioning</h3><p>把空间均分为几部分(类似hashtable中的bucket)，然后将数据存储在bucket中</p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081114279.png" alt="image-20230218210734514" style="zoom:67%;" />]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>排序算法专题</title>
    <link href="/2022/01/22/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/"/>
    <url>/2022/01/22/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>CS61B排序：选择排序，堆排序，归并排序，插入排序，希尔排序，快排</p><span id="more"></span><h1 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h1><p><strong>inversion</strong>(逆序对)</p><ul><li>An <strong>inversion</strong> is a pair of elements that are out of order with respect to &lt;. </li></ul><p>一种看待sort的方法：</p><ul><li>Given a sequence of elements with Z inversions.</li><li>Perform a sequence of operations that reduces inversions to 0.</li></ul><p>Sort中，我们关注两种复杂度</p><ul><li>time complexity</li><li>space complexity (<strong>extra</strong> memory usage)</li></ul><h2 id="Selection-Sort"><a href="#Selection-Sort" class="headerlink" title="Selection Sort"></a>Selection Sort</h2><p>θ(N^2^)</p><ul><li>Find smallest item.</li><li>Swap this item to the front and ‘fix’ it.</li><li>Repeat for unfixed items until all items are fixed.</li></ul><h2 id="Heap-Sort"><a href="#Heap-Sort" class="headerlink" title="Heap Sort"></a>Heap Sort</h2><blockquote><p>基于Selection Sort，但是加速了找smallest item这个过程</p></blockquote><p>必须用max-heap，why？</p><ul><li>min-heap也可以work，但是我们如果想直接在该数组中建立堆(without extra output array)来节省space complexity，min-heap不能做到这点</li></ul><p><strong>naive(朴素版)heap sort</strong></p><ul><li>Insert all items into a max heap, and discard input array. Create output array.</li><li>Repeat N times:<ul><li>Delete largest item from the max heap.</li><li>Put largest item at the end of the unused part of the output array.</li></ul></li></ul><p>runtime</p><ul><li>time complexity：θ(NlogN)</li><li>space complexity：θ(N) 因为开辟了额外的输出数组，长度为N<ul><li>这比选择排序worse，但是我们下面的策略可以改进</li></ul></li></ul><p><strong>In-place Heapsort</strong></p><blockquote><p>no extra array，直接在原数组中建立堆(heapify)，之后和朴素版的heapsort就一致了</p><p>为什么可以这样？因为按照层序从后往前的过程中，我们sink之后就保证以该位置为root的一个子堆满足heap的性质，因此我们从小到大地建立了完整有效地堆</p></blockquote><ul><li>Bottom-up heapify input array.<ul><li>To bottom-up heapify, just <strong>sink nodes in reverse level order.</strong></li><li>After sink(k), guaranteed that tree rooted at position k is a heap.</li></ul></li><li>Repeat N times:<ul><li>Delete largest item from the max heap, swapping root with last item in the heap.</li></ul></li></ul><p><a href="https://docs.google.com/presentation/d/1SzcQC48OB9agStD0dFRgccU-tyjD6m3esrSC-GLxmNc/edit?usp=sharing">in-place heap sort Demo</a></p><p>runtime</p><ul><li>time complexity：θ(NlogN)</li><li>space complexity：θ(1)</li></ul><h2 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort"></a>Merge Sort</h2><blockquote><p>chapt 8里面讲过，依次挨个地合并两个有序的数组</p></blockquote><p>看这个Demo就理解了 <a href="https://docs.google.com/presentation/d/1h-gS13kKWSKd_5gt2FPXLYigFY4jf5rBkNFl3qZzRRw/edit?usp=sharing">Merge Sort Demo</a></p><ul><li>Split items into 2 roughly even pieces.</li><li>Mergesort each half (steps not shown, this is a recursive algorithm!)</li><li>Merge the two sorted halves to form the final result.<ul><li><strong>Compare input[i] &lt; input[j] (if necessary).</strong></li><li>Copy smaller item and increment p and i or j.</li></ul></li></ul><h2 id="insertion-sort"><a href="#insertion-sort" class="headerlink" title="insertion sort"></a>insertion sort</h2><p><strong>naive</strong></p><ul><li>Starting with an empty output sequence.</li><li>Add each item from input, inserting into output at right point.</li></ul><p><strong>in-place</strong></p><ul><li>在该数组内用swap，而不是再开一个数组</li><li>Repeat for i = 0 to N - 1:<ul><li>Designate item i as the traveling item.</li><li>Swap item backwards until traveller is in the right place among all previously examined items.</li></ul></li></ul><p><strong>note：</strong></p><p>对于差不多有序的序列来说很快</p><p>runtime与inversion(逆序对)的个数成正比</p><p>一些经验表示，对于&lt;15个元素的序列，insertion sort是所有排序中最快(粗略的解释：Divide and conquer algorithms like heapsort / mergesort spend too much time dividing, but insertion sort goes straight to the conquest.)</p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081114681.png" alt="image-20230219213456835" style="zoom:67%;" /><h2 id="Shell-Sort"><a href="#Shell-Sort" class="headerlink" title="Shell Sort"></a>Shell Sort</h2><blockquote><p>利用insertion对元素少的序列很快这一特点</p></blockquote><ul><li>将序列中，每间隔d的index分为一组，对该组进行insertion sort</li><li>不断<code>d--</code>，直到d=1，整个序列恰恰都在一组，完成排序</li></ul><h2 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h2><blockquote><p>一个好的quick sort：需要有</p><ul><li>pick good pivot</li><li>good partition strategy</li></ul></blockquote><p>Quicksorting N items: (<a href="https://docs.google.com/presentation/d/1QjAs-zx1i0_XWlLqsKtexb-iueao9jNLkN-gW9QxAD0/edit?usp=sharing">Demo</a>)</p><h3 id="The-Core-Idea-of-Tony’s-Sort-Partitioning"><a href="#The-Core-Idea-of-Tony’s-Sort-Partitioning" class="headerlink" title="The Core Idea of Tony’s Sort: Partitioning"></a><strong>The Core Idea of Tony’s Sort: Partitioning</strong></h3><p>To partition an array a[] on element x=a[i] is to rearrange a[] so that: (partition作用的那个i，就叫做pivot)</p><ul><li>x moves to position j (may be the same as i)</li><li>All entries to the left of x are &lt;= x.</li><li>All entries to the right of x are &gt;= x.</li></ul><p>实现：</p><ul><li>可以用BST，把pivot当做root，比他小的都在left，比他大的都在right</li><li>simple but not fastest: 3 scan<ul><li>Create another array. Scan and copy all the red items to the first R spaces. Then scan for and copy the white item. Then scan and copy the blue items to the last B spaces.</li></ul></li></ul><p>observations:</p><ul><li>当我们partition(k=a[i])之后，k就在它的最终位置上不动了了(左边的都比他小，右边的都比他大)</li><li>Can sort two halves separately, e.g. through recursive use of partitioning.左右两边完全独立了</li></ul><p><strong>步骤：</strong></p><ul><li>Pick the pivot to be partitioned:  e.g.Partition on leftmost item. </li><li>Quicksort left half.</li><li>Quicksort right half.</li></ul><h3 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h3><ul><li>值得一提的是，quick sort的速度与选取的pivot最终落在的位置有很大关系</li></ul><p><strong>Best Case: Pivot Always Lands in the Middle</strong> </p><p>递归深度logN</p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081128345.png" alt="image-20230220200918361" style="zoom: 50%;" /><p><strong>Worst Case: Pivot Always Lands at Beginning of Array</strong></p><p>递归深度N</p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081128289.png" alt="image-20230220201459150" style="zoom: 50%;" /><p>一个有趣的观察：</p><ul><li>Quick Sort的过程其实就是BST建立的过程，我们可以看到每次选取的pivot都是子树的一个根，向下建立BST，so crazy！</li><li>回想Random insertion into a BST takes O(N log N) time.</li></ul><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081128194.png" alt="image-20230220202301322" style="zoom: 50%;" /><p>问题来了，N^2^与NlogN的差别可谓巨大，所以我们该怎么避免worst case的出现？</p><h3 id="Avoiding-the-Quicksort-Worst-Case"><a href="#Avoiding-the-Quicksort-Worst-Case" class="headerlink" title="Avoiding the Quicksort Worst Case"></a><strong>Avoiding the Quicksort Worst Case</strong></h3><p>小心两种特殊的序列，他们可能会使你的策略陷入N^2^</p><ul><li>Bad ordering: Array already in sorted order.</li><li>Bad elements: Array with all duplicates.</li></ul><p>we mainly focus on</p><ul><li>How you select your pivot.</li><li>How you partition around that pivot.</li></ul><p><strong>Philosophy 1: Randomness</strong> </p><blockquote><p>随机性是一个好的Quick Sort所<strong>必需</strong>的，对于一些确定的or伪随机的，总会存在潜在的危险. See McIlroy’s “<a href="http://www.cs.dartmouth.edu/~doug/mdmspe.pdf">A Killer Adversary for Quicksort</a>”</p></blockquote><ul><li>Strategy #1: Pick pivots randomly.</li><li>Strategy #2: Shuffle(搅乱) before you sort.</li></ul><p><strong>Philosophy 2b: Smarter Pivot Selection</strong> </p><blockquote><p>Use the median (or an approximation) as our pivot.也就是选取的pivot正好落在中间</p></blockquote><p>利用partition来寻找中值pivot</p><ul><li>一直partition，让partition(k)之后k的位置往中间靠，直到k落在length/2的位置</li></ul><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081114666.png" alt="image-20230220210311996" style="zoom: 50%;" /><p>worst case：θ(N^2^)    i.e.[1 2 3 4 5 6 7 8 9 10 … N]</p><p>average case：θ(N)</p><p><strong>Hoare Partitioning</strong>(双指针法)</p><p><a href="https://docs.google.com/presentation/d/1DOnWS59PJOa-LaBfttPRseIpwLGefZkn450TMSSUiQY/pub?start=false&loop=false&delayms=3000">Demo</a></p><p>Create L and G pointers at left and right ends.</p><ul><li><p>L pointer is a friend to small items,and hates large or equal items.(注意对于equal的我们不管，不然对于全重复元素的序列我们会陷入worst case)</p></li><li><p>G pointer is a friend to large items,and hates small or equal items.</p></li><li><p>Walk pointers towards each other,stopping on a hated item.</p><ul><li><p>When both pointers have stopped,swap and move pointers by one.</p></li><li><p>When pointers cross,you are done walking.</p></li></ul></li><li><p>Swap pivot  with G.</p></li></ul><p><strong>Sorting Properties</strong></p><p>stability</p><ul><li>Equivalent items don’t ‘cross over’ when being stably sorted.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BST与平衡树</title>
    <link href="/2022/01/17/BST%E4%B8%8E%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    <url>/2022/01/17/BST%E4%B8%8E%E5%B9%B3%E8%A1%A1%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>CS61B的BST，B树，23树，红黑树，LLRB 原理</p><span id="more"></span><h2 id="Chapt10-ADTs-Sets-Maps-BSTs"><a href="#Chapt10-ADTs-Sets-Maps-BSTs" class="headerlink" title="Chapt10 ADTs, Sets, Maps, BSTs"></a>Chapt10 ADTs, Sets, Maps, BSTs</h2><p>加快链表的查找也可以使用跳表来优化  θ(logN)</p><h3 id="BST-Binary-Search-Tree"><a href="#BST-Binary-Search-Tree" class="headerlink" title="BST(Binary Search Tree)"></a>BST(Binary Search Tree)</h3><p>一篇好文<a href="https://medium.com/@liuamyj/its-triangles-all-the-way-down-part-1-17f932f4c438">It’s Triangles All the Way Down (Part 1) | by Amy Liu | Medium</a></p><p>二分查找树</p><p><strong>提出BST的原因</strong></p><ul><li>对于LinkedList来说，我们search时最坏情况需要遍历整个list，尽管list是有序的，对于ordered array来说，我们可以通过二分查找来加快查找速度</li><li>受array的启发，我们可以在LinkedList的middle node设置一个引用，然后将middle node左边的List的指向翻转，这样我们就可以从middle位置根据大小向两边查找了</li><li>我们可以做得更好，在左右部分，递归地，我们继续添加他们各自middle node的使用，直到每个部分只剩1个，这就会形成BST</li></ul><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081111897.png" alt="image-20230128191549116" style="zoom: 50%;" /><ul><li><strong>Binary Search Trees</strong>:<ul><li>Every key in the left subtree is less than X’s key.</li><li>Every key in the right subtree is greater than X’s <strong>key.</strong></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BST</span>&lt;Key&gt; &#123;<br>    <span class="hljs-keyword">private</span> Key key;<br>    <span class="hljs-keyword">private</span> BST left;<br>    <span class="hljs-keyword">private</span> BST right;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BST</span><span class="hljs-params">(Key key, BST left, BST Right)</span> &#123;<br>        <span class="hljs-built_in">this</span>.key = key;<br>        <span class="hljs-built_in">this</span>.left = left;<br>        <span class="hljs-built_in">this</span>.right = right;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BST</span><span class="hljs-params">(Key key)</span> &#123;<br>        <span class="hljs-built_in">this</span>.key = key;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BST-operations"><a href="#BST-operations" class="headerlink" title="BST operations"></a><strong>BST operations</strong></h3><ul><li><p><code>static BST find(BST T, Key key)</code></p><ul><li><p>T是BST的root，return 与key匹配的node</p></li><li><p>```java<br>static BST find(BST T, Key sk){</p><pre><code class="hljs">if(T==null)&#123;    return null;&#125;if(sk.equals(T.key))&#123;    return T;&#125;else if(sk&lt;T.key)&#123;    find(T.left,sk);&#125;else if(sk&gt;T.key)&#123;    find(T.right,sk);&#125;</code></pre><p>}</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><br>* `<span class="language-javascript"><span class="hljs-keyword">static</span> <span class="hljs-variable constant_">BST</span> <span class="hljs-title function_">insert</span>(<span class="hljs-variable constant_">BST</span> T, <span class="hljs-title class_">Key</span> ik)</span>`<br><br>  * 我们总是在叶子结点进行insert！<br><br>  * <span class="hljs-keyword">return</span> the full BST <span class="hljs-keyword">with</span> the <span class="hljs-keyword">new</span> node inserted <span class="hljs-keyword">in</span> the correct position.<br><br>  * BST 不能有重复的<br><br>  * If found, <span class="hljs-keyword">do</span> nothing.<br><br>  * If <span class="hljs-keyword">not</span> found:<br><br>    * Create <span class="hljs-keyword">new</span> node.<br>    * <span class="hljs-built_in">Set</span> appropriate link<br><br>  * ```<span class="language-javascript">java</span><br><span class="language-javascript">    <span class="hljs-keyword">static</span> <span class="hljs-variable constant_">BST</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">BST T, Key ik</span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">null</span>)&#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">BST</span>(ik);</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        <span class="hljs-keyword">if</span>(ik&lt;T.<span class="hljs-property">key</span>)&#123;</span><br><span class="language-javascript">            T.<span class="hljs-property">left</span>=<span class="hljs-title function_">insert</span>(T.<span class="hljs-property">left</span>,ik);</span><br><span class="language-javascript">        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ik&gt;T.<span class="hljs-property">key</span>)&#123;</span><br><span class="language-javascript">            T.<span class="hljs-property">right</span>=<span class="hljs-title function_">insert</span>(T.<span class="hljs-property">right</span>,ik);</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> T;</span><br><span class="language-javascript">    &#125;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>static BST delete(BST T,key dk)</code></p><ul><li><p><strong>Hibbard deletion</strong></p></li><li><p>has <strong>no children</strong></p><ul><li>删除的肯定是叶子结点，只需要改变该叶子结点的父亲，</li></ul></li><li><p>has <strong>1 child</strong></p><ul><li>把该结点父亲结点的pointer指向该结点的子结点 we can just reassign the parent’s child pointer to the node’s child and the node will eventually be garbage collected</li></ul></li><li><p>has <strong>2 children</strong></p><ul><li><p>目标是找到一个满足左边的都比他小，右边都比他大的node来代替需要删除的node</p></li><li><p>删除有两个子结点的：对该子树，选择该子树中，左边最右(predecessor)，或者右边最左(sucessor)的来代替root</p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081111870.png" alt="image-20230128232228097" style="zoom:50%;" /></li></ul></li></ul></li></ul><p>θ(logN)：This was because we could eliminate half of the elements at every step of our search</p><h2 id="Chapt11：Balanced-Trees"><a href="#Chapt11：Balanced-Trees" class="headerlink" title="Chapt11：Balanced Trees"></a>Chapt11：Balanced Trees</h2><ul><li>The <strong>depth</strong> of a node：距离根结点有多远</li><li>The <strong>“height” of a tree</strong> is the depth of its deepest leaf, e.g. height(T) = 4.  <strong>worst case</strong></li><li>The <strong>“average depth”</strong> of a tree is the average depth of a tree’s nodes.  <strong>average case</strong><ul><li>(<strong>0</strong>x1 + <strong>1</strong>x2 + <strong>2</strong>x4 + <strong>3</strong>x6 + <strong>4</strong>x1)/(1+2+4+6+1) = 2.35</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081112370.png" alt="image-20230128232650535" style="zoom:67%;" /><p>BSTs have:</p><ul><li>Worst case Θ(N) height.</li><li>Best case Θ(log N) height.</li></ul><p>对于BST来说，不同的插入顺序会形成不同height的tree，也会造成不同的查找速度</p><p><strong>Randomlized Trees</strong></p><p>现实中插入往往是随机的，已经证明，随机插入的tree</p><ul><li>average depth：~ 2 ln N = Θ(log N)</li><li>height：~ 4.311 ln N= Θ(log N)</li><li>note：~ 和 Θ是一样的，但没有丢掉常数</li></ul><p>因此，随机插入时BST的表现不错，但是现实中我们不能做到处处随机，因此我们引出B-Trees来解决这个问题(在任意插入顺序下都有很好的height)</p><h3 id="B-tree"><a href="#B-tree" class="headerlink" title="B tree"></a><strong>B tree</strong></h3><blockquote><p>BST的问题是：我们一直在叶结点之后插入，这会导致height增加；那么，我们是否可以一直不往叶结点插入，来保证tree balance</p></blockquote><p>可以处理任何输入顺序，让树饱满，平衡</p><h4 id="Avoiding-Imbalance-through-Overstuffing"><a href="#Avoiding-Imbalance-through-Overstuffing" class="headerlink" title="Avoiding Imbalance through Overstuffing"></a><strong>Avoiding Imbalance through Overstuffing</strong></h4><ul><li>Never add new leaves at the bottom.</li><li>just add to a current leaf node. </li></ul><p>这也会造成一个问题，我们的叶子结点承载了太多(Leaf nodes can get too juicy.)，在叶子结点内的search是Θ(N)，退化了</p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081112835.png" alt="image-20230129174359497"></p><h4 id="solution"><a href="#solution" class="headerlink" title="solution"></a><strong>solution</strong></h4><ul><li>Set a limit L on the number of items, say L=3.</li><li>If any node has more than L items, give an item to parent.<ul><li>Which one? Let’s say (arbitrarily) the left-middle. 超载时有4个，选取中间靠左那个向上移</li><li>移了之后re-arrange the children accordingly.</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081112347.png" alt="image-20230129175307276" style="zoom:50%;" /><p>这些树被称作B-Tree or 2-3-4 tree or 2-3 tree，2-3-4的意思是每个结点的子结点可能有2,3,4之一</p><p>The process of adding a node to a 2-3-4 tree is:</p><ol><li>We still always inserting into a leaf node, so take the node you want to insert and traverse down the tree with it, going left and right according to whether or not the node to be inserted is greater than or smaller than the items in each node.</li><li>After adding the node to the leaf node, if the new node has 4 nodes, then pop up the middle left node and re-arrange the children accordingly.</li><li>If this results in the parent node having 4 nodes, then pop up the middle left node again, rearranging the children accordingly.</li><li>Repeat this process until the parent node can accommodate or you get to the root.</li></ol><p>Observation: Splitting-trees have <strong>perfect balance</strong>.</p><ul><li>如果分裂root，那么每个结点正好被压低一级，height+1</li><li>如果分裂叶子结点或者内部的结点，height不变</li><li>对于B树来说，不管是怎样的插入顺序，B-Tree都是稠密的，尽管可能在height上有细微的差别</li></ul><h4 id="B-Tree-Invariants"><a href="#B-Tree-Invariants" class="headerlink" title="B-Tree Invariants"></a><strong>B-Tree Invariants</strong></h4><p>由于B-Tree生成的独特方式，有以下不变的性质</p><ul><li>所有的叶结点到root的距离都相等</li><li>所有的非叶结点node有k个，那么它的子结点一定有k+1个</li></ul><p>这些不变量保证了B-Tree的稠密</p><h4 id="B-Tree-runtime"><a href="#B-Tree-runtime" class="headerlink" title="B-Tree runtime"></a>B-Tree runtime</h4><p>L: Max number of items per node.<br>Height: Between ~logL+1(N) and ~log2(N)</p><p>最高是每个叶子结点只包含一个，最低是每个叶子结点包含L个</p><ul><li><code>contains</code> O(logN)</li><li><code>add</code> O(logN)</li></ul><h4 id="2-3-Tree-Deletion"><a href="#2-3-Tree-Deletion" class="headerlink" title="2-3 Tree Deletion"></a>2-3 Tree Deletion</h4><p>In a 2-3 Tree, when we delete α from a node with 2 or more children, we:</p><ul><li><p><strong>Swap</strong> the value of the successor with α.   note:Successor will always be in a <strong>leaf node</strong></p></li><li><p>Then we <strong>delete</strong> the successor value.</p><ul><li><p>**Multi-Key Leaves **</p><ul><li><p>simply remove the item from the leaf</p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081112794.png" alt="image-20230129194308173" style="zoom:67%;" /></li></ul></li><li><p><strong>Single-Key Leaves</strong></p><ul><li>cannot simply remove the node entirely (Any node with k items must have k + 1 children! Instead, we’ll leave an empty node, which must be filled.)</li><li>so how to <strong>Filling in Empty Nodes (FIEN)</strong>?</li></ul></li></ul></li></ul><p><strong>Filling in Empty Nodes (FIEN)</strong></p><ol><li><p>兄弟结点 Mutil-key Sibling</p><ul><li><p>X steals parent’s item. Parent steals sibling’s item.</p></li><li><p>If X was not a leaf node, X steals one of sibling’s subtrees (to keep is a B-Tree).</p></li><li><p>x不是叶子结点<img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081112621.png" alt="image-20230129195026532" style="zoom:50%;" /></p></li><li><p>x是叶子结点<img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081122359.png" alt="image-20230129195130561" style="zoom:50%;" /></p></li></ul></li><li><p>Multi-key parent  ( siblings on the right all have one key)</p><ul><li>X and right sibling steal parent’s keys. Middle sibling moves into the parent.</li><li>Subtrees are passed along so that every node has the correct children.</li><li><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081112588.png" alt="image-20230129201754497" style="zoom: 50%;" /></li></ul></li><li><p>single-key parent and Sibling( The parent and all siblings have only one item.)</p><ul><li>Combine 1 sibling and parent into a single node that replaces X. Send the blank X up one level.</li><li>If blank ends up as the new root, just delete the blank and we are done.</li><li><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081112124.png" alt="image-20230129225609470" style="zoom:50%;" /></li></ul></li></ol><h3 id="BST-Rotating-Tree"><a href="#BST-Rotating-Tree" class="headerlink" title="BST Rotating Tree"></a>BST Rotating Tree</h3><blockquote><p>B-Tree实现起来很困难，尽管他快，让我们找另外一种同样快且实现简单的方法</p><p>由于插入顺序的不同，会形成多种B-Tree，其数目是可以计算的catalan(卡特兰数) <a href="https://en.wikipedia.org/wiki/Catalan_number">Catalan number - Wikipedia</a></p></blockquote><p>rotate可以在O(N)的时间内将树旋转为稠密的 (can move from any configuration to any other in 2n - 6 rotations )</p><p>The formal definition of rotation is:</p><p><code>rotateLeft(G)</code>: Let x be the right child of G. Make G the new left child of x.</p><ul><li>另一种理解方式：将right的x与G合并，然后向下发送合并之后的left(也就是G)，然后调整树的结构使其符合BST</li></ul><p><code>rotateRight(G)</code>: Let x be the left child of G. Make G the new right child of x.</p><ul><li>把G和left的x合并，然后向下发送合并之后的right(也就是G)，然后调整树使其符合BST</li></ul><p>不能rotate空的，无意义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">rotateRight</span><span class="hljs-params">(Node h)</span> &#123;<br>    <span class="hljs-comment">// assert (h != null) &amp;&amp; isRed(h.left);</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> h.left;<br>    h.left = x.right;<br>    x.right = h;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-comment">// make a right-leaning link lean to the left</span><br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">rotateLeft</span><span class="hljs-params">(Node h)</span> &#123;<br>    <span class="hljs-comment">// assert (h != null) &amp;&amp; isRed(h.right);</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> h.right;<br>    h.right = x.left;<br>    x.left = h;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><p>在建造的时候保持稠密</p><h3 id="Red-Black-Tree"><a href="#Red-Black-Tree" class="headerlink" title="Red-Black Tree"></a>Red-Black Tree</h3><blockquote><p>a specific tree data structure that remains balanced through using rotations.</p><p>一般的BST需要O(N)的时间来rotate来达到balance，这是在建造好之后采取的措施，亡羊补牢；下面介绍一种在建造的时候利用rotate来保持balance和bushy的结构</p></blockquote><p>Our goal: Build a BST that is structurally identical to a 2-3 tree.Since 2-3 trees are balanced, so will our special BSTs.</p><p>一个很好的exercise <a href="https://docs.google.com/presentation/d/1jgOgvx8tyu_LQ5Y21k4wYLffwp84putW8iD7_EerQmI/edit#slide=id.g463de7561_042">LLRB Insertion Demo - Google 幻灯片</a></p><h4 id="Representing-a-2-3-Tree-as-a-BST"><a href="#Representing-a-2-3-Tree-as-a-BST" class="headerlink" title="Representing a 2-3 Tree as a BST"></a><strong>Representing a 2-3 Tree as a BST</strong></h4><p>A 2-3 tree的2-nodes(可以有两个子结点的结点)和BST的完全一致</p><p>对于3-nodes来说：两种可能的方法</p><ol><li><p>“glue” node that doesn’t hold any information and only serves to show that its 2 children are actually a part of one node.</p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081112134.png" alt="image-20230130172316301" style="zoom:50%;" /><ul><li>缺点是不优雅，code will be ugly，而且d的right实际上浪费了</li></ul></li><li><p>Create “glue” links with the smaller item <strong>off to the left</strong>  (这种更好)</p><ul><li><p>make the left element a child of the right one.</p></li><li><p>We show that a link is a glue link by making it <strong>red</strong>.</p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081112053.png" alt="image-20230130172707741" style="zoom:50%;" /></li></ul></li></ol><h4 id="LLRB"><a href="#LLRB" class="headerlink" title="LLRB"></a><strong>LLRB</strong></h4><p>A BST with left glue links that represents a 2-3 tree is often called a “Left Leaning Red Black Binary Search Tree” or LLRB.</p><ul><li>LLRBs are normal BSTs! </li><li>There is a <strong>1-1 correspondence</strong> between an LLRB and an equivalent 2-3 tree.</li><li>The red is just a convenient fiction. Red links don’t “do” anything special.</li></ul><p><strong>LLRB’s的特征</strong></p><p>Here are the properties of LLRB’s:</p><ul><li>与 2-3 trees 1-1对应.</li><li>No node has 2 red links.</li><li>There are no red right-links.</li><li>Every path from root to leaf has same number of black links (because 2-3 trees have same number of links to every leaf).</li><li>Height is no more than ~2x height of corresponding 2-3 tree.</li></ul><p>What is the maximum height of the corresponding LLRB? (看黑线和红线之和)</p><ul><li>Total height is H (black) + H + 1 (red) = 2H + 1.</li></ul><p><strong>LLRB Construction</strong></p><ul><li>Insert as usual into a BST.</li><li>Use zero or more rotations to maintain the 1-1 mapping.</li></ul><h4 id="Inserting-into-LLRB"><a href="#Inserting-into-LLRB" class="headerlink" title="Inserting into LLRB"></a>Inserting into LLRB</h4><p>为了保持LLRB与2-3树的1-1对应，我们需要在LLRB中处理2-3树插入的各种情况</p><ol><li><p><strong>Task 1: insertion color</strong>: 在2-3 tree中，我们总是向叶子结点add，因此link的颜色总是应该为红色</p></li><li><p><strong>Task 2: insertion on the right</strong>: 回想一下，我们使用的是left-leaning的红色黑色树，这意味着我们永远不可能有一个right的红色链接。如果我们插入在右边，我们将需要使用旋转，以保持 LLRB 不变量。</p><p>但是，如果我们将要在右边加入一个红色链接，而且其左边也是一个红色链接，我们暂时允许这种情况存在，后面解决这种illegal的情况</p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081112211.png" alt="image-20230130174510212" style="zoom:50%;" /></li><li><p>**Task 3: double insertion on the left:**（two consecutive left links）</p><p>If there are 2 left red links, then we have a 4-node which is illegal. First, we will rotate to create the same tree seen in task 2 above. </p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081112848.png" alt="image-20230130174943033" style="zoom:50%;" /></li><li><p><strong>Splitting Temporary 4-Nodes</strong>：Then, in both situations, we will flip the colors of all edges touching S. This is equivalent to pushing up the middle node in a 2-3 tree.</p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081112438.png" alt="image-20230130175007766" style="zoom:50%;" /></li></ol><p>Here is a <strong>summary</strong> of all the operations:</p><ul><li>When inserting: Use a red link.</li><li>If there is aright leaning “3-node”, we have a Left Leaning Violation<ul><li><u>Rotate left</u> the appropriate node to fix.</li></ul></li><li>If there are two consecutive left links, we have an incorrect 4 Node Violation!<ul><li><u>Rotate right</u> the appropriate node to fix.</li></ul></li><li>If there are any nodes with two red children, we have a temporary 4 Node.<ul><li><u>Color flip</u> the node to emulate the split operation.</li></ul></li></ul><ul><li>注意这些情况可能会串联出现</li></ul><p><strong>Runtime</strong> :都是log(N)</p><p>Amazingly, turning a BST into an LLRB requires only 3 clever lines of code.Does not include helper methods (which do not require cleverness).</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">put</span><span class="hljs-params">(Node h, Key key, Value val)</span> &#123;<br>    <span class="hljs-keyword">if</span> (h == <span class="hljs-literal">null</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key, val, RED); &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">cmp</span> <span class="hljs-operator">=</span> key.compareTo(h.key);<br>    <span class="hljs-keyword">if</span> (cmp &lt; <span class="hljs-number">0</span>)      &#123; h.left  = put(h.left,  key, val); &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmp &gt; <span class="hljs-number">0</span>) &#123; h.right = put(h.right, key, val); &#125;<br>    <span class="hljs-keyword">else</span>              &#123; h.val   = val;                    &#125;<br><span class="hljs-comment">//只有下面这三行是额外添加的</span><br>    <span class="hljs-keyword">if</span> (isRed(h.right) &amp;&amp; !isRed(h.left))      &#123; h = rotateLeft(h);  &#125;<br>    <span class="hljs-keyword">if</span> (isRed(h.left)  &amp;&amp;  isRed(h.left.left)) &#123; h = rotateRight(h); &#125;<br>    <span class="hljs-keyword">if</span> (isRed(h.left)  &amp;&amp;  isRed(h.right))     &#123; flipColors(h);      &#125; <br><br>    <span class="hljs-keyword">return</span> h;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><ul><li>Binary search trees are simple, but they are subject to imbalance which leads to crappy runtime.</li><li>2-3 Trees (B Trees) are balanced, but painful to implement and relatively slow.</li><li>LLRBs insertion is simple to implement (but deletion is hard).<ul><li>Works by maintaining mathematical bijection with a 2-3 trees.</li></ul></li><li>Java’s <a href="https://github.com/AdoptOpenJDK/openjdk-jdk11/blob/999dbd4192d0f819cb5224f26e9e7fa75ca6f289/src/java.base/share/classes/java/util/TreeMap.java">TreeMap</a> is a red-black tree (but not left leaning).</li><li>LLRBs maintain correspondence with 2-3 tree, Standard Red-Black trees maintain correspondence with 2-3-4 trees.</li><li>Allows glue links on either side (see <a href="http://en.wikipedia.org/wiki/Red%E2%80%93black_tree">Red-Black Tree</a>).</li><li>More complex implementation, but significantly faster.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>BST</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2022/01/08/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2022/01/08/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p>CS61B 的并查集，从原理到实现，WQU，路径压缩</p><span id="more"></span><h1 id="chapt9-Disjoint-Sets-并查集"><a href="#chapt9-Disjoint-Sets-并查集" class="headerlink" title="chapt9 Disjoint Sets(并查集)"></a>chapt9 Disjoint Sets(并查集)</h1><p>不同并查集的元素也不能相同，而且为正数</p><p>支持两个操作的数据结构</p><ol><li><code>connect(x, y)</code>: connect <code>x</code> and <code>y</code>. Also known as <code>union</code></li><li><code>isConnected(x, y)</code>: returns true if <code>x</code> and <code>y</code> are connected (i.e. part of the same set).</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DisjointSets</span> &#123;<br>    <span class="hljs-comment">/** connects two items P and Q */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span>;<br><br>    <span class="hljs-comment">/** checks to see if two items are connected */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ListOfSets"><a href="#ListOfSets" class="headerlink" title="ListOfSets"></a>ListOfSets</h2><p>最朴素的做法，List存set，<code>List&lt;Set&lt;Integer&gt;&gt;</code></p><p>缺点：每次connect的时候需要遍历，O(N)，并且也不好写出</p><table><thead><tr><th>Implementation</th><th>Constructor</th><th><code>connect</code></th><th><code>isConnected</code></th></tr></thead><tbody><tr><td>ListOfSets</td><td>Θ(N)<a href="https://joshhug.gitbooks.io/hug61b/content/chap9/chap92.html#fn_1">1</a></td><td>O(N)</td><td>O(N)</td></tr></tbody></table><h2 id="Quick-Find"><a href="#Quick-Find" class="headerlink" title="Quick Find"></a>Quick Find</h2><ul><li>数组的索引表示集合的元素</li><li>The <strong>value at an index</strong> is the set number it belongs to.</li><li>只需要确保在一个集合中的元素有相同的id值就可以，这个值是什么并不重要</li></ul><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081111746.png" alt="image-20230125194838220" style="zoom: 80%;" /><ul><li><code>connect</code>：让两个集合的所有元素id改为相同 </li><li><code>isConnected(x, y)</code>：we simply check if <code>id[x] == id[y]</code>. </li></ul><table><thead><tr><th>Implementation</th><th>Constructor</th><th><code>connect</code></th><th><code>isConnected</code></th></tr></thead><tbody><tr><td>QuickFind</td><td>Θ(N)</td><td>Θ(N)</td><td>Θ(1)</td></tr></tbody></table><h2 id="Quick-Union"><a href="#Quick-Union" class="headerlink" title="Quick Union"></a>Quick Union</h2><p>不用id，我们在每个元素的索引存上他parent，如果没有parent，那么该元素为根，我们存上一个负数。这会让我们的集合看起来像个树形结构</p><p>we represent <code>&#123;0, 1, 2, 4&#125;, &#123;3, 5&#125;, &#123;6&#125;</code> as:</p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081111147.png" alt="image-20230125201839631" style="zoom:67%;" /><p>引入一个helper function： <code>find(int item)</code> which returns the root of the tree <code>item</code> is in. For example, for the sets above, <code>find(4) == 0</code>, <code>find(1) == 0</code>, <code>find(5) == 3</code>, etc. Each element has a unique root.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br>    <span class="hljs-keyword">while</span>(parent[x]&gt;<span class="hljs-number">0</span>)&#123;<br>        x=parent[x];<br>    &#125;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>connect(x,y)</code>：将x的parent改为y or 将y的parent改为x</li><li><code>isConnected(x,y)</code> ： check if <code>find(x) == find(y)</code>.</li></ul><table><thead><tr><th>Implementation</th><th>Constructor</th><th><code>connect</code>（主要find操作耗时）</th><th><code>isConnected</code></th></tr></thead><tbody><tr><td>QuickUnion</td><td>Θ(N)</td><td>O(N)</td><td>O(N)</td></tr></tbody></table><h2 id="Weighted-Quick-Union-WQU"><a href="#Weighted-Quick-Union-WQU" class="headerlink" title="Weighted Quick Union (WQU)"></a>Weighted Quick Union (WQU)</h2><p><strong>New rule:</strong> whenever we call <code>connect</code>, we always link the root of the <strong>smaller</strong> tree <strong>to the larger</strong> tree.</p><p>遵循这个规则，我们的tree高度不会超过logN，N是并查集元素的数量，因此<strong>the runtimes of <code>connect</code> and <code>isConnected</code> are bounded by O(log N).</strong></p><blockquote><p>既可以用数量，也可以用高度来衡量大小，两者的效率不会差太多，但是高度写起来很麻烦，因此我们常用集合数量来衡量</p></blockquote><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081111558.png" alt="image-20230126164358686" style="zoom: 67%;" /><table><thead><tr><th>Implementation</th><th>Constructor</th><th><code>connect</code></th><th><code>isConnected</code></th></tr></thead><tbody><tr><td>Weighted Quick Union</td><td>Θ(N)</td><td>O(log N)</td><td>O(log N)</td></tr></tbody></table><h2 id="WQU-with-path-compression-路径压缩"><a href="#WQU-with-path-compression-路径压缩" class="headerlink" title="WQU with path compression(路径压缩)"></a>WQU with path compression(路径压缩)</h2><p>The clever insight is realizing that whenever we call <code>find(x)</code> we have to traverse the path from <code>x</code> to root. So, along the way we can connect all the items we visit to their root at no extra asymptotic cost.</p><p>Connecting all the items along the way to the root will help make our tree shorter with each call to <code>find</code>.</p><table><thead><tr><th>Implementation</th><th><code>isConnected</code></th><th><code>connect</code></th></tr></thead><tbody><tr><td>Quick Find</td><td>Θ(N)</td><td>Θ(1)</td></tr><tr><td>Quick Union</td><td>O(N)</td><td>O(N)</td></tr><tr><td>Weighted Quick Union (WQU)</td><td>O(log N)</td><td>O(log N)</td></tr><tr><td>WQU with Path Compression</td><td>O(α(N))*</td><td>O(α(N))*</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>Union find</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
