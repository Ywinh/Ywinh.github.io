<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>xv6-trap</title>
    <link href="/2024/04/28/xv6-trap/"/>
    <url>/2024/04/28/xv6-trap/</url>
    
    <content type="html"><![CDATA[<p>详细看看 xv6 trap：相关寄存器，trap流程，用户trap，内核trap</p><span id="more"></span><h2 id="trap"><a href="#trap" class="headerlink" title="trap"></a>trap</h2><p><strong>首先介绍一下 S mode 和 U mode 的小区别：</strong></p><p>supervisor mode可以控制什么/特权是什么？</p><ul><li><p>读写控制寄存器：satp,stvec,sepc,sscratch</p></li><li><p>可以使用 PTE_U 标志位为 0 的 PTE。当 PTE_U 标志位为 1 的时候，表明用户代码可以使用这个页表；</p><p>如果这个标志位为 0，则只有 supervisor mode 可以使用这个页表。</p></li></ul><p>需要特别指出的是，supervisor mode 中的代码并不能读写任意物理地址。在 supervisor mode 中，就像普通的用户代码一样，也需要通过 page table 来访问内存。如果一个虚拟地址并不在当前由 SATP 指向的 page table 中，又或者 SATP 指向的 page table 中 PTE_U=1，那么 supervisor mode 不能使用那个地址。所以，即使我们在 supervisor mode，我们还是受限于当前 page table 设置的虚拟地址。</p><p><strong>什么时候会产生 trap</strong></p><p>有三种事件会导致中央处理器搁置普通指令的执行，并强制将控制权转移到处理该事件的特殊代码上</p><p>包括</p><ul><li><p>exception</p><ul><li>error:（用户或内核）指令做了一些非法的事情，例如除以零或使用无效的虚拟地址</li></ul></li><li><p>syscall: ecall （注意ecall并不会切换page table，所以这意味着，trap处理代码必须存在于每一个user page table中）</p><p>ecall之后就转到stevc寄存器指向的地址开始继续执行指令（trampoline page）</p></li><li><p>interrupt：设备中断，一个设备，例如当磁盘硬件完成读或写请求时，向系统表明它需要被关注。</p></li></ul><p>我们希望trap是<strong>透明的</strong>，也就是用户感觉不到发生 trap 了</p><p>通常的顺序是</p><ol><li>陷阱强制将控制权转移到内核</li><li>内核保存寄存器和其他状态，以便可以恢复执行</li><li>内核执行适当的处理程序代码（例如，系统调用接口或设备驱动程序）</li><li>内核恢复保存的状态并从陷阱中返回</li><li>原始代码从它停止的地方恢复。</li></ol><p>注意cpu不会保存除 <code>pc</code> 之外的任何寄存器，切换内核页表，切换内核栈，保存寄存器这些工作都需要内核软件自己来实现</p><h3 id="ecall时发生了什么"><a href="#ecall时发生了什么" class="headerlink" title="ecall时发生了什么"></a>ecall时发生了什么</h3><p>第一，ecall将代码从user mode改到supervisor mode。</p><p>第二，ecall将程序计数器的值保存在了SEPC寄存器。</p><p>第三，ecall会跳转到STVEC寄存器指向的指令。</p><p>sscrath(S-mode sratch：S态下可以临时使用的寄存器) 这个寄存器用户是看不到的，在刚刚进入trap的时候操作系统把trapframe的地址放在了里面</p><p>satp (S-mode address translation and protection)</p><p>Trampoline(跳板)：</p><ul><li>对ecall瞬间的状态做快照<ul><li>填充 trapframe</li><li>利用 sscratch 保存所有寄存器</li></ul></li></ul><h3 id="trap-相关寄存器"><a href="#trap-相关寄存器" class="headerlink" title="trap 相关寄存器"></a>trap 相关寄存器</h3><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MK04CleJKuURh9XXWGG%2F-MK0Jg73bN-fwYa4_qZ_%2Fimage.png?alt=media&token=0c0df379-44cc-4f81-926e-8855fdcbe9c3" alt="img" style="zoom:33%;" /><p><code>stvec</code></p><ul><li>CSR</li><li>保存”Handler”代码的地址</li></ul><p><code>sstatus</code></p><ul><li>sie (interrupt enabled)<ul><li>0 -&gt; disabled</li><li>1 -&gt; enabled</li></ul></li><li>spie (previous interrupts enabled)</li><li>spp (previous priviledge )<ul><li>0 -&gt; user</li><li>1 -&gt; kernel</li></ul></li></ul><p><code>sepc</code>（Supervisor Exception Program Counter）：</p><ul><li>当发生陷阱时，RISC-V会在这里保存程序计数器<code>pc</code>（因为<code>pc</code>会被<code>stvec</code>覆盖）。<code>sret</code>（从陷阱返回）指令会将<code>sepc</code>复制到<code>pc</code>。内核可以写入<code>sepc</code>来控制<code>sret</code>的去向。</li></ul><p><code>scause</code>： RISC-V在这里放置一个描述陷阱原因的数字。</p><p><code>sscratch</code>：内核在这里放置了一个值，这个值在陷阱处理程序一开始就会派上用场。</p><p><code>mstatus</code></p><ul><li>大致和<code>sstatus</code>一样，但是<code>mpp</code>有三个状态：user,supervisor,machine</li></ul><h3 id="trap大致流程"><a href="#trap大致流程" class="headerlink" title="trap大致流程"></a>trap大致流程</h3><p>当需要强制执行陷阱时，RISC-V硬件对所有陷阱类型（计时器中断除外）执行以下操作：</p><ol><li>如果陷阱是设备中断，并且状态<strong>SIE</strong>位被清空，则不执行以下任何操作。</li><li>清除<strong>SIE</strong>以禁用中断。</li><li>将<code>pc</code>复制到<code>sepc</code>。</li><li>将当前模式（用户或管理）保存在状态的<strong>SPP</strong>位中。</li><li>设置<code>scause</code>以反映产生陷阱的原因。</li><li>将模式设置为S mode</li><li>将<code>stvec</code>复制到<code>pc</code>。</li><li>在新的<code>pc</code>上开始执行。</li></ol><p>伪代码如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">sepc</span> = pc<br><br><span class="hljs-attr">pc</span> = stvec<br><br><span class="hljs-attr">scause</span> = ... (<span class="hljs-number">1</span> = TIMER<span class="hljs-comment">; 8 = syscall)</span><br><br><span class="hljs-attr">stval</span>  = addtional info (e.g: badInstruction)<br><br><span class="hljs-attr">sstatus.SPP</span> = Previous Mode (<span class="hljs-number">0</span> =U <span class="hljs-comment">; 1 = S) </span><br><br><span class="hljs-attr">sstatus.SPIE</span> = ssatus.SIE (保存之前的SIE)<br><br><span class="hljs-attr">sstatus.SIE</span> = <span class="hljs-number">0</span><br><br><span class="hljs-attr">mode</span> = S<br></code></pre></td></tr></table></figure><h4 id="trampoline"><a href="#trampoline" class="headerlink" title="trampoline"></a>trampoline</h4><blockquote><p>trampoline page在user page table中的映射与kernel page table中的映射是完全一样的。这两个page table中其他所有的映射都是不同的，只有trampoline page的映射是一样的，因此我们在切换page table时，寻址的结果不会改变，我们实际上就可以继续在同一个代码序列中执行程序而不崩溃。这是trampoline page的特殊之处，它同时在user page table和kernel page table都有相同的映射关系。</p></blockquote><p>即使trampoline page是在用户地址空间的user page table完成的映射，用户代码不能写它，因为这些page对应的PTE并没有设置PTE_u标志位。这也是为什么trap机制是安全的。</p><p>之所以叫trampoline page，是因为你某种程度在它上面“弹跳”了一下，然后从用户空间走到了内核空间。</p><h4 id="TRAPFRAME"><a href="#TRAPFRAME" class="headerlink" title="TRAPFRAME"></a>TRAPFRAME</h4><p>trapframe page里面存放了什么</p><p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MLQ4bdT5ylb0H6aFAhT%2F-MLVsAYDqR92__T08g2L%2Fimage.png?alt=media&token=286cd987-8607-482d-a7e4-b37de5eb47ac" alt="img"></p><p>很多槽位空出来是为了保存32个寄存器</p><p>在最开始还有5个数据，这些是内核事先存放在 trapframe 中的数据。</p><p>所以如何保存用户寄存器？</p><ul><li><p>内核非常方便的将trapframe page映射到了每个user page table，这个空间可以用于保存用户寄存器</p></li><li><p>进入到user space之前，内核会将trapframe page的地址保存在这个寄存器<code>sscratch</code>中，也就是0x3fffffe000这个地址</p><p>我们使用<code>csrrw</code>指令来交换<code>a0</code>和<code>sscratch</code>的值</p></li></ul><p>sret是我们在kernel中的最后一条指令，当我执行完这条指令：</p><ul><li>程序会切换回user mode</li><li>SEPC寄存器的数值会被拷贝到PC寄存器（程序计数器）</li><li>重新打开中断</li></ul><h3 id="从用户空间陷入"><a href="#从用户空间陷入" class="headerlink" title="从用户空间陷入"></a>从用户空间陷入</h3><blockquote><p>用户ecall or 做了一些非法事件 or 设备中断</p></blockquote><p>由于RISC-V硬件在陷阱期间不会切换页表，所以用户页表必须包括<code>uservec</code>（<strong>stvec</strong>指向的陷阱向量指令）的映射。<code>uservec</code>必须切换<code>satp</code>以指向内核页表；为了在切换后继续执行指令，<code>uservec</code>必须在内核页表中与用户页表中映射相同的地址。</p><p>因此才使用包含<code>uservec</code>的蹦床页面（trampoline page）来满足这些约束</p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202404212201089.png" alt="image-20240421220132965"></p><p>stvec 初始时指向 uservec</p><p>trapframe 预先包含的内容：</p><ul><li>指向当前进程内核栈的指针、当前CPU的<code>hartid</code>、<code>usertrap</code>的地址和内核页表的地址</li></ul><p><strong>uservec</strong> 做的工作：</p><ul><li><p>利用 sscratch 做媒介，把 a0 原本的值存在 sscratch</p></li><li><p>保存寄存器：（在用户地址空间）</p><p>利用 a0 在 trapframe 保存所有的寄存器， a0 最后保存，此时所有的寄存器都保存完了，想用哪个用哪个，将 a0 从 sscratch 恢复然后保存到 trapframe</p></li><li><p>切换到内核页表：根据 trapframe 原本保存的 kernel_satp，写入 satp </p></li><li><p>跳转到 usertrap()，不会返回</p></li></ul><p><strong>usertrap()：</strong>确定陷阱的原因，处理并返回</p><ul><li>首先 assert 这是一个来自用户态的中断：看sstatus.SPP是否为0，应该有一个地方会事先设置 SPP</li><li>stvec = kernelvec </li><li>保存sepc：<code>p-&gt;trapframe-&gt;epc = r_sepc()</code> <ul><li>为什么在这里我们又再次保存了sepc呢，是因为<code>usertrap</code>中可能有一个进程切换，可能导致<code>sepc</code>被覆盖</li></ul></li><li>判断是什么引起的trap，分类处理<ul><li>syscall ：<ul><li>p-&gt;trapframe-&gt;epc += 4 返回到发生trap的下一条指令</li><li>打开中断【不过这个地方为什么要关？注释上写的是为了方便时钟中断】</li><li>执行syscall</li></ul></li><li>设备中断：<ul><li>devintr() 来处理</li><li>特殊：如果是时钟中断，处理了之后要 yield()</li></ul></li><li>其他：发生错误，打印寄存器信息，然后kill这个进程，exit</li></ul></li><li>调用 usertrapret()</li></ul><p><strong>usertrapret():</strong> 未雨绸缪，为下一次 user trap 做准备</p><ul><li>关闭中断：现在要从 kernel 返回 user，不希望被打断，（除非你套娃，你有一个trap的trap来处理这种情况）</li><li>把 stvec  = uservec，方便下次trap，这个是从用户空间陷入的起点</li><li>写入一些 uservec 需要的 trapframe 信息（比如内核页表，内核栈，hartid）,也是为了方便下次</li><li>sstatus.SPP = 0 （转回user mode）,  sstatusSPIE = 1 （user mode可以中断）</li><li>sepc = p-&gt;trapfreame-&gt;epc</li><li>调用 userret ()，这里传入了两个参数 TRAPFRAME地址 和 satp（用户页表）</li></ul><p><strong>userret</strong>：从kernel返回到user</p><ul><li>将用户页表写入 satp</li><li>从 TRAPFRAME 地址恢复所有寄存器的值</li><li>sret 返回用户态（这里要利用spec ）</li></ul><h3 id="从内核空间陷入"><a href="#从内核空间陷入" class="headerlink" title="从内核空间陷入"></a>从内核空间陷入</h3><p>stvec 事先指向的是 kernelvec</p><p>kernelvec：</p><ul><li>保存寄存器（在被中断的内核线程的栈上）</li><li>跳转到kerneltrap()，会返回</li></ul><p>kerneltrap()：</p><ul><li>检查是什么类型的trap<ul><li>设备中断</li><li>异常</li></ul></li><li>返回到被 trap 中断的代码</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>xv6-in-openSBI</title>
    <link href="/2024/04/15/xv6-in-openSBI/"/>
    <url>/2024/04/15/xv6-in-openSBI/</url>
    
    <content type="html"><![CDATA[<p>最近完成操作系统大赛，需要为 xv6 实现一个 SBI 来完成指定的引导</p><p>TODO：理一下 xv6 原本的引导过程</p><span id="more"></span><h1 id="引导过程"><a href="#引导过程" class="headerlink" title="引导过程"></a>引导过程</h1><h2 id="OpenSBI"><a href="#OpenSBI" class="headerlink" title="OpenSBI"></a>OpenSBI</h2><p>OpenSBI的主要功能就是在M态初始化硬件，然后以S态跳转到内核的位置，完成整个启动过程。此外，OpenSBI作为S态内核的执行环境（EEI），可以以 <code>ecall</code> 的方式为S态内核提供一些只有M态才能实现的功能</p><p>每个cpu启动时，都在M态。在将控制权交给操作系统时，转换为 S 态</p><p>qemu 自带一个 opensbi</p><blockquote><p>指定 -bios default 这个选项</p></blockquote><p>由于 opensbi 占据了 0x80000000 到 0x80200000 这段区域，因此我们需要把 xv6 原本这段区域（Kernel）迁移到 0x80200000</p><p>加入opensbi后的内存布局</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c">PHYSICAL_MEMORY_TOP-&gt; +----------------------------+----<br>                      |                            |     <br>                      |    Free Physical memory    |    <br>                      |                            |                         <br>   kernelEnd   -----&gt; +----------------------------+----<br>                      |                            |                         <br>                      |          Kernel            |    <br>                      |                            |                           <br> <span class="hljs-number">0x8020</span> <span class="hljs-number">0000</span>   -----&gt; +----------------------------+----<br>                      |                            |                           <br>                      |         Open SBI           |    <br>                      |                            |                 <br> <span class="hljs-number">0x8000</span> <span class="hljs-number">0000</span>  -----&gt;  +----------------------------+----<br>                      |                            |                           <br>                      |                            |                           <br>                      |                            |                           <br>                      +----------------------------+---<br>                      |                            |                           <br>                      |           MMIO             |                <br>                      |                            |                           <br>                      +----------------------------+----<br>                      |                            |                           <br>                      |                            |                           <br>                      |                            |                           <br>                      +----------------------------+                           <br></code></pre></td></tr></table></figure><p>为了加入 SBI，需要更改的地方</p><ol><li><code>kernel.ld</code>  里面的内核起始地址</li><li><code>entry.s</code> 里面，<ul><li>由于 sbi 把 hart id 放在了 a0 寄存器，xv6 是从 tp 寄存器读出 hart id 的，因此这里需要一个 mv 指令</li><li>然后在这里要设置好对应核的 stack，每个核开了 4096 byte，需要设置好 sp 寄存器</li></ul></li><li>然后更改 xv6 的时钟中断实现<ul><li>因为 xv6 的时钟中断是在 m 态实现的，要实现 sbi 我们一直都会在 S 态，所以利用sbi提供的接口在 s 态实现了时钟中断</li><li>更改 <code>trap.c</code> 中 <code>scause</code> 为时钟中断时的动作</li></ul></li></ol><h2 id="多核启动流程"><a href="#多核启动流程" class="headerlink" title="多核启动流程"></a>多核启动流程</h2><p>由于 qemu 启动时的启动核不一定是 0，可能是随机的，目前采用的方式是</p><blockquote><p>注意这种启动方式可能启动核不是 0，而是其他，后期可能需要更改</p></blockquote><ul><li><p>设置了一个共享变量 <code>volatile static int boot_hart = -1;</code></p></li><li><p>启动核进入 if 判断，初始化自己，然后更改这个共享变量，利用 sbi 来唤醒其他核</p><p>初始化流程：</p><ul><li><p>更改 boot hart</p></li><li><p>初始化 printf (采用uart)</p></li><li><p>打印启动信息</p></li><li><p>初始化物理内存分配</p></li><li><p>初始化 kernel page table</p></li><li><p>开启分页</p></li><li><p>初始化进程</p></li><li><p>初始化根文件系统 (在proc.c里面)</p></li><li><p>初始化 trap 并设置好 kernelvec</p></li><li><p>初始化中断代理 PLIC</p></li><li><p>初始化 buffer cache</p></li><li><p>初始化 File table</p></li><li><p>初始化 virtio 驱动</p></li><li><p>开启 init 进程</p></li><li><p>使用 <code>SBI_HART_START</code> 启动其他核</p><p>初始化根文件系统</p><p><strong>开启 <code>init</code> 进程</strong></p></li></ul></li><li><p>其他核进入else，初始化自己，调用那些 <code>*inithart</code>的 函数</p><p>初始化流程</p><ul><li>开启分页</li><li>设置 kernelvec</li><li>PLIC 中断代理开启</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">volatile</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> boot_hart = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> _entry();<br><span class="hljs-type">void</span> <span class="hljs-title function_">start_harts</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// start() jumps here in supervisor mode on all CPUs.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-keyword">if</span>(boot_hart == <span class="hljs-number">-1</span>)&#123;<br>    boot_hart = cpuid();<br>    consoleinit();<br>    printfinit();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xv6 kernel is booting\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    kinit();         <span class="hljs-comment">// physical page allocator</span><br>    kvminit();       <span class="hljs-comment">// create kernel page table</span><br>    kvminithart();   <span class="hljs-comment">// turn on paging</span><br>    procinit();      <span class="hljs-comment">// process table</span><br>    trapinit();      <span class="hljs-comment">// trap vectors</span><br>    trapinithart();  <span class="hljs-comment">// install kernel trap vector</span><br>    plicinit();      <span class="hljs-comment">// set up interrupt controller</span><br>    plicinithart();  <span class="hljs-comment">// ask PLIC for device interrupts</span><br>    binit();         <span class="hljs-comment">// buffer cache</span><br>    <span class="hljs-comment">// iinit();         // inode table</span><br>    fileinit();      <span class="hljs-comment">// file table</span><br>    virtio_disk_init(); <span class="hljs-comment">// emulated hard disk</span><br>    userinit();      <span class="hljs-comment">// first user process</span><br>    <span class="hljs-comment">//started = 1;</span><br>    __sync_synchronize();<br>    <span class="hljs-comment">//启动其他核</span><br>    start_harts();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// while(started == 0)</span><br>    <span class="hljs-comment">//   ;</span><br>    __sync_synchronize();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hart %d starting\n&quot;</span>, cpuid());<br>    kvminithart();    <span class="hljs-comment">// turn on paging</span><br>    trapinithart();   <span class="hljs-comment">// install kernel trap vector</span><br>    plicinithart();   <span class="hljs-comment">// ask PLIC for device interrupts</span><br>  &#125;<br><br>  set_next_trigger();<br>  scheduler();        <br>&#125;<br><br><span class="hljs-type">void</span> <br><span class="hljs-title function_">start_harts</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; NCPU; i++ )&#123;<br>    <span class="hljs-keyword">if</span>(sbi_hart_get_status(i) == SBI_HSM_STATE_STOPPED)&#123;<br>      sbi_hart_start(i,(uint64)_entry,<span class="hljs-number">0</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>摘自FarmOs:</p><p>虽然说一个核就能完成大部分初始化工作，但因为架构要求，多核还是有一些需要各自初始化的代码。多核环境下需要注意这些事项：</p><ul><li>每个核需要设置独立的页表。允许各个核在运行阶段使用不同的页表</li><li>每个核有独立的核内时钟，为每个核单独计时</li><li>每个核有独立的中断处理向量，我们一般将其设为同一个位置</li><li>每个核有独立的外部中断控制器</li><li>当一个核与其他核访问同一个变量或同一块内存时，为了缓存能够及时同步，需要加 <code>fence</code> 指令，保证之前的所有读写指令在fence之后都已同步到内存。对应gcc的语法为 <code>__sync_synchronize()</code></li></ul><h2 id="SBI和BIOS和BOOTLOADER的关系"><a href="#SBI和BIOS和BOOTLOADER的关系" class="headerlink" title="SBI和BIOS和BOOTLOADER的关系"></a>SBI和BIOS和BOOTLOADER的关系</h2><blockquote><p>摘自 rCore</p></blockquote><p>SBI 是 RISC-V Supervisor Binary Interface 规范的缩写，OpenSBI 是RISC-V官方用C语言开发的SBI参考实现；RustSBI 是用Rust语言实现的SBI。</p><p>BIOS 是 Basic Input/Output System，作用是引导计算机系统的启动以及硬件测试，并向OS提供硬件抽象层。</p><p>机器上电之后，会从ROM中读取引导代码，引导整个计算机软硬件系统的启动。而整个启动过程是分为多个阶段的，现行通用的多阶段引导模型为：</p><p>ROM -&gt; LOADER -&gt; RUNTIME -&gt; BOOTLOADER -&gt; OS</p><ul><li>Loader 要干的事情，就是内存初始化，以及加载 Runtime 和 BootLoader 程序。而Loader自己也是一段程序，常见的Loader就包括 BIOS 和 UEFI，后者是前者的继任者。</li><li>Runtime 固件程序是为了提供运行时服务（runtime services），它是对硬件最基础的抽象，对OS提供服务，当我们要在同一套硬件系统中运行不同的操作系统，或者做硬件级别的虚拟化时，就离不开Runtime服务的支持。SBI就是RISC-V架构的Runtime规范。</li><li>BootLoader 要干的事情包括文件系统引导、网卡引导、操作系统启动配置项设置、操作系统加载等等。常见的 BootLoader 包括GRUB，U-Boot，LinuxBoot等。</li></ul><p>而 BIOS/UEFI 的大多数实现，都是 Loader、Runtime、BootLoader 三合一的，所以不能粗暴的认为 SBI 跟 BIOS/UEFI 有直接的可比性。</p><p>如果把BIOS当做一个泛化的术语使用，而不是指某个具体实现的话，那么可以认为 SBI 是 BIOS 的组成部分之一。</p><p>也可参考这份文稿《<a href="https://riscv.org/wp-content/uploads/2019/12/Summit_bootflow.pdf">An Introduction to RISC-V Boot Flow</a>》的P5, P7, P9-11。</p><p>题外话：<br>计算机最重要的思想之一就是分层抽象，在任意两层之间，还可以按照设计者的意愿再次添加抽象层。而软件架构的设计和实现，是为了解决现实世界的具体问题，会面临资源、财力、物力、人力、时间等多种因素的掣肘，就会诞生一些“不那么规矩”、“不那么单纯”的架构或组件/软件，它们往往会跨层次，跨模块，大模块拆小，小模块合并，甚至打破一些“金科玉律”等等。</p><p>所以，相比于弄懂一个名词，更多的精力应该放在理解事物的本质上，只要把解决问题的流程和方法弄明白了，解决问题的过程中所用到的子流程、工具、方法，你爱怎么叫怎么叫，甚至自己发明名词也可以（只是与外人沟通可能会不太顺畅）。</p>]]></content>
    
    
    
    <tags>
      
      <tag>xv6 openSBI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零到一的makefile</title>
    <link href="/2024/03/07/makefile/"/>
    <url>/2024/03/07/makefile/</url>
    
    <content type="html"><![CDATA[<p>笔者上手一些大型项目时，常常会看不懂Makefile而造成一些困难，因此参考资料形成了一篇文章，从完全零基础过来的，用时也不多。文末附上一个笔者最近学习的rCore的Makefile，看完全篇文章后一定可以看懂的，本文也可用于一个简单的中文手册查询。</p><span id="more"></span><p>一些好的学习资料：</p><p><a href="https://link.zhihu.com/?target=https://makefiletutorial.com/">Makefile Tutorial By Example</a></p><p>【从零开始学Makefile】 <a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/BV1Bv4y1J7QT/?p=35&share_source=copy_web&vd_source=576f3acb9c32919142fdca9c8e59711e">从零开始学Makefile_哔哩哔哩_bilibili</a></p><p><a href="https://link.zhihu.com/?target=https://gitee.com/yanmu_ym/cpp/blob/master/Make/make.md">Make/make.md · 岩木/CPP - Gitee.com</a></p><p><a href="https://seisman.github.io/how-to-write-makefile/">跟我一起写Makefile — 跟我一起写Makefile 1.0 文档 (seisman.github.io)</a></p><p>makefile有点像跟手动编译过程反着来，一步步去找依赖项</p><h1 id="规则的构成"><a href="#规则的构成" class="headerlink" title="规则的构成"></a><strong>规则</strong>的构成</h1><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">targets: prerequisites</span><br>command<br>command<br>command<br></code></pre></td></tr></table></figure><ul><li><p>targets（目标）：是文件名，通常一个规则只有一个targets</p></li><li><p>command（命令/方法）：创建目标的一系列步骤，需要用tab开头，</p></li><li><p>prerequisites（依赖）：也是文件名，可以有多个，用空格分隔，在运行目标的命令之前，这些文件需要存在。</p></li></ul><h1 id="命令和执行"><a href="#命令和执行" class="headerlink" title="命令和执行"></a>命令和执行</h1><h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><p>command其实就是执行shell的指令，默认一个command都是<strong>一个独立的shell</strong>来执行，如果需要所有command都在一个shell执行，需要<code>.ONESHELL</code></p><p>一个例子</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">all: </span><br>cd ..<br><span class="hljs-comment">#上面的cd不会影响这个echo，因为每行命令都在一个独立的shell里面运行</span><br>echo `pwd`<br><br><span class="hljs-comment"># 这个cd会影响echo，因为他们都在同一行，因此会打印出上级目录的路径</span><br>cd ..;echo `pwd`<br><br><span class="hljs-comment"># 和第二个一样，\表示在同一行</span><br>cd ..; \<br>echo `pwd`<br></code></pre></td></tr></table></figure><h2 id="command回显"><a href="#command回显" class="headerlink" title="command回显"></a><strong>command回显</strong></h2><p>command默认是先打印出语句，再执行内容，如果不需要先打印语句，在command前面加上<code>@</code></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">a: a.o</span><br>@echo hello<br></code></pre></td></tr></table></figure><p>也可以使用<code>.SILENT + 文件名</code>，表示直接执行不打印</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>如果一条规则当中包含多条Shell指令，每条指令执行完之后make都会检查返回状态，如果返回状态是0，则执行成功，继续执行下一条指令，直到最后一条指令执行完成之后，一条规则也就结束了。</p><p>如果过程中发生了错误，即某一条指令的返回值不是0，那么make就会终止执行当前规则中剩下的Shell指令。</p><p>例如</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">clean:</span><br>    rm main.o hello.o<br>    rm main.exe<br></code></pre></td></tr></table></figure><p>这时如果第一条rm main.o hello.o出错，第二条rm main.exe就不会执行。类似情况下，希望make忽视错误继续下一条指令。在指令开头<code>-</code>可以达到这种效果。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">clean:</span><br>    -rm main.o hello.o<br>    -rm main.exe<br></code></pre></td></tr></table></figure><p>也可以<code>make -k</code>，即使遇到错误也能继续执行，如果想一次查看Make的所有错误，可以使用<code>-k</code></p><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>在终端执行命令时，如果没有将目标作为 <code>make</code> 参数提供给命令，将运行第一个目标</p><p>make只会在这两种情况运行targets及其命令</p><ul><li>targets不存在，还未被创建</li><li>targets的依赖项更新了 （使用文件系统时间戳作为代理来确定是否有任何变化）</li></ul><p>一个示例</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">blah: blah.o</span><br>cc blah.o -o blah <span class="hljs-comment"># Runs third</span><br><br><span class="hljs-section">blah.o: blah.c</span><br>cc -c blah.c -o blah.o <span class="hljs-comment"># Runs second</span><br><br><span class="hljs-comment"># Typically blah.c would already exist, but I want to limit any additional required files</span><br><span class="hljs-section">blah.c:</span><br>echo <span class="hljs-string">&quot;int main() &#123; return 0; &#125;&quot;</span> &gt; blah.c <span class="hljs-comment"># Runs first</span><br></code></pre></td></tr></table></figure><p>以下 Makefile 最终运行所有三个目标。当您在终端中运行时 <code>make</code> ，它将构建一个按一系列步骤调用 <code>blah</code> 的程序：</p><ul><li>Make 选择目标，因为第一个目标是默认目标 <code>blah</code></li><li><code>blah</code> 需要 <code>blah.o</code> ，因此搜索 <code>blah.o</code> 目标</li><li><code>blah.o</code> 需要 <code>blah.c</code> ，因此搜索 <code>blah.c</code> 目标</li><li><code>blah.c</code> 没有依赖项，因此运行命令 <code>echo</code></li><li>然后运行该 <code>cc -c</code> 命令，因为所有 <code>blah.o</code> 依赖项都已完成</li><li>将运行 顶部 <code>cc</code> 命令，因为所有 <code>blah</code> 依赖项都已完成</li><li>就是这样： <code>blah</code> 是一个编译好的c程序</li></ul><p>可以看出targets会事先搜索依赖项是否已经创建，如果一个targets没有依赖项，那么会直接运行</p><p><strong>all</strong></p><p>运行all后面的所有目标</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">all: one two three</span><br><br><span class="hljs-section">one:</span><br>touch one<br><span class="hljs-section">two:</span><br>touch two<br><span class="hljs-section">three:</span><br>touch three<br><br><span class="hljs-section">clean:</span><br>rm -f one two three<br></code></pre></td></tr></table></figure><h2 id="一个规则多个目标"><a href="#一个规则多个目标" class="headerlink" title="一个规则多个目标"></a><strong>一个规则多个目标</strong></h2><p>当一个规则有多个目标时，将针对每个目标运行，<code>$@</code>是包含目标名称的<strong>auto</strong> 变量</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">all: f1.o f2.o</span><br><br>f1.o f2.o:<br>echo <span class="hljs-variable">$@</span><br><span class="hljs-comment"># Equivalent to:</span><br><span class="hljs-comment"># f1.o:</span><br><span class="hljs-comment"># echo f1.o</span><br><span class="hljs-comment"># f2.o:</span><br><span class="hljs-comment"># echo f2.o</span><br></code></pre></td></tr></table></figure><h2 id="同一目标多条规则"><a href="#同一目标多条规则" class="headerlink" title="同一目标多条规则"></a><strong>同一目标多条规则</strong></h2><p>同一目标可以对应多条规则。同一目标的所有规则中的依赖会被<strong>合并</strong>。但如果同一目标对应的多条规则都写了更新的command，则会使用最新的一条更新方法，并且会输出警告信息。</p><p>同一目标多规则通常用来给多个目标添加依赖而不用改动已写好的部分。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">input.o: input.cpp utility.inl</span><br>    g++ -c input.cpp<br><span class="hljs-section">main.o: main.cpp scene.h input.h test.h</span><br>    g++ -c main.cpp<br><span class="hljs-section">scene.o: scene.cpp scene.h utility.inl</span><br>    g++ -c scene.cpp<br><br>input.o main.o scene.o : common.h<br></code></pre></td></tr></table></figure><p>同时给三个目标添加了一个依赖common.h，但是不用修改上面已写好的部分。</p><p>作用是可以在后面给目标添加依赖</p><h2 id="为特定目标-模式-设置变量"><a href="#为特定目标-模式-设置变量" class="headerlink" title="为特定目标/模式 设置变量"></a>为特定目标/模式 设置变量</h2><p><strong>特定目标</strong></p><p>makefile的变量一般都是全局的，我们可以给特定目标设置只能他使用的变量</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">all: one = cool</span><br><br><span class="hljs-section">all: </span><br>echo one is defined: <span class="hljs-variable">$(one)</span><br><br><span class="hljs-section">other:</span><br>echo one is nothing: <span class="hljs-variable">$(one)</span><br></code></pre></td></tr></table></figure><ul><li>other目标看到的<code>$one</code>会打印一个空串</li></ul><p><strong>特定模式</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">%.c: one = cool</span><br><br><span class="hljs-section">blah.c: </span><br>echo one is defined: <span class="hljs-variable">$(one)</span><br><br><span class="hljs-section">other:</span><br>echo one is nothing: <span class="hljs-variable">$(one)</span><br></code></pre></td></tr></table></figure><h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><h2 id="普通依赖"><a href="#普通依赖" class="headerlink" title="普通依赖"></a><strong>普通依赖</strong></h2><p>前面说过的这种形式都是普通依赖。直接列在目标后面。普通依赖有两个特点：</p><ol><li>如果这一依赖是由其他规则生成的文件，那么执行到这一目标<strong>前</strong>会先执行生成依赖的那一规则</li><li>如果任何一个依赖文件修改时间比目标晚（更新了），那么就重新生成目标文件</li></ol><h2 id="order-only依赖"><a href="#order-only依赖" class="headerlink" title="order-only依赖"></a><strong>order-only依赖</strong></h2><p>依赖文件不存在时，会执行对应的方法生成，但<strong>依赖文件更新并不会导致目标文件的更新</strong></p><p>如果目标文件已存在，order-only依赖中的文件即使修改时间比目标文件晚，目标文件也不会更新。</p><p>定义方法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">targets : normal<span class="hljs-operator">-</span>prerequisites <span class="hljs-operator">|</span> <span class="hljs-keyword">order</span><span class="hljs-operator">-</span><span class="hljs-keyword">only</span><span class="hljs-operator">-</span>prerequisites<br></code></pre></td></tr></table></figure><p>normal-prerequisites部分可以为空</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><blockquote><p>变量定义类似C语言里的宏展开，只是字符串替换，因此变量只有一种类型：字符串</p></blockquote><p>变量只能是字符串。使用<code>:=</code> 或 <code>=</code></p><p><code>$(x)</code>就是用x这个字符串变量的值来替换<code>$(x)</code></p><p><code>$&#123;x&#125;</code>与<code>$(x)</code>等价</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">files := file1 file2<br><span class="hljs-section">some_file: </span><br>echo <span class="hljs-string">&quot;Look at this variable: &quot;</span> <span class="hljs-variable">$(files)</span><br></code></pre></td></tr></table></figure><p>会打印出<code>Look at this variable:  file1 file2</code></p><p>双<code>$</code>符号</p><p>如果想表示<code>$</code>这个符号</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># a 是 $b 这个字符串</span><br>a = $$b<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile">make_var = I am a make variable<br><span class="hljs-section">all:</span><br><span class="hljs-comment"># Same as running &quot;sh_var=&#x27;I am a shell variable&#x27;; echo $sh_var&quot; in the shell</span><br>sh_var=&#x27;I am a shell variable&#x27;; echo $$sh_var<br><br><span class="hljs-comment"># Same as running &quot;echo I am a make variable&quot; in the shell</span><br>echo <span class="hljs-variable">$(make_var)</span><br></code></pre></td></tr></table></figure><ul><li>对于<code>echo $$sh_var</code>，实际上等价于<code>echo $sh_var</code></li><li>而<code>echo $(make_var)</code>，实际上等价于<code>echo I am a make variable</code></li></ul><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>wildcard(通配符)</p><p><code>wildcard</code>函数：用于匹配文件名模式，可与<code>*</code>或<code>?</code>配合使用</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 查找当前目录下所有的 .c 文件</span><br>C_FILES := <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.c)</span><br><br><span class="hljs-comment"># 打印找到的 .c 文件列表</span><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-string">&quot;C files: <span class="hljs-variable">$(C_FILES)</span>&quot;</span><br></code></pre></td></tr></table></figure><p><code>*</code>：在文件系统中搜索匹配的文件名，匹配0或多个字符</p><ul><li>注意不要在变量定义中使用<code>*</code></li><li>当<code>*</code>没有匹配任何文件时，它将保持原样（除非在<code>wildcard</code>函数中运行）</li><li>建议<code>*</code>永远与wildcard配合使用</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs makefile">thing_wrong := *.o <span class="hljs-comment"># Don&#x27;t do this! &#x27;*&#x27; will not get expanded</span><br>thing_right := <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.o)</span><br><br><span class="hljs-section">all: one two three four</span><br><br><span class="hljs-comment"># Fails, because $(thing_wrong) is the string &quot;*.o&quot;</span><br><span class="hljs-section">one: <span class="hljs-variable">$(thing_wrong)</span></span><br><br><span class="hljs-comment"># Stays as *.o if there are no files that match this pattern :(</span><br><span class="hljs-section">two: *.o </span><br><br><span class="hljs-comment"># Works as you would expect! In this case, it does nothing.</span><br><span class="hljs-section">three: <span class="hljs-variable">$(thing_right)</span></span><br><br><span class="hljs-comment"># Same as rule three</span><br><span class="hljs-section">four: $(wildcard *.o)</span><br></code></pre></td></tr></table></figure><p><code>%</code></p><ul><li>当在匹配模式下使用时，会匹配字符串中的一个或多个字符</li><li>当在替换模式下使用时，会采用匹配的结果并将其替换在字符串中</li><li>常用于规则定义和特定函数</li></ul><h2 id="auto自动变量"><a href="#auto自动变量" class="headerlink" title="auto自动变量"></a>auto自动变量</h2><p><code>$@</code>：本条规则的目标名</p><p><code>$?</code>：依赖中修改过的文件名</p><p><code>$^</code>：所有依赖文件名，文件名不会重复，不包含order-only依赖 (就是<code>|</code>右边的)</p><p><code>$\*</code>：(简单理解)目标文件名的主干部分(即<u>不包括后缀名</u>)</p><h2 id="伪目标-PHONY"><a href="#伪目标-PHONY" class="headerlink" title="伪目标 .PHONY"></a><strong>伪目标 .PHONY</strong></h2><p>如果一个目标并不是一个文件，则这个目标就是伪目标。例如前面的clean目标。如果说在当前目录下有一个文件名称和这个目标名称冲突了，则这个目标就没法执行。这时候需要用到一个特殊的目标 .PHONY，将上面的clean目标改写如下</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: clean</span><br><span class="hljs-section">clean:</span><br>    rm block.o command.o input.o main.o scene.o test.o<br>    rm sudoku.exe<br></code></pre></td></tr></table></figure><p>这样即使当前目录下存在与目标同名的文件，该目标也能正常执行。</p><p><strong>伪目标的其他应用方式</strong></p><p>如果一条规则的依赖文件没有改动，则不会执行对应的更新方法。如果需要每次不论有没有改动都执行某一目标的更新方法，可以把对应的目标添加到.PHONY的依赖中，例如下面这种方式，则每次执行make都会更新test.o，不管其依赖文件有没有改动</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">test</span>.o: <span class="hljs-keyword">test</span>.cpp <span class="hljs-keyword">test</span>.h<br>        g++ -c <span class="hljs-keyword">test</span>.cpp<br><br>.PHONY: clean <span class="hljs-keyword">test</span>.o<br></code></pre></td></tr></table></figure><h2 id="Makefile读取过程"><a href="#Makefile读取过程" class="headerlink" title="Makefile读取过程"></a><strong>Makefile读取过程</strong></h2><p>GNU make分两个阶段来执行Makefile，第一阶段(读取阶段)：</p><ul><li>读取Makefile文件的所有内容</li><li>根据Makefile的内容在程序内建立起变量</li><li>在程序内构建起显式规则、隐式规则</li><li>建立目标和依赖之间的依赖图</li></ul><p>第二阶段(目标更新阶段)：</p><ul><li>用第一阶段构建起来的数据确定哪个目标需要更新然后执行对应的更新方法</li></ul><p>变量和函数的<strong>展开</strong>（针对<code>$</code>符号）如果发生在第一阶段，就称作<strong>立即展开</strong>（第一阶段读到的时候就展开），否则称为<strong>延迟展开</strong>。立即展开的变量或函数在第一个阶段，也就是Makefile被读取解析的时候就进行展开。延迟展开的变量或函数将会到用到的时候才会进行展开，有以下两种情况：</p><ul><li>在一个立即展开的表达式中用到</li><li>在第二个阶段中用到</li></ul><p><strong>显式规则中，目标和依赖部分都是立即展开，在更新方法中延迟展开</strong></p><p>一个例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile">a = ok<br><br><span class="hljs-comment">#file是=,所以延迟展开</span><br>file = <span class="hljs-variable">$(a)</span><br><br><span class="hljs-section">all:</span><br>@echo <span class="hljs-variable">$(file)</span><br><span class="hljs-comment"># a在第一阶段被覆盖为no，最后echo出no</span><br>a = no<br></code></pre></td></tr></table></figure><h2 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h2><h3 id="递归展开赋值（延迟展开）"><a href="#递归展开赋值（延迟展开）" class="headerlink" title="递归展开赋值（延迟展开）"></a><strong>递归展开赋值（延迟展开）</strong></h3><p>第一种方式就是直接使用=，这种方式如果赋值的时候右边是其他变量引用或者函数调用之类的，将不会做处理，直接保留原样，在使用到该变量的时候再来进行处理得到变量值（Makefile执行的第二个阶段再进行变量展开得到变量值）</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile">bar2 = ThisIsBar2No.1<br>foo = <span class="hljs-variable">$(bar)</span><br>foo2 = <span class="hljs-variable">$(bar2)</span><br><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(foo)</span>  <span class="hljs-comment"># Huh?</span><br>    @echo <span class="hljs-variable">$(foo2)</span>  <span class="hljs-comment"># ThisIsBar2No.2</span><br>    @echo <span class="hljs-variable">$(ugh)</span>   <span class="hljs-comment"># Huh?</span><br><br>bar = <span class="hljs-variable">$(ugh)</span><br>ugh = Huh?<br>bar2 = ThisIsBar2No.2<br></code></pre></td></tr></table></figure><h3 id="简单赋值-立即展开"><a href="#简单赋值-立即展开" class="headerlink" title="简单赋值(立即展开)"></a><strong>简单赋值(立即展开)</strong></h3><p>简单赋值使用:=或::=，这种方式如果等号右边是其他变量或者引用的话，将会在赋值的时候就进行处理得到变量值。（Makefile执行第一阶段进行变量展开）</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile">bar2 := ThisIsBar2No.1<br>foo := <span class="hljs-variable">$(bar)</span><br>foo2 := <span class="hljs-variable">$(bar2)</span><br><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(foo)</span>    <span class="hljs-comment"># 空串，没有内容 ！！</span><br>    @echo <span class="hljs-variable">$(foo2)</span>    <span class="hljs-comment"># ThisIsBar2No.1</span><br>    @echo <span class="hljs-variable">$(ugh)</span>    <span class="hljs-comment"># </span><br><br>bar := <span class="hljs-variable">$(ugh)</span><br>ugh := Huh?<br>bar2 := ThisIsBar2No.2<br></code></pre></td></tr></table></figure><h3 id="条件赋值"><a href="#条件赋值" class="headerlink" title="条件赋值"></a>条件赋值</h3><p>条件赋值使用?=，如果变量已经定义过了（即已经有值了），那么就保持原来的值，如果变量还没赋值过，就把右边的值赋给变量。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">var1 = 100<br>var1 ?= 200<br><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(var1)</span> <span class="hljs-comment"># 100 注释var1 = 100之后为200</span><br></code></pre></td></tr></table></figure><h3 id="Shell运行赋值"><a href="#Shell运行赋值" class="headerlink" title="Shell运行赋值"></a>Shell运行赋值</h3><p>使用<code>!=</code>，运行一个Shell指令后将返回值赋给一个变量</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">gcc_version != gcc --version<br>files != ls .<br></code></pre></td></tr></table></figure><h3 id="追加"><a href="#追加" class="headerlink" title="追加"></a>追加</h3><p> 使用 <code>+=</code> 用于追加</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">foo := start<br>foo += more<br><span class="hljs-comment"># foo变为 start more，中间有个空格</span><br><span class="hljs-section">all: </span><br>echo <span class="hljs-variable">$(foo)</span><br></code></pre></td></tr></table></figure><h2 id="取消变量"><a href="#取消变量" class="headerlink" title="取消变量"></a>取消变量</h2><p>如果想清除一个变量，用以下方法，变量就会变为空</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">undefine</span> &lt;变量名&gt;   如 <span class="hljs-keyword">undefine</span> files,  <span class="hljs-keyword">undefine</span> obj<br></code></pre></td></tr></table></figure><h2 id="变量替换引用"><a href="#变量替换引用" class="headerlink" title="变量替换引用"></a>变量替换引用</h2><p>语法：**$(var:a=b)<strong>，意思是将变量var的值当中每一项</strong>结尾**的a替换为b，直接上例子</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">files = main.cpp hello.cpp<br>objs := $(files:.cpp=.o) <span class="hljs-comment"># main.o hello.o</span><br><span class="hljs-comment"># 另一种写法</span><br>objs := $(files:%.cpp=%.o)<br></code></pre></td></tr></table></figure><h2 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h2><p>所有在Makefile中的变量，都可以在执行make时能过指定参数的方式进行覆盖。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">OverridDemo := ThisIsInMakefile<br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(OverridDemo)</span><br></code></pre></td></tr></table></figure><p>如果直接执行</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">make</span><br></code></pre></td></tr></table></figure><p>则上面的输出内容为<em>ThisIsInMakefile</em>，但可以在执行make时指定参数：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">make <span class="hljs-attribute">OverridDemo</span>=ThisIsFromOutShell # 等号两边不能有空格 !!<br><span class="hljs-comment"># 如果变量值中有空格，需要用引号</span><br>make <span class="hljs-attribute">OverridDemo</span>=“This Is <span class="hljs-keyword">From</span> Out Shell”<br></code></pre></td></tr></table></figure><p>则输出OverridDemo的值是ThisIsFromOutShell或This Is From Out Shell。</p><p>用这样的命令参数会覆盖Makefile中对应变量的值，如果不想被覆盖，可以在变量前加上<strong>override</strong>指令，override具有较高优先级，不会被命令参数覆盖</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">override</span> OverridDemo := ThisIsInMakefile<br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(OverridDemo)</span><br></code></pre></td></tr></table></figure><p>这样即使命令行指定参数，也只会为<code>ThisIsInMakefile</code></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">make <span class="hljs-attribute">OverridDemo</span>=ThisIsFromOutShell<br></code></pre></td></tr></table></figure><h2 id="绑定目标的变量"><a href="#绑定目标的变量" class="headerlink" title="绑定目标的变量"></a>绑定目标的变量</h2><p>Makefile中的变量一般是全局变量。也就是说定义之后在Makefile的任意位置都可以使用。但也可以将变量指定在某个目标的范围内，这样这个变量就只能在这个目标对应的规则里面保用</p><p>语法</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada">target … : <span class="hljs-type">variable</span>-assignment<br>target … : <span class="hljs-type">prerequisites</span><br>    recipes<br>    …<br></code></pre></td></tr></table></figure><p>例</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile">var1 = Global Var<br><br><span class="hljs-section">first: all t2</span><br><br><span class="hljs-section">all: var2 = Target All Var</span><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(var1)</span><br>    @echo <span class="hljs-variable">$(var2)</span><br><br><span class="hljs-section">t2:</span><br>    @echo <span class="hljs-variable">$(var1)</span><br>    @echo <span class="hljs-variable">$(var2)</span><br></code></pre></td></tr></table></figure><h1 id="静态模式规则"><a href="#静态模式规则" class="headerlink" title="静态模式规则"></a>静态模式规则</h1><p>静态模式就是用<code>%</code>进行文件匹配来推导出对应的依赖。</p><p><strong>语法</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">targets …: <span class="hljs-built_in">target-pattern</span>(目标模式): <span class="hljs-built_in">prereq-patterns</span>(依赖模式) …<br>        recipe<br>        …<br></code></pre></td></tr></table></figure><p>一个例子</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objects = foo.o bar.o all.o<br><span class="hljs-section">all: <span class="hljs-variable">$(objects)</span></span><br><br><span class="hljs-comment"># These files compile via implicit rules</span><br><span class="hljs-comment"># Syntax - targets ...: target-pattern: prereq-patterns ...</span><br><span class="hljs-comment"># In the case of the first target, foo.o, the target-pattern matches foo.o and sets the &quot;stem&quot; to be &quot;foo&quot;.</span><br><span class="hljs-comment"># It then replaces the &#x27;%&#x27; in prereq-patterns with that stem</span><br><span class="hljs-variable">$(objects)</span>: %.o: %.c<br><br><span class="hljs-section">all.c:</span><br>echo <span class="hljs-string">&quot;int main() &#123; return 0; &#125;&quot;</span> &gt; all.c<br><br><span class="hljs-section">%.c:</span><br>touch <span class="hljs-variable">$@</span><br><br><span class="hljs-section">clean:</span><br>rm -f *.c *.o all<br></code></pre></td></tr></table></figure><h1 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h1><h2 id="ifeq判断两个值是否相等"><a href="#ifeq判断两个值是否相等" class="headerlink" title="ifeq判断两个值是否相等"></a>ifeq判断两个值是否相等</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs makefile">version = 3.0<br><br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(version)</span>,1.0)            <span class="hljs-comment"># ifeq后一定要一个空格</span><br>    msg := 版本太旧了，请更新版本<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(version)</span>, 3.0)<br>    msg := 版本太新了，也不行<br><span class="hljs-keyword">else</span><br>    msg := 版本可以用<br><span class="hljs-keyword">endif</span><br><br><br><span class="hljs-comment"># 另外的写法</span><br>msg = Other<br><span class="hljs-keyword">ifeq</span> <span class="hljs-string">&quot;<span class="hljs-variable">$(OS)</span>&quot;</span> <span class="hljs-string">&quot;Windows_NT&quot;</span><br>    msg = This is a Windows Platform<br><span class="hljs-keyword">endif</span><br><br><span class="hljs-keyword">ifeq</span> &#x27;<span class="hljs-variable">$(OS)</span>&#x27; &#x27;Windows_NT&#x27;<br><br><span class="hljs-keyword">ifeq</span> &#x27;<span class="hljs-variable">$(OS)</span>&#x27; <span class="hljs-string">&quot;Windows_NT&quot;</span><br></code></pre></td></tr></table></figure><p>还有<code>ifneq</code>，用法相同，只是结果相反</p><h2 id="ifdef判断变量是否已经定义"><a href="#ifdef判断变量是否已经定义" class="headerlink" title="ifdef判断变量是否已经定义"></a>ifdef判断变量是否已经定义</h2><p><code>ifdef</code>不展开变量，他只是查看是否定义了变量</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile">bar =<br>foo = <span class="hljs-variable">$(bar)</span><br><br><span class="hljs-section">all:</span><br><span class="hljs-keyword">ifdef</span> foo<br>echo <span class="hljs-string">&quot;foo is defined&quot;</span><br><span class="hljs-keyword">endif</span><br><span class="hljs-keyword">ifndef</span> bar<br>echo <span class="hljs-string">&quot;but bar is not&quot;</span><br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><h2 id="ifndef-判断一个变量是否没被定义"><a href="#ifndef-判断一个变量是否没被定义" class="headerlink" title="ifndef 判断一个变量是否没被定义"></a><strong>ifndef</strong> 判断一个变量是否没被定义</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">ifndef</span> FLAGS<br>    FLAGS = -finput-charset=utf-8<br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p><strong>调用函数的语法</strong></p><p><code>$(fn, arguments)</code> 或 <code>$&#123;fn, arguments&#125;</code>，注意参数之间不要有空格，如果有空格的话将视为参数的一部分    </p><h2 id="字符替换与分析"><a href="#字符替换与分析" class="headerlink" title="字符替换与分析"></a>字符替换与分析</h2><h4 id="subst"><a href="#subst" class="headerlink" title="subst"></a><strong>subst</strong></h4><p>文本替换函数，返回替换后的文本</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">subst</span> target,replacement,text)</span><br>        --- 在text中，把target替换为replacement<br>        --- target 需要替换的内容<br>        --- replacement 替换为的内容<br>        --- text 需要处理的内容，可以是任意字符串<br><br><br><br>objs = main.o hello.o<br>srcs = <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> .o,.cpp,<span class="hljs-variable">$(objs)</span>)</span><br>headers = <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> .cpp,.h,<span class="hljs-variable">$(srcs)</span>)</span><br><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(srcs)</span><br>    @echo <span class="hljs-variable">$(headers)</span><br></code></pre></td></tr></table></figure><ul><li><p>如果要替换空格或者逗号，使用变量</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile">comma := ,<br>empty:=<br>space := <span class="hljs-variable">$(empty)</span> <span class="hljs-variable">$(empty)</span><br>foo := a b c<br>bar := <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> <span class="hljs-variable">$(space)</span>,<span class="hljs-variable">$(comma)</span>,<span class="hljs-variable">$(foo)</span>)</span><br><br><span class="hljs-section">all: </span><br>@echo <span class="hljs-variable">$(bar)</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="patsubst"><a href="#patsubst" class="headerlink" title="patsubst"></a><strong>patsubst</strong></h4><p>模式替换， 返回替换后的文本</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> pattern,replacement,text)</span><br>        --- pattern 需要替换的模式<br>        --- replacement 需要替换为<br>        --- text 待处理内容，各项内容需要用空格隔开<br><br><br>foo := a.o b.o l.a c.o<br>one := <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.o,%.c,<span class="hljs-variable">$(foo)</span>)</span><br><span class="hljs-comment"># This is a shorthand for the above</span><br>two := $(foo:%.o=%.c)<br><span class="hljs-comment"># This is the suffix-only shorthand, and is also equivalent to the above.</span><br>three := $(foo:.o=.c)<br><br><span class="hljs-section">all:</span><br>echo <span class="hljs-variable">$(one)</span><br>echo <span class="hljs-variable">$(two)</span><br>echo <span class="hljs-variable">$(three)</span>   <br></code></pre></td></tr></table></figure><ul><li>注意上面<code>two</code>和<code>three</code>的简写，也很常用</li></ul><h4 id="strip"><a href="#strip" class="headerlink" title="strip"></a><strong>strip</strong></h4><p>去除字符串头部和尾部的空格，中间如果连续有多个空格，则用一个空格替换，返回去除空格后的文本</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">strip</span> string)</span><br>        --- string 需要去除空格的字符串<br><br><br>files =     hello.cpp      main.cpp     test.cpp<br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">strip</span> <span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="findstring"><a href="#findstring" class="headerlink" title="findstring"></a>findstring</h4><p>查找字符串，如果找到了，则返回对应的字符串，如果没找到，则反回空串</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">findstring</span> find,string)</span><br>        --- find 需要查找的字符串<br>        --- string 用来查找的内容<br><br>files = hello.cpp main.cpp test.cpp<br><span class="hljs-comment">#返回&quot;hel&quot;</span><br>find = <span class="hljs-variable">$(<span class="hljs-built_in">findstring</span> hel,<span class="hljs-variable">$(files)</span>)</span> <br><span class="hljs-comment">#返回空串</span><br>find = <span class="hljs-variable">$(<span class="hljs-built_in">findstring</span> HEL,<span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>从文本中筛选出符合模式的内容并返回</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">filter</span> pattern…,text)</span><br>        --- pattern 模式，可以有多个，用空格隔开<br>        --- text 用来筛选的文本，多项内容需要用空格隔开，否则只会当一项来处理<br><br>files = hello.cpp main.cpp test.cpp main.o hello.o hello.h<br><span class="hljs-comment">#files2:main.o hello.o hello.h</span><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">filter</span> %.o %.h,<span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="filter-out"><a href="#filter-out" class="headerlink" title="filter-out"></a>filter-out</h4><p>与filter相反，过滤掉符合模式的，返回剩下的内容</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">filter</span>-out pattern…,text)</span><br>        --- pattern 模式，可以有多个，用空格隔开<br>        --- text 用来筛选的文本，多项内容需要用空格隔开，否则只会当一项来处理<br><br><br>files = hello.cpp main.cpp test.cpp main.o hello.o hello.h<br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">filter</span>-out %.o %.cpp,<span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>将文本内的各项按字典顺序排列，并且移除重复项</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">sort</span> list)</span><br>        --- list 需要排序内容<br><br><br>files = hello.cpp main.cpp test.cpp main.o hello.o hello.h main.cpp hello.cpp<br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">sort</span> <span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="word"><a href="#word" class="headerlink" title="word"></a>word</h4><p>用于返回文本中第n个单词 (注意下标从1开始的，不是0)</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">word</span> n,text)</span><br>        --- n 第n个单词，从1开始，如果n大于总单词数，则返回空串<br>        --- text 待处理文本<br><br>files = hello.cpp main.cpp test.cpp main.o hello.o hello.h main.cpp hello.cpp<br><span class="hljs-comment">#files2:test.cpp</span><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">word</span> 3,<span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="wordlist"><a href="#wordlist" class="headerlink" title="wordlist"></a>wordlist</h4><p>用于返回文本指定范围内的单词列表</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">wordlist</span> start,end,text)</span><br>        --- start 起始位置，如果大于单词总数，则返回空串<br>        --- end 结束位置，如果大于单词总数，则返回起始位置之后全部，如果start &gt; end，什么都不返回<br><br>files = hello.cpp main.cpp test.cpp main.o hello.o hello.h main.cpp hello.cpp<br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">wordlist</span> 3,6,<span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="words"><a href="#words" class="headerlink" title="words"></a>words</h4><p>返回文本中单词数</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(words text)</span><br>        --- text 需要处理的文本<br><br><br>files = hello.cpp main.cpp test.cpp main.o hello.o hello.h main.cpp hello.cpp<br>nums = <span class="hljs-variable">$(words <span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="firstword"><a href="#firstword" class="headerlink" title="firstword"></a>firstword</h4><p>返回第一个单词</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">firstword</span> <span class="hljs-params">text</span>)</span><br></code></pre></td></tr></table></figure><h4 id="lastword"><a href="#lastword" class="headerlink" title="lastword"></a>lastword</h4><p>返回最后一个单词</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">lastword</span> <span class="hljs-params">text</span>)</span><br></code></pre></td></tr></table></figure><h2 id="文件名处理函数"><a href="#文件名处理函数" class="headerlink" title="文件名处理函数"></a>文件名处理函数</h2><h4 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h4><p>返回文件目录</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">dir</span> files)</span><br>        --- files 需要返回目录的文件名，可以有多个，用空格隔开<br><br>files = src/hello.cpp main.cpp<br><span class="hljs-comment">#files2:src/ ./</span><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">dir</span> <span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="notdir"><a href="#notdir" class="headerlink" title="notdir"></a>notdir</h4><p>返回除目录部分的文件名</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">notdir</span> files)</span><br>        --- files 需要返回文件列表，可以有多个，用空格隔开<br><br>files = src/hello.cpp main.cpp<br><span class="hljs-comment">#files2:hello.cpp main.cpp</span><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">notdir</span> <span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="suffix"><a href="#suffix" class="headerlink" title="suffix"></a>suffix</h4><p>返回文件后缀名，如果没有后缀返回空</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">suffix</span> files)</span><br>        --- files 需要返回后缀的文件名，可以有多个，用空格隔开<br><br><br>files = src/hello.cpp main.cpp hello.o hello.hpp hello<br><span class="hljs-comment">#files2:.cpp .cpp .o .hpp</span><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">suffix</span> <span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="basename"><a href="#basename" class="headerlink" title="basename"></a>basename</h4><p>返回文件名除后缀的部分</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">basename</span> files)</span><br>        --- files 需要返回的文件名，可以有多个，用空格隔开<br><br><br>files = src/hello.cpp main.cpp hello.o hello.hpp hello<br><span class="hljs-comment">#files2:src/hello main hello hello hello</span><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">basename</span> <span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="addsuffix"><a href="#addsuffix" class="headerlink" title="addsuffix"></a>addsuffix</h4><p>给文件名添加后缀</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">addsuffix</span> <span class="hljs-built_in">suffix</span>,files)</span><br>        --- suffix 需要添加的后缀<br>        --- files 需要添加后缀的文件名，可以有多个，用空格隔开<br><br>files = src/hello.cpp main.cpp hello.o hello.hpp hello<br><span class="hljs-comment">#files2:src/hello.cpp.exe main.cpp.exe hello.o.exe hello.hpp.exe hello.exe</span><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">addsuffix</span> .exe,<span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="addprefix"><a href="#addprefix" class="headerlink" title="addprefix"></a>addprefix</h4><p>给文件名添加前缀</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> prefix,files)</span><br>        --- prefix 需要添加的前缀<br>        --- files 需要添加前缀的文件名，可以有多个，用空格隔开<br><br>files = src/hello.cpp main.cpp hello.o hello.hpp hello<br><span class="hljs-comment">#files2:make/src/hello.cpp make/main.cpp make/hello.o make/hello.hpp make/hello</span><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> make/,<span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p>将两个列表中的内容一对一连接，如果两个列表内容数量不相等，则多出来的部分原样返回，注意是有顺序之分的，比如下面这个例子如果改为<code>files2 = $(join $(f2),$(f1))</code>，结果是相反的</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">join</span> list1,list2)</span><br>        --- list1 第一个列表<br>        --- list2 需要连接的第二个列表<br><br><br>f1 = hello main test<br>f2 = .cpp .hpp<br><span class="hljs-comment">#files2:hello.cpp main.hpp test</span><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">join</span> <span class="hljs-variable">$(f1)</span>,<span class="hljs-variable">$(f2)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="wildcard"><a href="#wildcard" class="headerlink" title="wildcard"></a>wildcard</h4><p>返回符合通配符的文件列表</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> pattern)</span><br>        --- pattern 通配符<br><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.cpp)</span><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *)</span><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> src/*.cpp)</span><br></code></pre></td></tr></table></figure><h4 id="realpath"><a href="#realpath" class="headerlink" title="realpath"></a>realpath</h4><p>返回文件的绝对路径</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">realpath</span> files)</span><br>        --- files 需要返回绝对路径的文件，可以有多个，用空格隔开<br><br>f3 = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> src/*)</span><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">realpath</span> <span class="hljs-variable">$(f3)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="abspath"><a href="#abspath" class="headerlink" title="abspath"></a>abspath</h4><p>返回绝对路径，用法同realpath，如果一个文件名不存在，realpath不会返回内容，abspath则会返回一个当前文件夹一下的绝对路径</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">abspath</span> <span class="hljs-params">files</span>)</span><br></code></pre></td></tr></table></figure><h2 id="条件函数"><a href="#条件函数" class="headerlink" title="条件函数"></a>条件函数</h2><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><p><code>if</code> 检查第一个参数是否为<strong>非空</strong>。如果是这样，则运行第二个参数，否则运行第三个参数</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">if</span> condition,then-part[,else-part])</span><br>        --- condition 条件部分<br>        --- then-part 条件为真时执行的部分<br>        --- else-part 条件为假时执行的部分，如果省略则为假时返回空串<br><br>files = src/hello.cpp main.cpp hello.o hello.hpp hello<br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">if</span> <span class="hljs-variable">$(files)</span>,有文件,没有文件)</span><br></code></pre></td></tr></table></figure><h4 id="or"><a href="#or" class="headerlink" title="or"></a>or</h4><p>返回条件中第一个不为空的部分</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">or</span> condition1[,condition2[,condition3…]])</span><br><br>f1 = <br>f2 = <br>f3 = hello.cpp<br>f4 = main.cpp<br><span class="hljs-comment">#files2:hello.cpp</span><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">or</span> <span class="hljs-variable">$(f1)</span>,<span class="hljs-variable">$(f2)</span>,<span class="hljs-variable">$(f3)</span>,<span class="hljs-variable">$(f4)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="and"><a href="#and" class="headerlink" title="and"></a>and</h4><p>如果条件中有一个为空串，则返回空，如果全都不为空，则返回最后一个条件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">and</span> condition1[,condition2[,condition3…]])</span><br><br>f1 = 12<br>f2 = 34<br>f3 = hello.cpp<br>f4 = main.cpp<br><span class="hljs-comment">#files2:main.cpp</span><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">and</span> <span class="hljs-variable">$(f1)</span>,<span class="hljs-variable">$(f2)</span>,<span class="hljs-variable">$(f3)</span>,<span class="hljs-variable">$(f4)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="intcmp"><a href="#intcmp" class="headerlink" title="intcmp"></a>intcmp</h4><p>比较两个整数大小，并返回对应操作结果（GNU make 4.4以上版本）</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(intcmp lhs,rhs[,lt-part[,eq-part[,gt-part]]])</span> <br>        --- lhs 第一个数<br>        --- rhs 第二个数<br>        --- lt-part  lhs &lt; rhs时执行<br>        --- eq-part  lhs = rhs时执行<br>        --- gt-part  lhs &gt; rhs时执行<br>        --- 如果只提供前两个参数，则lhs == rhs时返回数值，否则返回空串<br>            参数为lhs,rhs,lt-part时，当lhs &lt; rhs时返回lt-part结果，否则返回空<br>            参数为lhs,rhs,lt-part,eq-part，lhs &lt; rhs返回lt-part结果，否则都返回eq-part结果<br>            参数全时，lhs &lt; rhs返回lt-part，lhs == rhs返回eq-part, lhs &gt; rhs返回gt-part<br><br><br><br>@echo <span class="hljs-variable">$(intcmp 2,2,-1,0,1)</span><br></code></pre></td></tr></table></figure><h2 id="file"><a href="#file" class="headerlink" title="file"></a>file</h2><p>读写文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">file</span> op filename[,text])</span><br>        --- op 操作<br>                &gt; 覆盖<br>                &gt;&gt; 追加<br>                &lt; 读<br>        --- filename 需要操作的文件名<br>        --- text 写入的文本内容，读取是不需要这个参数<br><br><br>files = src/hello.cpp main.cpp hello.o hello.hpp hello<br>write = <span class="hljs-variable">$(<span class="hljs-built_in">file</span> &gt; makewrite.txt,<span class="hljs-variable">$(files)</span>)</span><br>read = <span class="hljs-variable">$(<span class="hljs-built_in">file</span> &lt; makewrite.txt)</span><br></code></pre></td></tr></table></figure><h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><p>对一列用空格隔开的字符序列中每一项进行处理，并返回处理后的列表（将一个单词列表（用空格分隔）转换为另一个单词列表）</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> each,list,process)</span><br>        --- each list中的每一项<br>        --- list 需要处理的字符串序列，用空格隔开<br>        --- process 需要对每一项进行的处理<br><br>foo := who are you<br><span class="hljs-comment"># For each &quot;word&quot; in foo, output that same word with an exclamation after</span><br>bar := <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> wrd,<span class="hljs-variable">$(foo)</span>,<span class="hljs-variable">$(wrd)</span>!)</span><br><span class="hljs-section">all:</span><br><span class="hljs-comment"># Output is &quot;who! are! you!&quot;</span><br>@echo <span class="hljs-variable">$(bar)</span><br><br>list = 1 2 3 4 5<br>result = <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> each,<span class="hljs-variable">$(list)</span>,$(<span class="hljs-built_in">addprefix</span> cpp,$(<span class="hljs-built_in">addsuffix</span> .cpp,<span class="hljs-variable">$(each)</span>)</span>))<br></code></pre></td></tr></table></figure><p>第二个例子作用类似C/C++中的循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> list[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span> result[<span class="hljs-number">5</span>];<br><span class="hljs-type">int</span> each;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>&#123;<br>    each = list[i];<br>    result[i] = <span class="hljs-built_in">process</span>(each);<br>&#125;<br><span class="hljs-comment">// 此时result即为返回结果</span><br></code></pre></td></tr></table></figure><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><ul><li>Make支持创建函数，可以通过创建变量来定义函数，但使用参数 <code>$(0)</code> 、 <code>$(1)</code> 等，<code>$(0)</code> 是变量，而 <code>$(1)</code> 、 <code>$(2)</code> 等是参数</li></ul><p>将一些复杂的表达式写成一个变量，用call可以像调用函数一样进行调用。类似于编程语言中的自定义函数。在函数中可以用$(n)来访问第n个参数</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">call</span> funcname,param1,param2,…)</span><br>        --- funcname 自定义函数（变量名）<br>        --- 参数至少一个，可以有多个，用逗号隔开<br><br>sweet_new_fn = Variable Name: $(0) First: $(1) Second: $(2) Empty Variable: $(3)<br><br><span class="hljs-section">all:</span><br><span class="hljs-comment"># Outputs &quot;Variable Name: sweet_new_fn First: go Second: tigers Empty Variable:&quot;</span><br>@echo <span class="hljs-variable">$(<span class="hljs-built_in">call</span> sweet_new_fn, go, tigers)</span><br></code></pre></td></tr></table></figure><h2 id="value"><a href="#value" class="headerlink" title="value"></a>value</h2><p>对于不是立即展开的变量，可以查看变量的原始定义；对于立即展开的变量，直接返回变量值</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">value</span> variable)</span><br><br>var = value function test<br>var2 = <span class="hljs-variable">$(var)</span><br>var3 := <span class="hljs-variable">$(var)</span><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">value</span> var2)</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">value</span> var3)</span><br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>查看一个变量定义来源</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">origin</span> variable)</span><br><br><br>var2 = origin function <br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">origin</span> var1)</span>    <span class="hljs-comment"># undefined 未定义</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">origin</span> CC)</span>        <span class="hljs-comment"># default 默认变量</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">origin</span> JAVA_HOME)</span> <span class="hljs-comment"># environment 环境变量</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">origin</span> var2)</span>    <span class="hljs-comment"># file 在Makefile文件中定义的变量</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">origin</span> @)</span>        <span class="hljs-comment"># automatic 自动变量</span><br></code></pre></td></tr></table></figure><h2 id="flavor"><a href="#flavor" class="headerlink" title="flavor"></a>flavor</h2><p>查看一个变量的赋值方式</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">flavor</span> variable)</span><br><br>var2 = flavor function<br>var3 := flavor funciton<br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">flavor</span> var1)</span>    <span class="hljs-comment"># undefined 未定义</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">flavor</span> var2)</span>    <span class="hljs-comment"># recursive 递归展开赋值</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">flavor</span> var3)</span>    <span class="hljs-comment"># simple 简单赋值</span><br></code></pre></td></tr></table></figure><h2 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h2><p>可以将一段文本生成Makefile的内容</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">eval</span> text)</span><br><br><span class="hljs-keyword">define</span> eval_target = <br><span class="hljs-section">eval:</span><br>    @echo Target Eval Test<br><span class="hljs-keyword">endef</span><br><br><span class="hljs-variable">$(<span class="hljs-built_in">eval</span> <span class="hljs-variable">$(eval_target)</span>)</span><br></code></pre></td></tr></table></figure><p>以上，运行make时将会执行eval目标，输出<code>Target Eval Test</code></p><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>用于执行Shell命令</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">files = <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> ls *.cpp)</span><br><span class="hljs-variable">$(<span class="hljs-built_in">shell</span> echo This is from <span class="hljs-built_in">shell</span> function)</span><br></code></pre></td></tr></table></figure><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p>将一个字符串序列中的项拆开放入多个变量中，并对各个变量进行操作（GNU make 4.4以上版本），有点像rust里的解构</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(let var1 [var2 ...],[list],proc)</span><br>        --- var 变量，可以有多个，用空格隔开<br>        --- list 待处理字符串，各项之间空格隔开<br>        --- proc 对变量进行的操作，结果为let的返回值<br>            将list中的值依次一项一项放到var中，如果var的个数多于list项数，那多出来的var是空串。如果<br>            var的个数小于list项数，则先依次把前而的项放入var中，剩下的list所有项都放入最后一个var中<br><br><br>list = a b c d<br>letfirst = <span class="hljs-variable">$(let first second rest,<span class="hljs-variable">$(list)</span>,<span class="hljs-variable">$(first)</span>)</span><br>letrest = <span class="hljs-variable">$(let first second rest,<span class="hljs-variable">$(list)</span>,<span class="hljs-variable">$(rest)</span>)</span><br><br><br><span class="hljs-comment"># 结合call可以对所有项进行递归处理</span><br>reverse = <span class="hljs-variable">$(let first rest,$(1)</span>,<span class="hljs-variable">$(<span class="hljs-built_in">if</span> <span class="hljs-variable">$(rest)</span>,$(<span class="hljs-built_in">call</span> reverse,<span class="hljs-variable">$(rest)</span>)</span> )<span class="hljs-variable">$(first)</span>)<br><span class="hljs-section">all: ; @echo $(call reverse,d c b a)</span><br></code></pre></td></tr></table></figure><h2 id="信息提示函数"><a href="#信息提示函数" class="headerlink" title="信息提示函数"></a>信息提示函数</h2><h4 id="error"><a href="#error" class="headerlink" title="error"></a>error</h4><p>提示错误信息并终止make执行</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">error</span> text)</span><br>        --- text 提示信息<br><br>EXIT_STATUS = -1<br><span class="hljs-keyword">ifneq</span> (0, <span class="hljs-variable">$(EXIT_STATUS)</span>)<br>    <span class="hljs-variable">$(<span class="hljs-built_in">error</span> An <span class="hljs-built_in">error</span> occured! make stopped!)</span><br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><h4 id="warning"><a href="#warning" class="headerlink" title="warning"></a>warning</h4><p>提示警告信息，make不会终止</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">warning</span> text)</span><br><br><span class="hljs-keyword">ifneq</span> (0, <span class="hljs-variable">$(EXIT_STATUS)</span>)<br>    <span class="hljs-variable">$(<span class="hljs-built_in">warning</span> This is a <span class="hljs-built_in">warning</span> message)</span><br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><h4 id="info"><a href="#info" class="headerlink" title="info"></a>info</h4><p>输出一些信息</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(info text…)</span><br><br><span class="hljs-variable">$(info 编译开始.......)</span><br><span class="hljs-variable">$(info 编译结束)</span><br></code></pre></td></tr></table></figure><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>试试分析一下这个rust的makefile把，来自rCore</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs makefile">TARGET := riscv64gc-unknown-none-elf<br>MODE := release<br>APP_DIR := src/bin<br>TARGET_DIR := target/<span class="hljs-variable">$(TARGET)</span>/<span class="hljs-variable">$(MODE)</span><br>BUILD_DIR := build<br>OBJDUMP := rust-objdump --arch-name=riscv64<br>OBJCOPY := rust-objcopy --binary-architecture=riscv64<br>PY := python3<br><br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(MODE)</span>, release)<br>MODE_ARG := --release<br><span class="hljs-keyword">endif</span><br><br>BASE ?= 0<br>CHAPTER ?= 0<br>TEST ?= <span class="hljs-variable">$(CHAPTER)</span><br><br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(TEST)</span>, 0) <span class="hljs-comment"># No test, deprecated, previously used in v3</span><br>APPS :=  <span class="hljs-variable">$(<span class="hljs-built_in">filter</span>-out $(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(APP_DIR)</span>/ch*.rs)</span>, <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(APP_DIR)</span>/*.rs)</span>)<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(TEST)</span>, 1) <span class="hljs-comment"># All test</span><br>APPS :=  <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(APP_DIR)</span>/ch*.rs)</span><br><span class="hljs-keyword">else</span><br>TESTS := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> seq <span class="hljs-variable">$(BASE)</span> <span class="hljs-variable">$(TEST)</span>)</span><br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(BASE)</span>, 0) <span class="hljs-comment"># Normal tests only</span><br>APPS := <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> T, <span class="hljs-variable">$(TESTS)</span>, $(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(APP_DIR)</span>/ch<span class="hljs-variable">$(T)</span>_*.rs)</span>)<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(BASE)</span>, 1) <span class="hljs-comment"># Basic tests only</span><br>APPS := <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> T, <span class="hljs-variable">$(TESTS)</span>, $(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(APP_DIR)</span>/ch<span class="hljs-variable">$(T)</span>b_*.rs)</span>)<br><span class="hljs-keyword">else</span> <span class="hljs-comment"># Basic and normal</span><br>APPS := <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> T, <span class="hljs-variable">$(TESTS)</span>, $(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(APP_DIR)</span>/ch<span class="hljs-variable">$(T)</span>*.rs)</span>)<br><span class="hljs-keyword">endif</span><br><span class="hljs-keyword">endif</span><br><br>ELFS := <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> <span class="hljs-variable">$(APP_DIR)</span>/%.rs, <span class="hljs-variable">$(TARGET_DIR)</span>/%, <span class="hljs-variable">$(APPS)</span>)</span><br><br><span class="hljs-section">binary:</span><br>@echo <span class="hljs-variable">$(ELFS)</span><br>@if [ $&#123;CHAPTER&#125; -gt 3 ]; then \<br>cargo build <span class="hljs-variable">$(MODE_ARG)</span> ;\<br><span class="hljs-keyword">else</span> \<br>CHAPTER=<span class="hljs-variable">$(CHAPTER)</span> python3 build.py ;\<br>fi<br>@<span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> elf, <span class="hljs-variable">$(ELFS)</span>, \</span><br><span class="hljs-variable"><span class="hljs-variable">$(OBJCOPY)</span> <span class="hljs-variable">$(elf)</span> --<span class="hljs-built_in">strip</span>-all -O binary $(<span class="hljs-built_in">patsubst</span> <span class="hljs-variable">$(TARGET_DIR)</span>/%, <span class="hljs-variable">$(TARGET_DIR)</span>/%.bin, <span class="hljs-variable">$(elf)</span>)</span>; \<br>cp <span class="hljs-variable">$(elf)</span> <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> <span class="hljs-variable">$(TARGET_DIR)</span>/%, <span class="hljs-variable">$(TARGET_DIR)</span>/%.elf, <span class="hljs-variable">$(elf)</span>)</span>;)<br><br><span class="hljs-section">disasm:</span><br>@<span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> elf, <span class="hljs-variable">$(ELFS)</span>, \</span><br><span class="hljs-variable"><span class="hljs-variable">$(OBJDUMP)</span> <span class="hljs-variable">$(elf)</span> -S &gt; $(<span class="hljs-built_in">patsubst</span> <span class="hljs-variable">$(TARGET_DIR)</span>/%, <span class="hljs-variable">$(TARGET_DIR)</span>/%.asm, <span class="hljs-variable">$(elf)</span>)</span>;)<br>@<span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> t, <span class="hljs-variable">$(ELFS)</span>, cp <span class="hljs-variable">$(t)</span>.asm <span class="hljs-variable">$(BUILD_DIR)</span>/asm/;)</span><br><br><span class="hljs-section">pre:</span><br>@mkdir -p <span class="hljs-variable">$(BUILD_DIR)</span>/bin/<br>@mkdir -p <span class="hljs-variable">$(BUILD_DIR)</span>/elf/<br>@mkdir -p <span class="hljs-variable">$(BUILD_DIR)</span>/app/<br>@mkdir -p <span class="hljs-variable">$(BUILD_DIR)</span>/asm/<br>@<span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> t, <span class="hljs-variable">$(APPS)</span>, cp <span class="hljs-variable">$(t)</span> <span class="hljs-variable">$(BUILD_DIR)</span>/app/;)</span><br><br><span class="hljs-section">build: clean pre binary</span><br>@<span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> t, <span class="hljs-variable">$(ELFS)</span>, cp <span class="hljs-variable">$(t)</span>.bin <span class="hljs-variable">$(BUILD_DIR)</span>/bin/;)</span><br>@<span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> t, <span class="hljs-variable">$(ELFS)</span>, cp <span class="hljs-variable">$(t)</span>.elf <span class="hljs-variable">$(BUILD_DIR)</span>/elf/;)</span><br><br><span class="hljs-section">clean:</span><br>@cargo clean<br>@rm -rf <span class="hljs-variable">$(BUILD_DIR)</span><br><br><span class="hljs-section">all: build</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: elf binary build clean all</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Makefile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rCore-Blog</title>
    <link href="/2023/12/02/rCore-Blog/"/>
    <url>/2023/12/02/rCore-Blog/</url>
    
    <content type="html"><![CDATA[<p>2023 秋 rCore 训练营个人存档：二三阶段优秀</p><span id="more"></span><h1 id="二阶段实验总结"><a href="#二阶段实验总结" class="headerlink" title="二阶段实验总结"></a>二阶段实验总结</h1><h2 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a>lab1</h2><p>目的就是实现三个信息的统计</p><h3 id="status-TaskStatus"><a href="#status-TaskStatus" class="headerlink" title="status: TaskStatus"></a>status: TaskStatus</h3><ul><li>按照提示直接设置为running</li></ul><h3 id="syscall-times-u32-MAX-SYSCALL-NUM"><a href="#syscall-times-u32-MAX-SYSCALL-NUM" class="headerlink" title="[syscall_times: [u32; MAX_SYSCALL_NUM]"></a>[syscall_times: [u32; MAX_SYSCALL_NUM]</h3><ul><li>第一次尝试直接在sys_task_info来加载，发现好像不行，因为不知道传入的ti: *mut TaskInfo，这个参数到底在哪里被初始化的，而且每个任务都需要有一个syscall_times数组</li><li>由此我在<code>TaskControBlock</code>中维护一个<code>pub task_syscall_times: [u32; MAX_SYSCALL_NUM]</code>数组，这样通过全局遍历TASK_MANAGER可以很好的在每次系统调用时更新</li><li>更新位置在<code>trap_handler</code>进入<code>syscall之前</code>，读取x17寄存器为syscall id</li></ul><h3 id="time-usize"><a href="#time-usize" class="headerlink" title="time: usize"></a>time: usize</h3><ul><li><p>需要得到的是从第一次运行到现在的时间，现在的时间可以通过<code>get_time_ms</code>直接获得</p></li><li><p>第一次运行开始的时间，需要在应用第一次变成Running态的时候记载，因此我们为每个</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">TaskControBlock</span><br></code></pre></td></tr></table></figure><p>中维护</p><ul><li><code>pub task_start: usize,</code> 记录任务第一次开始的时间</li><li><code>pub task_flag: bool,</code> 标志是否为第一次，如果是就是false，然后我们更新<code>task_start</code>，并且将该变量置为false，保证只记录一次start time</li></ul></li></ul><h2 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h2><p>直接&lt;&lt;12直接这样会报错overflow，但是那个函数确实就是干了这个事情，只是我帮他弄了一把，很奇怪，还是最后用函数了</p><p>taskInfo报错，按照群里大佬这样修改，但不知道为什么这样修改</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//原</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_time_us</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>    time::<span class="hljs-title function_ invoke__">read</span>() / (CLOCK_FREQ / MICRO_PER_SEC)<br>&#125;<br><span class="hljs-comment">//修改为</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_time_us</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>    time::<span class="hljs-title function_ invoke__">read</span>() * MICRO_PER_SEC / CLOCK_FREQ<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><ol><li><code>vpn_end</code>计算有问题，len需要/8吗：不需要，因为VA就是取最低39位，不会左移右移啥的</li><li>上取整，如果已经对齐的情况下还会上取整吗：回答，不会的</li></ol><h3 id="bug与问题"><a href="#bug与问题" class="headerlink" title="bug与问题"></a>bug与问题</h3><ol><li>对于判断是否mapped过，只考虑了<code>find_pte</code>不能为<code>None</code>，没有考虑<code>find_pte</code>存在，但是<code>pte.is_valid()</code>不合法这件事，卡了很久，也不好调试</li><li>MapPermission不好进行零初始化，那么就用match，但是match要解决穷尽匹配，我们先把不合法的删去，然后最后一个_只代表<code>6</code>的情况</li><li>对题意理解有问题，在mmap中，我以为如果start和end之间有已经被映射的页，我们还是需要分配len这么长，也就是不error，映射一段不连续的虚拟内存，写了比较复杂，后面才知道直接error</li><li>这章很难debug，看样子甚至是多线程跑测试，所以花费很多时间</li></ol><h2 id="lab3"><a href="#lab3" class="headerlink" title="lab3"></a>lab3</h2><h3 id="继承上一章修改"><a href="#继承上一章修改" class="headerlink" title="继承上一章修改"></a>继承上一章修改</h3><p>今天上下午一直在移植代码，尝试了<code>git cherry-pick</code>试了很久，重置过去重置过来，问了gpt，看了b站，csdn都无果，就是没有合并，只显示reports文件夹有冲突，主要的os没有，遂还是采用<code>git diff</code>打patch的笨方法，冲突太多了，合并了小一个小时。</p><h3 id="修理waitpid"><a href="#修理waitpid" class="headerlink" title="修理waitpid"></a>修理waitpid</h3><p>移植好之后，<code>make run</code>确实能跑了，但是随便输一个就报错，说<code>waitpid</code>清除僵尸进程的引用计数有错，本来应该是1，结果是2，多了一个，debug找不出来，println也没看出来在哪里。仔细想想，找了跟<code>Arc</code>有关的所有代码，可以肯定一件事，模板代码一定没问题，那问题就出在我自己移植过来的代码，最后一个个注释排除法，找到了原来是我自己用了一个Arc没有drop，我以为drop了inner的RefMut就可以了，没想到这个也要drop。为啥这个不会自动drop呢？</p><p>目前还有usertest卡住的问题，再看看。</p><h3 id="spawn"><a href="#spawn" class="headerlink" title="spawn"></a>spawn</h3><p>通过注释发现卡住的原因是spawn的实现有问题，重点在维护父子关系，注意<code>drop</code>的位置</p><ul><li>spawn就是新建一个进程而已，不要想着用fork+exec，之前直接调用fork()和exec()会出问题，也不好调试，于是自己仿照fork内容与exec自己实现</li></ul><h3 id="stride"><a href="#stride" class="headerlink" title="stride"></a>stride</h3><p>stride感觉倒是很简单，根据提示BIG_STRIDE需要大一点，于是把BIG_STRIDE设置为了0x100000，然后每次调度的时候，都要fetch_task，于是在这里找出最小的stride返回，pass的维护在set_piro里面实现，因为prio只会在这里修改</p><h2 id="lab4"><a href="#lab4" class="headerlink" title="lab4"></a>lab4</h2><p>这章我真的心累了，调试了两天，目前还是有一个神奇的bug，我觉得不是我代码的问题</p><p>在<code>ch6_file2</code>里面：我做了如下修改，//后的就是新加入的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust">   <span class="hljs-keyword">let</span> <span class="hljs-variable">test_str</span> = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br>   <span class="hljs-keyword">let</span> <span class="hljs-variable">fname</span> = <span class="hljs-string">&quot;fname2\0&quot;</span>;<br>   <span class="hljs-keyword">let</span> (lname0, lname1, lname2) = (<span class="hljs-string">&quot;linkname0\0&quot;</span>, <span class="hljs-string">&quot;linkname1\0&quot;</span>, <span class="hljs-string">&quot;linkname2\0&quot;</span>);<br>   <span class="hljs-keyword">let</span> <span class="hljs-variable">fd</span> = <span class="hljs-title function_ invoke__">open</span>(fname, OpenFlags::CREATE | OpenFlags::WRONLY) <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>;<br><span class="hljs-comment">//</span><br>   <span class="hljs-keyword">let</span> <span class="hljs-variable">fd1</span> = <span class="hljs-title function_ invoke__">open</span>(lname0, OpenFlags::CREATE | OpenFlags::WRONLY) <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>;<br><span class="hljs-comment">//</span><br>   <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;ok1&quot;</span>);<br>   <span class="hljs-comment">//此处传入的lname0是0x0，为什么</span><br>   <span class="hljs-title function_ invoke__">link</span>(fname, lname0);<br><span class="hljs-comment">//</span><br>   <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;ok2&quot;</span>);<br>...<br></code></pre></td></tr></table></figure><p>发现在 link(fname, lname0);   //此处传入的lname0是<strong>0x0</strong>，为什么，看运行结果(在open系统调用和link加入了println!打印传入str的地址)，部分结果如下</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">open</span>:<span class="hljs-type">path</span>  <span class="hljs-keyword">is</span> <span class="hljs-number">0x42cd</span><br><span class="hljs-keyword">open</span>:<span class="hljs-type">path</span>  <span class="hljs-keyword">is</span> <span class="hljs-number">0x42d4</span><br>ok1<br>link:<span class="hljs-built_in">old</span> <span class="hljs-type">name</span> addr <span class="hljs-keyword">is</span> <span class="hljs-number">0x42cd</span><br>link:<span class="hljs-built_in">new</span> <span class="hljs-type">name</span> addr is0x0<br>old_name is6 ,new_name is45 <br>[kernel] Panicked at /root/<span class="hljs-number">2023</span>a-rcore-Ywinh/easy-fs/src/layout.rs:<span class="hljs-number">419</span> range <span class="hljs-keyword">end</span> <span class="hljs-keyword">index</span> <span class="hljs-number">45</span> <span class="hljs-keyword">out</span> <span class="hljs-keyword">of</span> range <span class="hljs-keyword">for</span> <span class="hljs-keyword">slice</span> <span class="hljs-keyword">of</span> length <span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><p>可以看到<code>lname</code>对应的<code>new name</code>在open里面的地址是<code>0x42d4</code>,但是在link里面是<code>0x0</code>，就是这个bug让我以为我的<code>link</code>出错了，改了一整天，后面copy别人的代码也不行，真的心累了。。请教了群里的一位大佬，还没回我，希望能解决…</p><p>解决！syscall 陷入时参数写错了，这个是 git cherry pick的时候自动覆盖掉了，很坑爹</p><p><strong>自己对于rust的理解还是不够，还是要在实践中多用，但很感谢能通过这个机会锻炼自己~~</strong></p><h1 id="三阶段总结"><a href="#三阶段总结" class="headerlink" title="三阶段总结"></a>三阶段总结</h1><p><strong>调试技巧：使用用户态 qemu 进行对拍</strong></p><p>测例库里编译的测例都是完全符合规范的 <code>RISC-V</code> 可执行程序，所以它当然可以在其他内核上运行。</p><p>如果你还记得，在 <code>rCore-Tutorial</code>的 <code>ch0</code>配环境的时候，安装了 <code>qemu-riscv64</code> 和 <code>qemu-system-riscv64</code>。后者用于运行实验，而前者实际上是一个用户态模拟器。换而言之，它可以直接运行用户态的 <code>RISC-V</code> 程序，我们可以直接把测例文件扔给它。</p><p>例如在 <code>testcases/</code> 目录下执行 <code>qemu-riscv64 ./build/hello</code>，就可以获取正确输出（可以打开 <code>testcases/src/hello.c</code> 看看正确输出长什么样）。</p><p>同样地，也可以执行 <code>qemu-riscv64 ./build/42</code>。这个用户程序在退出时返回了一个 <code>42</code>，不过没有打印输出。但我们可以在上面的命令之后立即执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> $?<br></code></pre></td></tr></table></figure><p>就可以看到返回值 <code>42</code></p><blockquote><p><code>$?</code> 是一个shell的变量，表示上一条命令的返回值。</p><p>在这个例子中，具体来说是 <code>qemu</code> 的返回值。它执行了我们要求的用户程序，然后把用户程序的返回值作为自己的返回值，推给宿主机。</p></blockquote><p>如此一来，后续我们每次遇到一个新的应用程序，就可以用 <code>qemu-riscv64</code> 进行检查，看看正常的“内核”运行它应该是什么样的，然后来推测我们的内核运行同一个测例时出了什么错。</p><p>我们把这种调试方式叫做“对拍”。</p><h2 id="lab1-1"><a href="#lab1-1" class="headerlink" title="lab1"></a>lab1</h2><h3 id="修改hello测例"><a href="#修改hello测例" class="headerlink" title="修改hello测例"></a>修改hello测例</h3><p>首先运行hello后，发现输出<code>Incorrect argc</code>，点进hello.c里面查看，发现是<code>argc</code>传入不对，结合实验书测例库里面，对于c语言和rCore的用户栈排布不一样，推测应该是这个原因，造成c语言里面传入的argc不是想要的参数</p><p>于是阅读ch7的命令行参数这一章节，了解了sys_exec是如何把命令行参数压入用户栈，以及用户库如何从用户栈上还原命令行参数</p><p>那么接下来就是找出C语言规定栈和rCore栈的区别了，为了方便把指导书上栈展示的顺序从低到高改为从高到低</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs prolog">position            content                     size (bytes)<br>  ------------------------------------------------------------------------<br>  stack pointer -&gt;  [ argc = number of args ]     <span class="hljs-number">8</span><br>                    [ argv[<span class="hljs-number">0</span>] (pointer) ]         <span class="hljs-number">8</span> (program name)<br>                    [ argv[<span class="hljs-number">1</span>] (pointer) ]         <span class="hljs-number">8</span><br>                    [ argv[..] (pointer) ]        <span class="hljs-number">8</span> * x<br>                    [ argv[n - <span class="hljs-number">1</span>] (pointer) ]     <span class="hljs-number">8</span><br>                    [ argv[n] (pointer) ]         <span class="hljs-number">8</span>   (= <span class="hljs-symbol">NULL</span>)<br><br>                    [ argv[<span class="hljs-number">0</span>] ]                   &gt;=<span class="hljs-number">0</span> (program name)<br>                    [ <span class="hljs-string">&#x27;\0&#x27;</span> ]                      <span class="hljs-number">1</span><br>                    [ argv[..] ]                  &gt;=<span class="hljs-number">0</span><br>                    [ <span class="hljs-string">&#x27;\0&#x27;</span> ]                      <span class="hljs-number">1</span><br>                    [ argv[n - <span class="hljs-number">1</span>] ]               &gt;=<span class="hljs-number">0</span><br>                    [ <span class="hljs-string">&#x27;\0&#x27;</span> ]                      <span class="hljs-number">1</span><br><br>  ------------------------------------------------------------------------<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202312031458613.png" alt="image-20231203145758498"></p><img src="https://rcore-os.cn/rCore-Tutorial-Book-v3/_images/user-stack-cmdargs.png" alt="../_images/user-stack-cmdargs.png" style="zoom: 67%;" /><p>可以发现<strong>黄色部分和蓝色部分顺序是反的</strong>，因此我们思路就有了，找到方法交换这两部分</p><p>修改后代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//首先预留好所有的位置,从后往前预留,其实顺序无关紧要，减去的总数都是一样的</span><br>      <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">0</span>..args.<span class="hljs-title function_ invoke__">len</span>()).<span class="hljs-title function_ invoke__">rev</span>() &#123;<br>          user_sp -= args[i].<span class="hljs-title function_ invoke__">len</span>() + <span class="hljs-number">1</span>;<br>      &#125;<br>      <span class="hljs-keyword">let</span> <span class="hljs-variable">argv_end</span> = user_sp;<br>      user_sp -= (args.<span class="hljs-title function_ invoke__">len</span>() + <span class="hljs-number">1</span>) * core::mem::size_of::&lt;<span class="hljs-type">usize</span>&gt;();<br>      <span class="hljs-comment">//准备写入，user_sp目前指向argv数组的起始地址</span><br>      <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">argv</span>: <span class="hljs-type">Vec</span>&lt;_&gt; = (<span class="hljs-number">0</span>..=args.<span class="hljs-title function_ invoke__">len</span>())<br>          .<span class="hljs-title function_ invoke__">map</span>(|arg| &#123;<br>              <span class="hljs-title function_ invoke__">translated_refmut</span>(<br>                  new_token,<br>                  (user_sp + arg * core::mem::size_of::&lt;<span class="hljs-type">usize</span>&gt;()) <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-type">usize</span>,<br>              )<br>          &#125;)<br>          .<span class="hljs-title function_ invoke__">collect</span>();<br>      *argv[args.<span class="hljs-title function_ invoke__">len</span>()] = <span class="hljs-number">0</span>;<br><br>      <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">temp_ptr</span> = argv_end;<br>      <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..args.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>          *argv[i] = temp_ptr;<br>          <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">p</span> = temp_ptr;<br>          <span class="hljs-keyword">for</span> <span class="hljs-variable">c</span> <span class="hljs-keyword">in</span> args[i].<span class="hljs-title function_ invoke__">as_bytes</span>() &#123;<br>              *<span class="hljs-title function_ invoke__">translated_refmut</span>(new_token, p <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-type">u8</span>) = *c;<br>              p += <span class="hljs-number">1</span>;<br>          &#125;<br>          *<span class="hljs-title function_ invoke__">translated_refmut</span>(new_token, p <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-type">u8</span>) = <span class="hljs-number">0</span>;<br>          temp_ptr += args[i].<span class="hljs-title function_ invoke__">len</span>() + <span class="hljs-number">1</span>;<br>      &#125;<br><br>      <span class="hljs-comment">//写入argc</span><br>      user_sp -= core::mem::size_of::&lt;<span class="hljs-type">usize</span>&gt;();<br>      *<span class="hljs-title function_ invoke__">translated_refmut</span>(new_token, user_sp <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-type">isize</span>) = args.<span class="hljs-title function_ invoke__">len</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">isize</span>;<br>...<br>...<br><span class="hljs-comment">// trap_cx.x[11] = argv_base;</span><br>      trap_cx.x[<span class="hljs-number">11</span>] = user_sp + core::mem::size_of::&lt;<span class="hljs-type">usize</span>&gt;();<br></code></pre></td></tr></table></figure><p>有一个很重要的点是，不要对齐user_sp，如果对齐了user_sp，那么在传入a1的时候，就不能这样赋值<code>user_sp + core::mem::size_of::&lt;usize&gt;()</code>，对齐后user_sp已经不是最初的版本了，会出现错误，一个解决方式是事先保存，不过rCore上面说不对齐对qemu没有影响，我就先不管了。</p><p><strong>实验结果</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202311142342402.png" alt="image-20231114234248317"></p><h3 id="问答题：elf与bin的区别"><a href="#问答题：elf与bin的区别" class="headerlink" title="问答题：elf与bin的区别"></a>问答题：elf与bin的区别</h3><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smali">ch6_file0.elf: ELF 64-bit LSB executable, UCB RISC-V, RVC,<span class="hljs-built_in"> double-float </span>ABI, version 1 (SYSV),<span class="hljs-keyword"> static</span>ally linked, stripped<br>ch6_file0.bin: data<br></code></pre></td></tr></table></figure><p> ELF 格式执行文件经过 <code>objcopy</code> 工具丢掉所有 ELF header 和符号变为二进制镜像文件bin</p><p>elf里面含有不少其他信息，程序头之类的，但是bin里面只有纯数据</p><p>如何使用反汇编：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">riscv64-linux-musl-objdump <span class="hljs-tag">&lt;<span class="hljs-name">path</span>&gt;</span> -ld &gt; <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>.S<br></code></pre></td></tr></table></figure><h2 id="lab2-1"><a href="#lab2-1" class="headerlink" title="lab2"></a>lab2</h2><h3 id="编程作业1：跟着教程做"><a href="#编程作业1：跟着教程做" class="headerlink" title="编程作业1：跟着教程做"></a>编程作业1：跟着教程做</h3><p>主要是要用引入的mod里的用户栈初始函数来替换lab1写的，具体如下，调用几个引入的mod里的api</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">elf</span> = ElfLoader::<span class="hljs-title function_ invoke__">new</span>(elf_data).<span class="hljs-title function_ invoke__">unwrap</span>();<br>user_sp = elf.<span class="hljs-title function_ invoke__">init_stack</span>(new_token, user_sp, args.<span class="hljs-title function_ invoke__">clone</span>());<br></code></pre></td></tr></table></figure><h3 id="编程作业2：添加syscall"><a href="#编程作业2：添加syscall" class="headerlink" title="编程作业2：添加syscall"></a>编程作业2：添加syscall</h3><p>根据教程，每步出现<code>Unsupported syscall_id: 29</code>这种报错，我们采用以下步骤初步处理</p><ol><li>在<code>syscall/mod.rs</code>里添加对应的<code>syscall_id</code>常量</li><li>查询对应id的syscall，通过<a href="https://jborza.com/post/2021-05-11-riscv-linux-syscalls/">此网页</a></li><li>重点关注<code>DESCRIPTION</code>,<code>RETURN VALUE</code>,<code>ERROR</code>，适当取舍实现</li></ol><p>通过报错我们依次处理了三个syscall</p><h4 id="29-sys-ioctl"><a href="#29-sys-ioctl" class="headerlink" title="29 sys_ioctl"></a>29 sys_ioctl</h4><p>尝试直接0返回，但是没有输出<code>hellostd</code>，尝试直接搬过来sys_write，但是失败（不知道怎么实现）</p><p>进汇编看一下调用ioctl的时候，传了哪些参数，因为翻看手册对里面写的<code>request</code>参数感觉很模糊，不知道要干嘛</p><p>在ecall前，传入的参数为</p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202311151404589.png" alt="image-20231115140405483"></p><p>后来发现这个地方<strong>直接0返回就行</strong>，因为我把<code>writev</code>看成了<code>readv</code>，因此输出<code>hellostd</code>这个活应该是在<code>writev</code>这里干的</p><h4 id="66-sys-writev"><a href="#66-sys-writev" class="headerlink" title="66 sys_writev"></a>66 sys_writev</h4><blockquote><p>这里一开始看错了，把66看成了readv，导致全部syscall改完之后，以为唯一需要更改的是ioctl这个，但是无从下手，事实上readv,writev这两个对应的手册就是一样的…</p></blockquote><h5 id="思考过程"><a href="#思考过程" class="headerlink" title="思考过程"></a>思考过程</h5><p>发现直接调用<code>sys_write</code>好像不行，报错</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">xrzr</span>|r~r[kernel] Panicked at src/fs/stdio.rs:<span class="hljs-number">55</span> called `Result::unwrap()` <span class="hljs-literal">on</span> an `Err` value: Utf8Error &#123; valid_up_to: <span class="hljs-number">0</span>, error_len: Some(<span class="hljs-number">1</span>) &#125;<br></code></pre></td></tr></table></figure><p>转回去看手册，<code>writev</code>就是从几个地址写入<code>fd</code>，写入<code>iovcnt</code>次，因此思路就是调用<code>iovcnt</code>次<code>sys_write</code>，但是为了保险起见，我还是没有使用嵌套的系统调用，复制粘贴修改了一下<code>sys_write</code>写到<code>sys_writev</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">writev</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> iovec *iov, <span class="hljs-type">int</span> iovcnt)</span>;<br></code></pre></td></tr></table></figure><p>去查阅了一下<code>musl</code>源码，全局搜索<code>iovec</code>，得到<code>iovec</code>结构体的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">STRUCT iovec &#123; <span class="hljs-type">void</span> *iov_base; <span class="hljs-type">size_t</span> iov_len; &#125;;<br></code></pre></td></tr></table></figure><p>改写到rust中</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust">/os/src/syscall/<span class="hljs-keyword">mod</span>.rs<br><br><span class="hljs-comment">/// Iovec</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Iovec</span> &#123;<br>    <span class="hljs-comment">/// base addr</span><br>    <span class="hljs-keyword">pub</span> iov_base: *<span class="hljs-keyword">const</span> <span class="hljs-type">u8</span>,<br>    <span class="hljs-comment">/// len</span><br>    <span class="hljs-keyword">pub</span> iov_len: <span class="hljs-type">usize</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// writev syscall</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sys_writev</span>(fd: <span class="hljs-type">usize</span>, buf: *<span class="hljs-keyword">const</span> Iovec, iovcnt: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">isize</span> &#123;<br>    <span class="hljs-comment">// println!(&quot;fd is &#123;&#125;&quot;, fd);</span><br>    <span class="hljs-comment">// println!(&quot;buf is &#123;:?&#125;&quot;, buf);</span><br>    <span class="hljs-comment">// println!(&quot;iovcnt is &#123;&#125;&quot;, iovcnt);</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">token</span> = <span class="hljs-title function_ invoke__">current_user_token</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">process</span> = <span class="hljs-title function_ invoke__">current_process</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">inner</span> = process.<span class="hljs-title function_ invoke__">inner_exclusive_access</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">write_num</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> fd &gt;= inner.fd_table.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(file) = &amp;inner.fd_table[fd] &#123;<br>        <span class="hljs-keyword">if</span> !file.<span class="hljs-title function_ invoke__">writable</span>() &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">file</span> = file.<span class="hljs-title function_ invoke__">clone</span>();<br>        <span class="hljs-comment">// release current task TCB manually to avoid multi-borrow</span><br>        <span class="hljs-title function_ invoke__">drop</span>(inner);<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..iovcnt &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">iov_ptr</span> = <span class="hljs-title function_ invoke__">translated_ref</span>(token, buf.<span class="hljs-title function_ invoke__">wrapping_add</span>(i));<br>            write_num += file.<span class="hljs-title function_ invoke__">write</span>(UserBuffer::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">translated_byte_buffer</span>(<br>                token,<br>                (*iov_ptr).iov_base,<br>                (*iov_ptr).iov_len,<br>            ))) <span class="hljs-keyword">as</span> <span class="hljs-type">isize</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    write_num<br>&#125;<br></code></pre></td></tr></table></figure><p>自己第一次没思考清晰的地方</p><ul><li>在这个函数里面传入了<code>Iovec</code>结构体的指针，这是个虚拟地址，需要先得到它的物理地址才能访问这个结构体里面存的东西，对应<code>translated_ref</code></li><li>结构体内存的是一个虚拟地址和一个usize，因此这个虚拟地址还需要再次翻译才能正确写入，对应<code>translated_byte_buffer</code></li></ul><p><strong>最终结果</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202311151608600.png" alt="image-20231115160854543"></p><h4 id="94-sys-exitgroup"><a href="#94-sys-exitgroup" class="headerlink" title="94 sys_exitgroup"></a>94 sys_exitgroup</h4><blockquote><p>退出一个进程的所有线程</p></blockquote><p>尝试直接0返回，成功</p><h4 id="问答作业"><a href="#问答作业" class="headerlink" title="问答作业"></a>问答作业</h4><p>options，调用可直接按位或</p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202311151710134.png" alt="image-20231115171046087"></p><h2 id="lab3-1"><a href="#lab3-1" class="headerlink" title="lab3"></a>lab3</h2><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p><strong>思考题1.1</strong></p><p>cargo缓存比如log库的代码在：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/root/</span>.cargo<span class="hljs-regexp">/registry/</span>src<span class="hljs-regexp">/mirrors.ustc.edu.cn-61ef6e0cd06fb9b8/</span>log-<span class="hljs-number">0.4</span>.<span class="hljs-number">20</span>/src<br></code></pre></td></tr></table></figure><p><strong>思考题1.2</strong>：如果忘记 <code>make clean</code> 会发生什么？</p><p>不会panic，而是make run成功</p><p><strong>思考题2</strong>：在<a href="https://scpointer.github.io/rcore2oscomp/docs/lab3/before.html">部分往届内核及运行指引</a> 一节提到的内核中挑选一个，描述它在默认情况下启动后会执行哪些测例（抑或是直接启动终端）。</p><p>选择的<a href="https://github.com/greenhandzpx/Titanix">Titanix</a></p><p>首先看了下readme，得知<code>make run</code>之后会进入busybox的shell，因此第一个应该就是busybox</p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202311191437705.png" alt="image-20231119143736590"></p><p>测试用例</p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202311191438324.png" alt="image-20231119143810275"></p><p><strong>思考题3.1</strong>：为什么要在开头结尾各输出一句，会不会太过重复？（提示：考虑执行出错的情况，或者 <code>sys_exit</code> ）</p><p>开头的是必须的，可以看到<code>exitgroup</code>每次都是直接退出，没有输出返回值，对比一下图中的两个框</p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202311211756068.png" alt="image-20231121175645028"></p><p><strong>思考题3.2</strong>：为什么要结尾还要输出一遍 <code>syscall</code> 的完整参数，只输出返回值行不行？（提示：考虑像 <code>sys_yield</code> 这样的 <code>syscall</code>）</p><p>yield用于切换进程，让出当前进程的执行权，如果切换到其他进程，参数是会改变的，因此结尾要再输出一遍完整参数</p><h3 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h3><p>使用方法：直接把<code>strace</code>加在要运行的命令之前，就能看到执行命令过程中执行的所有<code>syscall</code></p><p>注意执行strace的路径应该要有执行命令的elf或文件</p><p><code>strace</code> 也可以加一些参数，常用的有</p><ul><li><code>-c</code> 按种类统计 <code>syscall</code> 的执行时间、次数和报错次数。注意，“报错”只是代表返回小于 0 的错误码，不代表用户程序出错。例如检查文件是否不存在时也可以用 <code>sys_openat</code> ，得到 <code>ENOENT</code>（没有此文件）的结果属于“报错”，但这就是我们预期的结果。</li><li><code>-p &lt;PID&gt;</code> 表示指定追踪的进程ID。如果想调试一个大的应用程序，可能会有许多进程共同协作，我们可以指定关心某一个</li><li><code>-t</code> 输出时间信息；<code>-T</code> 显示每次调用的时间</li><li><code>-f</code> 追踪 <code>fork</code>；<code>-F</code> 追踪 <code>fork</code> 和 <code>vfork</code></li><li><code>-e [!]value[,value2]</code>指定要追踪的<code>syscall</code><ul><li>如<code>-e clone,read</code>就是只看<code>sys_clone</code>和<code>sys_read</code></li><li><code>-e \!read</code>表示不看<code>sys_read</code></li></ul></li></ul><h3 id="实验3-1-修复busybox-mv"><a href="#实验3-1-修复busybox-mv" class="headerlink" title="实验3.1 修复busybox mv"></a>实验3.1 修复busybox mv</h3><p>首先捋一下教程里面修复<code>ls</code>的过程</p><ul><li>修改启动侧例，单独分析有问题的<code>ls</code>的输出</li><li>在<code>syscall</code>函数里面，写上<code>error!</code>输出信息（包括：<code>syscall id</code>，<code>args</code>），方便调试</li><li>make run获取错误答案</li><li>调试往届内核错误，应该找Linux的syscall对拍，使用<code>strace</code>，采用在本机调试（涉及具体文件操作？）</li><li>strace获取“标准答案”</li><li>对照找不同，可以依据linux文档找syscall定义</li></ul><p><strong>实验</strong></p><p>首先获取标准答案：</p><p><code>strace busybox mv abc bin/</code></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">...                            <br><span class="hljs-function"><span class="hljs-title">newfstatat</span><span class="hljs-params">(AT_FDCWD, <span class="hljs-string">&quot;bin/&quot;</span>, &#123;st_mode=S_IFDIR|<span class="hljs-number">0755</span>, st_size=<span class="hljs-number">4096</span>, ...&#125;, <span class="hljs-number">0</span>)</span></span> = <span class="hljs-number">0</span><br><span class="hljs-function"><span class="hljs-title">newfstatat</span><span class="hljs-params">(AT_FDCWD, <span class="hljs-string">&quot;bin/abc&quot;</span>, <span class="hljs-number">0</span>x7ffd45e76cc8, <span class="hljs-number">0</span>)</span></span> = -<span class="hljs-number">1</span> ENOENT (No such file or directory)<br><span class="hljs-function"><span class="hljs-title">rename</span><span class="hljs-params">(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;bin/abc&quot;</span>)</span></span>                = <span class="hljs-number">0</span><br>...<br></code></pre></td></tr></table></figure><p><code>make run</code>，题目说是<code>mv</code>的问题，因此只截取了<code>mv</code>片段：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs inform7">...<br><span class="hljs-comment">[syscall]</span> id = FSTATAT, args = <span class="hljs-comment">[18446744073709551516, 1073741382, 1073740160, 0, 1073741382, 18446744073709551516]</span>, entry<br><span class="hljs-keyword">Is</span> a directory<br><span class="hljs-comment">[syscall]</span> id = 79, args = <span class="hljs-comment">[18446744073709551516, 1073741382, 1073740160, 0, 1073741382, 18446744073709551516]</span>, return 0<br><span class="hljs-comment">[syscall]</span> id = BRK, args = <span class="hljs-comment">[0, 64, 1458528, 0, 1457024, 4096]</span>, entry<br><span class="hljs-comment">[syscall]</span> id = 214, args = <span class="hljs-comment">[0, 64, 1458528, 0, 1457024, 4096]</span>, return 1067450368<br><span class="hljs-comment">[syscall]</span> id = MMAP, args = <span class="hljs-comment">[0, 4096, 3, 34, 18446744073709551615, 0]</span>, entry<br><span class="hljs-comment">[syscall]</span> id = 222, args = <span class="hljs-comment">[0, 4096, 3, 34, 18446744073709551615, 0]</span>, return 4096<br><br><span class="hljs-comment">[syscall]</span> id = FSTATAT, args = <span class="hljs-comment">[18446744073709551516, 4128, 1073740160, 0, 4128, 18446744073709551516]</span>, entry<br><span class="hljs-comment">[syscall]</span> id = 79, args = <span class="hljs-comment">[18446744073709551516, 4128, 1073740160, 0, 4128, 18446744073709551516]</span>, return -64<br><br><span class="hljs-comment">[syscall]</span> id = WRITE, args = <span class="hljs-comment">[2, 1073740112, 47, 0, 0, 0]</span>, entry<br>mv: can&#x27;t stat &#x27;bin/abc&#x27;: No error information<br><span class="hljs-comment">[syscall]</span> id = 64, args = <span class="hljs-comment">[2, 1073740112, 47, 0, 0, 0]</span>, return 47<br>...<br></code></pre></td></tr></table></figure><ul><li>可以看到中间有个<code>FSTATAT</code>返回了<code>-64</code>，阅读<code>deal_result</code>知道返回值的处理是添加一个<code>-</code>号，因此实际是返回一个64</li></ul><p>make run LOG=debug得到一个error：<code>get stat error: ENONET</code></p><p>应该就是<code>fstatat</code>有问题吧</p><p>根据fstat的debug信息查看一下调用了哪些函数 </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[syscall] id = FSTATAT, args = [<span class="hljs-number">18446744073709551516</span>, <span class="hljs-number">4128</span>, <span class="hljs-number">1073740160</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4128</span>, <span class="hljs-number">18446744073709551516</span>], entry<br>path : <span class="hljs-regexp">/bin/</span>abc<br><span class="hljs-keyword">Into</span> function new_fd, path: <span class="hljs-regexp">/bin/</span>abc<br>open <span class="hljs-keyword">file</span>: <span class="hljs-regexp">/bin/</span>abc <span class="hljs-keyword">READ</span><br>lookup at root: <span class="hljs-regexp">/bin/</span>abc<br>lookup at fatfs: bin/abc<br>get stat error: ENONET<br>[syscall] id = <span class="hljs-number">79</span>, args = [<span class="hljs-number">18446744073709551516</span>, <span class="hljs-number">4128</span>, <span class="hljs-number">1073740160</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4128</span>, <span class="hljs-number">18446744073709551516</span>], <span class="hljs-keyword">return</span> -<span class="hljs-number">64</span><br></code></pre></td></tr></table></figure><p><code>get_stat_in_fs</code>一定返回一个err，全局搜索<code>ENONET</code>定位了错误位置，在此修改即可，注意根据调试信息可以知道<code>get stat error</code>出现的位置，防止混淆（因为有多个<code>get stat error</code>）</p><p>依据strace得到正确的返回值应该是<code>-1</code>，但是<code>ENOENT</code>在<code>LinuxError</code>对应的是<code>2</code>呀，根据语义修改为<code>ENOENT</code></p><p>修改后返回值可以对上了，但是<code>mv</code>报错：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">mv: can<span class="hljs-symbol">&#x27;t</span> rename <span class="hljs-symbol">&#x27;abc</span>&#x27;: Operation <span class="hljs-keyword">not</span> permitted<br></code></pre></td></tr></table></figure><p>翻译一下<code>renameat(2)</code>的内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">renameat2</span><span class="hljs-params">(<span class="hljs-type">int</span> olddirfd, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *oldpath,</span><br><span class="hljs-params">                    <span class="hljs-type">int</span> newdirfd, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *newpath, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span>;<br></code></pre></td></tr></table></figure><p><strong>描述</strong></p><ul><li>用于重命名文件，如果需要，可以将文件移动到其他目录。对文件创建的硬链接（使用<code>link(2)</code>创建）不受影响。对于<code>oldpath</code>的打开文件描述符也不受影响。</li><li>如果<code>newpath</code>已经存在，它将被原子性地替换，因此在访问<code>newpath</code>时不会找不到文件的情况。但是，可能存在一个时间窗口，其中<code>oldpath</code>和<code>newpath</code>都引用正在被重命名的文件。</li><li>如果<code>oldpath</code>和<code>newpath</code>是引用同一文件的现有硬链接，则<code>rename()</code>不执行任何操作，并返回成功状态。</li><li>如果<code>newpath</code>存在但由于某种原因操作失败，<code>rename()</code>保证保留<code>newpath</code>的一个实例。</li><li><code>oldpath</code>可以指定一个目录。在这种情况下，<code>newpath</code>要么不存在，要么必须指定为空目录。这个有疑问</li><li>如果<code>oldpath</code>是符号链接，则重命名该链接；如果<code>newpath</code>是符号链接，则将覆盖该链接。</li><li>如果<code>oldpath</code>中给定的路径是相对路径，则它相对于由文件描述符<code>olddirfd</code>引用的目录进行解释（而不是相对于调用进程的当前工作目录，如<code>rename()</code>对于相对路径所做的那样）。如果<code>oldpath</code>是相对路径且<code>olddirfd</code>是特殊值<code>AT_FDCWD</code>，则<code>oldpath</code>相对于调用进程的当前工作目录进行解释</li></ul><p><strong>flags</strong></p><ul><li><p><code>RENAME_EXCHANGE</code>：原子地交换<code>oldpath</code>和<code>newpath</code>。这两个路径必须存在，但可以是不同类型的（例如，一个可能是非空目录，另一个可能是符号链接）。</p></li><li><p><code>RENAME_NOREPLACE</code>：不要覆盖<code>rename</code>的<code>newpath</code>。如果<code>newpath</code>已经存在，则返回错误。<code>RENAME_NOREPLACE</code>不能与<code>RENAME_EXCHANGE</code>一起使用。</p></li><li><p><code>RENAME_WHITEOUT</code>（自Linux 3.18起）：此操作仅对overlay/union文件系统实现有意义。指定<code>RENAME_WHITEOUT</code>会在重命名的源文件同时创建一个”whiteout”对象。整个操作是原子的，因此如果重命名成功，则”whiteout”也将已创建。”Whiteout”是在union/overlay文件系统结构中具有特殊含义的对象。在这些结构中，存在多个层，只有顶层会被修改。在上层的”whiteout”将有效地隐藏下层的匹配文件，使其看起来好像文件不存在。当重命名存在于下层的文件时，首先将文件复制到上层（如果尚未在上层），然后在上层以读写方式重命名。同时，源文件需要被”whiteout”（以使下层的源文件版本变得不可见）。整个操作需要原子执行。在非union/overlay中，”whiteout”显示为带有{0,0}设备号的字符设备。<code>RENAME_WHITEOUT</code>需要与创建设备节点相同的特权（即<code>CAP_MKNOD</code>能力）。<code>RENAME_WHITEOUT</code>不能与<code>RENAME_EXCHANGE</code>一起使用。<code>RENAME_WHITEOUT</code>需要底层文件系统的支持。支持它的文件系统包括tmpfs（自Linux 3.18起）、ext4（自Linux 3.18起）、XFS（自Linux 4.1起）、f2fs（自Linux 4.2起）、btrfs（自Linux 4.7起）和ubifs（自Linux 4.9起）。</p></li></ul><p>把oldpath复制到newpath这里，如果newpath是一个目录，那么就移动到目录下面，如果newpath不是目录，就重命名（可以执行统一的语义：移到 ./newpath ），最后删除oldpath</p><p>看了下<code>rename</code>，如果new存在的话会remove他，代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">rename_flags</span> = RenameFlags::<span class="hljs-title function_ invoke__">from_bits</span>(flags <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br> error!(<br>     <span class="hljs-string">&quot;old_path is &#123;&#125;,new_path is &#123;&#125;&quot;</span>,<br>     old_path.<span class="hljs-title function_ invoke__">path</span>(),<br>     new_path.<span class="hljs-title function_ invoke__">path</span>()<br> );<br><br> <span class="hljs-comment">//如果路径不存在，old-&gt;error,new-&gt;分情况讨论</span><br> <span class="hljs-keyword">if</span> !<span class="hljs-title function_ invoke__">path_exists</span>(old_path.<span class="hljs-title function_ invoke__">path</span>()) &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(SyscallError::EPERM);<br> &#125;<br><br> <span class="hljs-comment">//如果`oldpath`和`newpath`是引用同一文件的现有硬链接，则`rename()`不执行任何操作，并返回成功状态。</span><br> <span class="hljs-keyword">if</span> old_path.<span class="hljs-title function_ invoke__">path</span>() == new_path.<span class="hljs-title function_ invoke__">path</span>() &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-number">0</span>);<br> &#125;<br><br> <span class="hljs-comment">//如果`newpath`存在但由于某种原因操作失败，`rename()`保证保留`newpath`的一个实例。</span><br><br> <span class="hljs-comment">//一共四种情况 [file,dir] [file file] [dir file] [dir dir]</span><br> <span class="hljs-comment">//old_path必须存在，new_path有些情况可以不存在，因此old_data不存在直接err</span><br> <span class="hljs-keyword">let</span> <span class="hljs-variable">old_data</span> = <span class="hljs-title function_ invoke__">metadata</span>(old_path.<span class="hljs-title function_ invoke__">path</span>())?;<br> <span class="hljs-keyword">if</span> old_data.<span class="hljs-title function_ invoke__">is_dir</span>() &#123;<br>     <span class="hljs-comment">//`oldpath`可以指定一个目录。在这种情况下，`newpath`要么不存在，要么必须指定为(空)目录。</span><br>     <span class="hljs-keyword">if</span> !<span class="hljs-title function_ invoke__">path_exists</span>(new_path.<span class="hljs-title function_ invoke__">path</span>()) &#123;<br>         <span class="hljs-keyword">let</span> <span class="hljs-variable">_</span> = <span class="hljs-title function_ invoke__">rename</span>(old_path.<span class="hljs-title function_ invoke__">path</span>(), new_path.<span class="hljs-title function_ invoke__">path</span>());<br>     &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Ok</span>(new_data) = <span class="hljs-title function_ invoke__">metadata</span>(new_path.<span class="hljs-title function_ invoke__">path</span>()) &#123;<br>         <span class="hljs-comment">//todo,空目录如何表达？,考虑flag</span><br>         <span class="hljs-keyword">if</span> new_data.<span class="hljs-title function_ invoke__">is_dir</span>() &#123;<br>             <span class="hljs-keyword">let</span> <span class="hljs-variable">_</span> = <span class="hljs-title function_ invoke__">rename</span>(old_path.<span class="hljs-title function_ invoke__">path</span>(), new_path.<span class="hljs-title function_ invoke__">path</span>());<br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>             <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(SyscallError::EPERM);<br>         &#125;<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(SyscallError::EPERM);<br>     &#125;<br> &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> old_data.<span class="hljs-title function_ invoke__">is_file</span>() &#123;<br>     <span class="hljs-keyword">let</span> <span class="hljs-variable">_</span> = <span class="hljs-title function_ invoke__">rename</span>(old_path.<span class="hljs-title function_ invoke__">path</span>(), new_path.<span class="hljs-title function_ invoke__">path</span>());<br> &#125;<br><br> <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>flag还没有实现，有时间再补上</p><p>得到正确答案：</p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202311211725497.png" alt="image-20231121172459332"></p><h3 id="实验3-2"><a href="#实验3-2" class="headerlink" title="实验3.2"></a>实验3.2</h3><p>还是老样子首先和本机标准答案对照：</p><p><code>strace busybox mv bin def</code></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">...<br><span class="hljs-function"><span class="hljs-title">newfstatat</span><span class="hljs-params">(AT_FDCWD, <span class="hljs-string">&quot;bin&quot;</span>, &#123;st_mode=S_IFDIR|<span class="hljs-number">0755</span>, st_size=<span class="hljs-number">4096</span>, ...&#125;, <span class="hljs-number">0</span>)</span></span> = <span class="hljs-number">0</span><br><span class="hljs-function"><span class="hljs-title">newfstatat</span><span class="hljs-params">(AT_FDCWD, <span class="hljs-string">&quot;bin/def&quot;</span>, <span class="hljs-number">0</span>x7ffe00dec808, <span class="hljs-number">0</span>)</span></span> = -<span class="hljs-number">1</span> ENOENT (No such file or directory)<br><span class="hljs-function"><span class="hljs-title">rename</span><span class="hljs-params">(<span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;bin/def&quot;</span>)</span></span><br>...<br></code></pre></td></tr></table></figure><p>Starry内核：</p><p>为了方便调试在<code>renameat2</code>里面加了一句:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust">error!(<br>    <span class="hljs-string">&quot;old_path is &#123;&#125;,new_path is &#123;&#125;&quot;</span>,<br>    old_path.<span class="hljs-title function_ invoke__">path</span>(),<br>    new_path.<span class="hljs-title function_ invoke__">path</span>()<br>);<br></code></pre></td></tr></table></figure><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[syscall]</span> id = FSTATAT, args = <span class="hljs-comment">[18446744073709551516, 1073741383, 1073740160, 0, 1073741383, 18446744073709551516]</span>, entry<br><span class="hljs-keyword">Is</span> a directory<br><span class="hljs-comment">[syscall]</span> id = 79, args = <span class="hljs-comment">[18446744073709551516, 1073741383, 1073740160, 0, 1073741383,18446744073709551516]</span>, return 0<br><span class="hljs-comment">[syscall]</span> id = FACCESSAT, args = <span class="hljs-comment">[18446744073709551516, 1073741383, 2, 0, 16384, 1073741383]</span>, entry<br><span class="hljs-keyword">Is</span> a directory<br><span class="hljs-comment">[syscall]</span> id = 48, args = <span class="hljs-comment">[18446744073709551516, 1073741383, 2, 0, 16384, 1073741383]</span>, return 0<br><span class="hljs-comment">[syscall]</span> id = RENAMEAT2, args = <span class="hljs-comment">[18446744073709551516, 1073741387, 18446744073709551516, 1073741383, 0, 1073741387]</span>, entry<br>old_path <span class="hljs-keyword">is</span> /def,new_path <span class="hljs-keyword">is</span> /bin<br><span class="hljs-keyword">Is</span> a directory<br>dst file already exist, now remove it<br><span class="hljs-keyword">Is</span> a directory<br><span class="hljs-comment">[AxError::IsADirectory]</span><br><span class="hljs-comment">[syscall]</span> id = 276, args = <span class="hljs-comment">[18446744073709551516, 1073741387, 18446744073709551516, 1073741383, 0, 1073741387]</span>, return 0<br></code></pre></td></tr></table></figure><p>可以看到出问题了，应该是错把dir当成file的错误</p><p>与实验<code>3.1</code>的答案对照一下看看</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vim">[syscall] id = FSTATAT, <span class="hljs-keyword">args</span> = [<span class="hljs-number">18446744073709551516</span>, <span class="hljs-number">4128</span>, <span class="hljs-number">1073740160</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4128</span>, <span class="hljs-number">18446744073709551516</span>], entry<br>[syscall] id = <span class="hljs-number">79</span>, <span class="hljs-keyword">args</span> = [<span class="hljs-number">18446744073709551516</span>, <span class="hljs-number">4128</span>, <span class="hljs-number">1073740160</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4128</span>, <span class="hljs-number">18446744073709551516</span>], <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>[syscall] id = FACCESSAT, <span class="hljs-keyword">args</span> = [<span class="hljs-number">18446744073709551516</span>, <span class="hljs-number">4128</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">16384</span>, <span class="hljs-number">4128</span>], entry<br>[syscall] id = <span class="hljs-number">48</span>, <span class="hljs-keyword">args</span> = [<span class="hljs-number">18446744073709551516</span>, <span class="hljs-number">4128</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">16384</span>, <span class="hljs-number">4128</span>], <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>[syscall] id = RENAMEAT2, <span class="hljs-keyword">args</span> = [<span class="hljs-number">18446744073709551516</span>, <span class="hljs-number">1073741387</span>, <span class="hljs-number">18446744073709551516</span>, <span class="hljs-number">4128</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1073741387</span>], entry<br>old_path <span class="hljs-keyword">is</span> /<span class="hljs-keyword">abc</span>,new_path <span class="hljs-keyword">is</span> /bin/<span class="hljs-keyword">abc</span><br>dst <span class="hljs-keyword">file</span> already exist, now <span class="hljs-built_in">remove</span> it<br>[syscall] id = <span class="hljs-number">276</span>, <span class="hljs-keyword">args</span> = [<span class="hljs-number">18446744073709551516</span>, <span class="hljs-number">1073741387</span>, <span class="hljs-number">18446744073709551516</span>, <span class="hljs-number">4128</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1073741387</span>], <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>对比发现<code>deal_with_path</code>会预先处理好<code>new_path</code>，对于上一小节实验给出<code>old_path is /abc,new_path is /bin/abc</code>，而对于这节实验给出<code>old_path is /def,new_path is /bin</code></p><p>由于我error!的位置在处理的最前面，因此，就只有<code>deal_with_path</code>会出现这个问题，进入函数，开始修正</p><ul><li><p>首先做了一个小test，发现不可能存在同名的file和dir</p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202311211725553.png" alt="image-20231121172532515"></p></li><li><p>那么是怎么分辨一个没有以<code>/</code>是dir还是file呢，我的想法是首先获取<code>metadata</code>，利用里面的<code>is_dir</code>和<code>is_file</code>来判断，如果满足是目录而且没有以<code>/</code>结尾，手动给他添上</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Ok</span>(new_data) = <span class="hljs-title function_ invoke__">metadata</span>(path.<span class="hljs-title function_ invoke__">as_str</span>()) &#123;<br>    <span class="hljs-keyword">if</span> new_data.<span class="hljs-title function_ invoke__">is_dir</span>() &amp;&amp; !path.<span class="hljs-title function_ invoke__">ends_with</span>(<span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>        path = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;/&quot;</span>, path);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>可以正确输出</p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202311211739021.png" alt="image-20231121173905954"></p></li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>项目二是ArceOs宏内核，当时选项目二的原因是</p><ol><li>想参加大赛</li><li>从第二阶段的rCore tutorial学习之后，还有一些疑问，想借这个项目巩固一下，同时跨越从教程到自己写内核的鸿沟</li></ol><p>个人觉得收获很大的是调试技巧方面：</p><p>gdb：</p><p>gdb 不支持跨地址空间的查找。它只知道当前能不能访问某个地址（虚拟地址），不会管现在的页表在哪，所以内核调试时经常会遇到因为地址当前无法访问而打不上断点的情况。这时可分为以下情况处理：</p><ol><li><p>把断点打在内核入口，也即 <code>0x80200000</code> 处，然后使用 <code>c</code> 命令跳过去。之后就可以打大部分内核符号的断点了。</p></li><li><p>把断点打在 <code>mm::init()</code> （页表初始化函数）然后使用 <code>c</code> 命令跳过去，再用 <code>n</code> 指令跳过这段流程，就可以打页表中有映射的地址的断点了，例如跳板页 <code>TRAMPOLINE</code>。</p></li><li><p>一般来说，如果想打用户程序的断点，先使用 <code>c</code> 命令，等待程序运行到 <code>user_shell</code> 等待输出的时候，再 <code>ctrl+C</code>，就可以打用户地址空间的断点了。但缺点是此时无法打内核的断点</p></li></ol><p>总的说来，训练营收获很大，从一开始的只是了解了OS的皮毛，或者说书本上的OS知识，再经过第一阶段，从零开始学习了rust的基础，第二阶段亲自上手体验五个实验，细致地体会OS各种核心的概念，中断、虚拟内存、进程切换、多线程、信号等等，然后第三阶段通过AecOS宏内核的学习，了解到OS大赛所需要的部分知识，我的认知确实有短暂地螺旋上升，很谢谢有这样一个平台能学习OS，感谢。</p>]]></content>
    
    
    
    <tags>
      
      <tag>rust os</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数论</title>
    <link href="/2023/04/03/%E6%95%B0%E8%AE%BA/"/>
    <url>/2023/04/03/%E6%95%B0%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>欧几里得算法 筛法求素数（埃氏筛、欧拉筛） 裴蜀定理板子</p><span id="more"></span><h1 id="欧几里得-辗转相除法"><a href="#欧几里得-辗转相除法" class="headerlink" title="欧几里得(辗转相除法)"></a>欧几里得(辗转相除法)</h1><p>求a，b的最大公因数</p><p>gcd(a,b) = gcd(b,a%b) = ….. 直到(a,b)中b为0，那么结果就为a</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> b?<span class="hljs-built_in">gcd</span>(a,b):a ;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="筛法求素数"><a href="#筛法求素数" class="headerlink" title="筛法求素数"></a>筛法求素数</h1><h2 id="埃氏筛"><a href="#埃氏筛" class="headerlink" title="埃氏筛"></a>埃氏筛</h2><p>从2开始的 x ，划掉每个x的倍数，优化一下可以从x^2^开始划</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> primes[N],cnt;<br><span class="hljs-type">bool</span> st[N];<span class="hljs-comment">//初始为false，true表示被筛掉了，最后为false的都是质数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>; i&lt;=n ;i++)&#123;<br>    <span class="hljs-keyword">if</span>(!st[i])&#123;<br>        primes[cnt++] = i;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i*i; j&lt;=n; j++) st[i]=<span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h2><ul><li>每个合数只被划掉一次，而且是被它的最小质因子划掉的 (原理是：每个合数都有一个&lt;= sqrt(x) 的质因子 )<ul><li>由于被它的最小质因子划掉的，因此还可以求每个数的最小质因子</li></ul></li><li>筛的过程，为了避免重复筛<ul><li>对于每个数x，乘上 &lt;= x的最小质因子的质数，就可以保证不重复筛</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> primes[N],cnt;<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>; i&lt;=n; i++)&#123;<br>        <span class="hljs-keyword">if</span>(!st[i]) primes[cnt++] = i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; primes[j]*i&lt;=n;j++ )&#123;<span class="hljs-comment">//此时primes[]数组里面的都是 &lt;= i的</span><br>            <span class="hljs-type">int</span> t = primes[j]*i ;<br>            st[t] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//筛掉</span><br>            <span class="hljs-keyword">if</span>(i % primes[j] == <span class="hljs-number">0</span> ) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//primes[j]就是最小质因子，因为前面两行代码已经实现了乘primes[j],直接退出</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="裴蜀定理-扩展欧几里得算法"><a href="#裴蜀定理-扩展欧几里得算法" class="headerlink" title="裴蜀定理(扩展欧几里得算法)"></a>裴蜀定理(扩展欧几里得算法)</h1><p>(a,b) = d   </p><p>裴蜀定理可以求出一组x，y 使得 d = ax<del>0</del> + by<del>0</del></p><p>并且只要求出满足的一组解x，y，就可以求出所有解</p><p>a’ = a/d  b’ = b/d</p><p>x = x<del>0</del> + k<em>b’    y = y<del>0</del> - k</em>a’</p><p><strong>运用</strong></p><p>(a,b) = (b,a%b) =… = d</p><p>因此 b*y + (a % b) * x = d</p><p>即    b<em>y + (a - a/b * b ) * x = a</em>x + (y-a/b * x ) * b = d</p><p>=&gt;   x’ = x    y’ = y - a/b*x  (b = 0 时停止)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//exgcd可以找出满足的 d = ax + by 中的x，y并且返回d</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!b)&#123;<br>        x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-type">int</span> d = <span class="hljs-built_in">exgcd</span>(b, a%b, y, x);<br>    y -= a / b * x;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>欧几里得算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树状数组</title>
    <link href="/2023/03/23/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    <url>/2023/03/23/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p>树状数组和线段树的实现</p><span id="more"></span><p>如何推导？查看本人的知乎这篇文章：<a href="https://zhuanlan.zhihu.com/p/585460026">前缀和改进之树状数组 - 知乎 (zhihu.com)</a></p><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul><li><p>单点修改，区间求和  O(logN)</p></li><li><p>可以在，O(logN)的时间内，动态求前缀和 ( 对比前缀和，修改的话需要O(N) )</p></li></ul><p>注意：树状数组下标一定要<strong>从1开始</strong></p><h4 id="树状数组初始化"><a href="#树状数组初始化" class="headerlink" title="树状数组初始化"></a>树状数组初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span> ; i&lt;=n ; i++) <span class="hljs-built_in">add</span>(i,a[i]);<br></code></pre></td></tr></table></figure><p>小小地解释一下原理：</p><ul><li><p>树状数组中奇数下标和原数组相等</p></li><li><p><code>c[x] = 原数组中下标从(x-lowbit(x)，x]的和</code> 左开右闭</p></li></ul><h4 id="三个基本操作："><a href="#三个基本操作：" class="headerlink" title="三个基本操作："></a>三个基本操作：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[N],c[N];<span class="hljs-comment">//a[N]为原数组，c[N]为树状数组</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; -x;<br>&#125;<br><br><span class="hljs-comment">//一般情况下只支持add，如果要实现修改某一个数，可以add他们的差值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x , <span class="hljs-type">int</span> v )</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i&lt;=n;i+=<span class="hljs-built_in">lowbit</span>(i)) c[i] += v;    <br>&#125;<br><br><span class="hljs-comment">//查询</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x ; i&gt;=<span class="hljs-number">1</span> ; i-=<span class="hljs-built_in">lowbit</span>(i) )  res += c[i];<span class="hljs-comment">//for循环截止条件写成 i!=0 即 i也可以</span><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><p>每个结点都是一个结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> L,R;<br>    <span class="hljs-type">int</span> sum;<br>&#125;tr[N*<span class="hljs-number">4</span>];<br></code></pre></td></tr></table></figure><p>线段树存储</p><p>注意结点个数要开 <code>4n</code> 其中n是有多少个数</p><p>类似于堆的存储方式，存在一维数组，对于一个序号为x的节点</p><ul><li>父节点为 x/2 (下取整) <code>x&gt;&gt;1</code></li><li>左子节点为 x*2  <code>x&lt;&lt;1</code></li><li>右子节点为 x*2+1  <code>x&lt;&lt; 1 | 1</code></li></ul><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><ul><li><p>单点修改 O(logN)</p></li><li><p>区间查询 O(logN)</p></li></ul><p>四个函数</p><p>pushup 用子节点信息更新当前节点信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    tr[u].sum = tr[u&lt;&lt;<span class="hljs-number">1</span>].sum + tr[u&lt;&lt;<span class="hljs-number">1</span> | <span class="hljs-number">1</span>].sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>build  在一段区间上初始化线段树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l == r) tr[u] = &#123;l,r,w[r]&#125;;<br>    <span class="hljs-keyword">else</span>&#123;<br>        tr[u] = &#123;l,r&#125;;<br>        <span class="hljs-type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">build</span>(u&lt;&lt;<span class="hljs-number">1</span>,l,mid), <span class="hljs-built_in">build</span>(u&lt;&lt;<span class="hljs-number">1</span> | <span class="hljs-number">1</span> , mid+<span class="hljs-number">1</span> ,r);<br>        <span class="hljs-built_in">pushup</span>(u);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>modify  修改某个点的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> v)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(tr[u].l == tr[u].r ) tr[u].sum += v;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(x &lt;= mid) <span class="hljs-built_in">modify</span>(u&lt;&lt;<span class="hljs-number">1</span>, x , v);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span> , x , v);<br>        <span class="hljs-built_in">pushup</span>(u);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>query   查询</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(tr[u].l&gt;=l &amp;&amp; tr[u].r&lt;=r) <span class="hljs-keyword">return</span> tr[u].sum;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(l &lt;= mid) sum += <span class="hljs-built_in">query</span>(u&lt;&lt;<span class="hljs-number">1</span> , l ,mid);<br>        <span class="hljs-keyword">if</span>(r &gt; mid)  sum += <span class="hljs-built_in">query</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,l,r);<br>        <span class="hljs-keyword">return</span> sum<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>dp</title>
    <link href="/2023/03/17/dp/"/>
    <url>/2023/03/17/dp/</url>
    
    <content type="html"><![CDATA[<p>介绍简单dp： 01 背包一维二维实现</p><span id="more"></span><h1 id="DP-动态规划-背包"><a href="#DP-动态规划-背包" class="headerlink" title="DP(动态规划)-背包"></a>DP(动态规划)-背包</h1><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><ul><li><p>题目</p><p>有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。第 i 件物品的体积是 v<del>i</del>，价值是 w<del>i</del>。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。</p></li><li><p>为什么称作01背包，因为对于每个物品，只对应选或者不选两种状态，因此称为01背包</p></li></ul><p><strong>主要思想：</strong></p><ul><li>状态表示: 我们用<code>f[i][j]</code>来表示，前<code>i</code>个物品，最大容量是<code>j</code>，可以得到的最大价值</li><li>状态计算:<ul><li>对于<code>f[i][j]</code>，第 i 个物品，我们有两种选择<ul><li>不选他: <code>f[i][j]=f[i-1][j]</code>，将第 i 个物品剔除然后选最大</li><li>选他: <code>f[i][j]=f[i-1][j-v[i]]+w[i]</code>，先将第 i 个物品放入背包，然后在前 i-1 个物品，容量为 j -v[i]的状态下找最大</li></ul></li><li>因此得出状态方程: <code> f[i][j] = max(f[i-1][j],f[i-1][j-v[i]]+w[i])</code></li></ul></li></ul><img src="https://img-blog.csdnimg.cn/119dcd0622ed424783892acdc976a3f5.png" alt="img" style="zoom: 50%;" /><h3 id="二维朴素版"><a href="#二维朴素版" class="headerlink" title="二维朴素版"></a>二维朴素版</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> v[N],w[N];<br><span class="hljs-type">int</span> f[N][N];<br><span class="hljs-comment">//对于f[i][j]，当i或者j为0时，f[i][j] = 0</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i++) cin&gt;&gt;v[i]&gt;&gt;w[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n; i++ )&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt;= m ;j++)&#123;<br>            <span class="hljs-comment">// 当前背包容量装不进第i个物品，则价值等于前i-1个物品</span><br>            <span class="hljs-keyword">if</span>(j &lt; v[i]) f[i][j] = f[i<span class="hljs-number">-1</span>][j];<br>            <span class="hljs-comment">// 可以装第i个物品，决策是否选他，用max来比较</span><br>            <span class="hljs-keyword">else</span> f[i][j] = <span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j],f[i<span class="hljs-number">-1</span>][j-v[i]]+w[i]);<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;f[n][m]&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="一维终极版"><a href="#一维终极版" class="headerlink" title="一维终极版"></a>一维终极版</h3><p>可以看做我们将 i-1 层的拷贝下来</p><p>01背包从大到小</p><p>完全背包从小到大</p>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从BST到高维数据search</title>
    <link href="/2022/02/02/%E4%BB%8EBST%E5%88%B0%E9%AB%98%E7%BB%B4%E6%95%B0%E6%8D%AEsearch/"/>
    <url>/2022/02/02/%E4%BB%8EBST%E5%88%B0%E9%AB%98%E7%BB%B4%E6%95%B0%E6%8D%AEsearch/</url>
    
    <content type="html"><![CDATA[<p>quadTree，kdTree</p><span id="more"></span><h1 id="Lecture-19-Multi-Dimensional-Data"><a href="#Lecture-19-Multi-Dimensional-Data" class="headerlink" title="Lecture 19: Multi-Dimensional Data"></a>Lecture 19: Multi-Dimensional Data</h1><h2 id="Range-Finding-and-Nearest-1D-Data"><a href="#Range-Finding-and-Nearest-1D-Data" class="headerlink" title="Range-Finding and Nearest (1D Data)"></a>Range-Finding and Nearest (1D Data)</h2><p>BST中可添加的operation：</p><ul><li>select(int i): Returns the ith smallest item in the set.</li><li>rank(T x): Returns the “rank” of x in the set (opposite of select).</li><li>subSet(T from, T to): Returns all items between from and to.</li><li>nearest(T x): Returns the value closest to x.<ul><li>实现：Just search for N and record closest item seen</li></ul></li></ul><p>直到现在，我们总是在一维数据中比较，但是不是所有的item都能只在一个维度中完成比较的</p><h2 id="Multi-dimensional-Data"><a href="#Multi-dimensional-Data" class="headerlink" title="Multi-dimensional Data"></a><strong>Multi-dimensional Data</strong></h2><p>我们想在二维空间中实现</p><ul><li>2D Range Searching: How many objects are in the highlighted rectangle(矩形)?  注意这个操作其实就是上面一维数据中的subset的推广</li><li>Nearest</li></ul><p>Ideally, we’d like to store our data in a format (like a BST) that allows more efficient approaches than just iterating over all objects.</p><p><strong>BST of 2D</strong></p><p>我们需要做出选择，是以x坐标比较(X-Based Tree)，还是以y坐标(Y-Based Tree)比较来建立我们的BST，无论哪一种，我们都会丢失掉一些信息，这会让我们的search变慢</p><h3 id="QuadTrees"><a href="#QuadTrees" class="headerlink" title="QuadTrees"></a><strong>QuadTrees</strong></h3><p>类似x，y坐标系，我们将2D空间分出四部分，NW(西北)，NE(东北)，SW(西南)，SE(东南)</p><p>Every Node has four children:</p><ul><li>Top left, a.k.a. northwest.</li><li>Top right, a.k.a. northeast.</li><li>Bottom left, a.k.a. southwest.</li><li>Bottom right, a.k.a. southeast. </li></ul><p>注意，在插入生成QuadTrees时，我们也需要沿着root出发，再依次顺着树枝往下走，直到找到合适的地方插入</p><p><a href="https://docs.google.com/presentation/d/1vqAJkvUxSh-Eq4iIJZevjpY29nagNTjx-4N3HpDi0UQ/pub?start=false&loop=false&delayms=3000">QuadTrees Insertion Demo</a></p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081113875.png" alt="image-20230218204014098" style="zoom:67%;" /><p><a href="https://docs.google.com/presentation/d/1ZVvh_Q15Lh2D1_NnzZ4PR_aDsLBwvAU9JYQAwlSuXSM/edit?usp=sharing">Range Search Demo</a></p><p>以上是2D情况，对于3D，我们可以用8叉树来表示空间并进行高效地search，以此类推，来表示更高维度(大于3 dimensions的数据真的存在吗，有什么用？You may want to organize data on a large number of dimensions.Example: Want to find songs with the following features:Length between 3 minutes and 6 minutes.Between 1000 and 20,000 listens.Between 120 to 150 BPM.Were recorded after 2004.)</p><p>我们可以简单地增加子结点的个数，但这会显得臃肿，因此我们引出一种简洁但是对任何维度都适用的——k-d Tree</p><h3 id="k-d-Tree"><a href="#k-d-Tree" class="headerlink" title="k-d Tree"></a>k-d Tree</h3><p>有点类似于我们最早提出BST的X-Based Tree and Y-Based Tree，但是有所改进，对于2D，我们对于每一层比较的标准是按照顺序x-y-x-y…，3D(x-y-z-x-y-z…)</p><p>k-d tree example for 2-d:</p><ul><li>Basic idea, root node partitions entire space into left and right (by x).</li><li>All depth 1 nodes partition subspace into up and down (by y).</li><li>All depth 2 nodes partition subspace into left and right (by x).</li></ul><p><a href="https://docs.google.com/presentation/d/1WW56RnFa3g6UJEquuIBymMcu9k2nqLrOE1ZlnTYFebg/edit?usp=sharing">K-d tree insertion demo</a>.</p><p>k-d Tree对待比较中的平局，可以看做大于 or 小于，选定了就不能再改变了。</p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081109939.png" alt="image-20230218205046614" style="zoom:67%;" /><p>k-d nearest (始终是沿着建立好的k-d Tree来搜索)</p><ul><li>You always explore the good side [the old version performed an unnecessary check!</li><li>You only explore the bad side if there’s a chance that it could contain something better.</li></ul><p>k-d nearest，先看好的一方，在判断坏的一方是否值得一看</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">nearest(Node n, Point goal, Node <span class="hljs-keyword">best):</span><br><span class="hljs-keyword"></span>If n is null, return <span class="hljs-keyword">best</span><br><span class="hljs-keyword"></span>If n.<span class="hljs-keyword">distance(goal) </span>&lt; <span class="hljs-keyword">best.distance(goal), </span><span class="hljs-keyword">best </span>= n<br>If goal &lt; n (according to n’s comparator):<br>goodSide = n.”left”Child<br><span class="hljs-keyword">badSide </span>= n.”right”Child<br><span class="hljs-symbol">else:</span><br>goodSide = n.”right”Child<br><span class="hljs-keyword">badSide </span>= n.”left”Child<br><span class="hljs-keyword">best </span>= nearest(goodSide, goal, <span class="hljs-keyword">best)</span><br><span class="hljs-keyword"></span>If <span class="hljs-keyword">bad </span>side could still have something useful<br><span class="hljs-keyword">best </span>= nearest(<span class="hljs-keyword">badSide, </span>goal, <span class="hljs-keyword">best)</span><br><span class="hljs-keyword"></span>return <span class="hljs-keyword">best</span><br></code></pre></td></tr></table></figure><h3 id="Uniform-partitioning"><a href="#Uniform-partitioning" class="headerlink" title="Uniform partitioning"></a>Uniform partitioning</h3><p>把空间均分为几部分(类似hashtable中的bucket)，然后将数据存储在bucket中</p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081114279.png" alt="image-20230218210734514" style="zoom:67%;" />]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>排序算法专题</title>
    <link href="/2022/01/22/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/"/>
    <url>/2022/01/22/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>CS61B排序：选择排序，堆排序，归并排序，插入排序，希尔排序，快排</p><span id="more"></span><h1 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h1><p><strong>inversion</strong>(逆序对)</p><ul><li>An <strong>inversion</strong> is a pair of elements that are out of order with respect to &lt;. </li></ul><p>一种看待sort的方法：</p><ul><li>Given a sequence of elements with Z inversions.</li><li>Perform a sequence of operations that reduces inversions to 0.</li></ul><p>Sort中，我们关注两种复杂度</p><ul><li>time complexity</li><li>space complexity (<strong>extra</strong> memory usage)</li></ul><h2 id="Selection-Sort"><a href="#Selection-Sort" class="headerlink" title="Selection Sort"></a>Selection Sort</h2><p>θ(N^2^)</p><ul><li>Find smallest item.</li><li>Swap this item to the front and ‘fix’ it.</li><li>Repeat for unfixed items until all items are fixed.</li></ul><h2 id="Heap-Sort"><a href="#Heap-Sort" class="headerlink" title="Heap Sort"></a>Heap Sort</h2><blockquote><p>基于Selection Sort，但是加速了找smallest item这个过程</p></blockquote><p>必须用max-heap，why？</p><ul><li>min-heap也可以work，但是我们如果想直接在该数组中建立堆(without extra output array)来节省space complexity，min-heap不能做到这点</li></ul><p><strong>naive(朴素版)heap sort</strong></p><ul><li>Insert all items into a max heap, and discard input array. Create output array.</li><li>Repeat N times:<ul><li>Delete largest item from the max heap.</li><li>Put largest item at the end of the unused part of the output array.</li></ul></li></ul><p>runtime</p><ul><li>time complexity：θ(NlogN)</li><li>space complexity：θ(N) 因为开辟了额外的输出数组，长度为N<ul><li>这比选择排序worse，但是我们下面的策略可以改进</li></ul></li></ul><p><strong>In-place Heapsort</strong></p><blockquote><p>no extra array，直接在原数组中建立堆(heapify)，之后和朴素版的heapsort就一致了</p><p>为什么可以这样？因为按照层序从后往前的过程中，我们sink之后就保证以该位置为root的一个子堆满足heap的性质，因此我们从小到大地建立了完整有效地堆</p></blockquote><ul><li>Bottom-up heapify input array.<ul><li>To bottom-up heapify, just <strong>sink nodes in reverse level order.</strong></li><li>After sink(k), guaranteed that tree rooted at position k is a heap.</li></ul></li><li>Repeat N times:<ul><li>Delete largest item from the max heap, swapping root with last item in the heap.</li></ul></li></ul><p><a href="https://docs.google.com/presentation/d/1SzcQC48OB9agStD0dFRgccU-tyjD6m3esrSC-GLxmNc/edit?usp=sharing">in-place heap sort Demo</a></p><p>runtime</p><ul><li>time complexity：θ(NlogN)</li><li>space complexity：θ(1)</li></ul><h2 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort"></a>Merge Sort</h2><blockquote><p>chapt 8里面讲过，依次挨个地合并两个有序的数组</p></blockquote><p>看这个Demo就理解了 <a href="https://docs.google.com/presentation/d/1h-gS13kKWSKd_5gt2FPXLYigFY4jf5rBkNFl3qZzRRw/edit?usp=sharing">Merge Sort Demo</a></p><ul><li>Split items into 2 roughly even pieces.</li><li>Mergesort each half (steps not shown, this is a recursive algorithm!)</li><li>Merge the two sorted halves to form the final result.<ul><li><strong>Compare input[i] &lt; input[j] (if necessary).</strong></li><li>Copy smaller item and increment p and i or j.</li></ul></li></ul><h2 id="insertion-sort"><a href="#insertion-sort" class="headerlink" title="insertion sort"></a>insertion sort</h2><p><strong>naive</strong></p><ul><li>Starting with an empty output sequence.</li><li>Add each item from input, inserting into output at right point.</li></ul><p><strong>in-place</strong></p><ul><li>在该数组内用swap，而不是再开一个数组</li><li>Repeat for i = 0 to N - 1:<ul><li>Designate item i as the traveling item.</li><li>Swap item backwards until traveller is in the right place among all previously examined items.</li></ul></li></ul><p><strong>note：</strong></p><p>对于差不多有序的序列来说很快</p><p>runtime与inversion(逆序对)的个数成正比</p><p>一些经验表示，对于&lt;15个元素的序列，insertion sort是所有排序中最快(粗略的解释：Divide and conquer algorithms like heapsort / mergesort spend too much time dividing, but insertion sort goes straight to the conquest.)</p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081114681.png" alt="image-20230219213456835" style="zoom:67%;" /><h2 id="Shell-Sort"><a href="#Shell-Sort" class="headerlink" title="Shell Sort"></a>Shell Sort</h2><blockquote><p>利用insertion对元素少的序列很快这一特点</p></blockquote><ul><li>将序列中，每间隔d的index分为一组，对该组进行insertion sort</li><li>不断<code>d--</code>，直到d=1，整个序列恰恰都在一组，完成排序</li></ul><h2 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h2><blockquote><p>一个好的quick sort：需要有</p><ul><li>pick good pivot</li><li>good partition strategy</li></ul></blockquote><p>Quicksorting N items: (<a href="https://docs.google.com/presentation/d/1QjAs-zx1i0_XWlLqsKtexb-iueao9jNLkN-gW9QxAD0/edit?usp=sharing">Demo</a>)</p><h3 id="The-Core-Idea-of-Tony’s-Sort-Partitioning"><a href="#The-Core-Idea-of-Tony’s-Sort-Partitioning" class="headerlink" title="The Core Idea of Tony’s Sort: Partitioning"></a><strong>The Core Idea of Tony’s Sort: Partitioning</strong></h3><p>To partition an array a[] on element x=a[i] is to rearrange a[] so that: (partition作用的那个i，就叫做pivot)</p><ul><li>x moves to position j (may be the same as i)</li><li>All entries to the left of x are &lt;= x.</li><li>All entries to the right of x are &gt;= x.</li></ul><p>实现：</p><ul><li>可以用BST，把pivot当做root，比他小的都在left，比他大的都在right</li><li>simple but not fastest: 3 scan<ul><li>Create another array. Scan and copy all the red items to the first R spaces. Then scan for and copy the white item. Then scan and copy the blue items to the last B spaces.</li></ul></li></ul><p>observations:</p><ul><li>当我们partition(k=a[i])之后，k就在它的最终位置上不动了了(左边的都比他小，右边的都比他大)</li><li>Can sort two halves separately, e.g. through recursive use of partitioning.左右两边完全独立了</li></ul><p><strong>步骤：</strong></p><ul><li>Pick the pivot to be partitioned:  e.g.Partition on leftmost item. </li><li>Quicksort left half.</li><li>Quicksort right half.</li></ul><h3 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h3><ul><li>值得一提的是，quick sort的速度与选取的pivot最终落在的位置有很大关系</li></ul><p><strong>Best Case: Pivot Always Lands in the Middle</strong> </p><p>递归深度logN</p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081128345.png" alt="image-20230220200918361" style="zoom: 50%;" /><p><strong>Worst Case: Pivot Always Lands at Beginning of Array</strong></p><p>递归深度N</p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081128289.png" alt="image-20230220201459150" style="zoom: 50%;" /><p>一个有趣的观察：</p><ul><li>Quick Sort的过程其实就是BST建立的过程，我们可以看到每次选取的pivot都是子树的一个根，向下建立BST，so crazy！</li><li>回想Random insertion into a BST takes O(N log N) time.</li></ul><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081128194.png" alt="image-20230220202301322" style="zoom: 50%;" /><p>问题来了，N^2^与NlogN的差别可谓巨大，所以我们该怎么避免worst case的出现？</p><h3 id="Avoiding-the-Quicksort-Worst-Case"><a href="#Avoiding-the-Quicksort-Worst-Case" class="headerlink" title="Avoiding the Quicksort Worst Case"></a><strong>Avoiding the Quicksort Worst Case</strong></h3><p>小心两种特殊的序列，他们可能会使你的策略陷入N^2^</p><ul><li>Bad ordering: Array already in sorted order.</li><li>Bad elements: Array with all duplicates.</li></ul><p>we mainly focus on</p><ul><li>How you select your pivot.</li><li>How you partition around that pivot.</li></ul><p><strong>Philosophy 1: Randomness</strong> </p><blockquote><p>随机性是一个好的Quick Sort所<strong>必需</strong>的，对于一些确定的or伪随机的，总会存在潜在的危险. See McIlroy’s “<a href="http://www.cs.dartmouth.edu/~doug/mdmspe.pdf">A Killer Adversary for Quicksort</a>”</p></blockquote><ul><li>Strategy #1: Pick pivots randomly.</li><li>Strategy #2: Shuffle(搅乱) before you sort.</li></ul><p><strong>Philosophy 2b: Smarter Pivot Selection</strong> </p><blockquote><p>Use the median (or an approximation) as our pivot.也就是选取的pivot正好落在中间</p></blockquote><p>利用partition来寻找中值pivot</p><ul><li>一直partition，让partition(k)之后k的位置往中间靠，直到k落在length/2的位置</li></ul><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081114666.png" alt="image-20230220210311996" style="zoom: 50%;" /><p>worst case：θ(N^2^)    i.e.[1 2 3 4 5 6 7 8 9 10 … N]</p><p>average case：θ(N)</p><p><strong>Hoare Partitioning</strong>(双指针法)</p><p><a href="https://docs.google.com/presentation/d/1DOnWS59PJOa-LaBfttPRseIpwLGefZkn450TMSSUiQY/pub?start=false&loop=false&delayms=3000">Demo</a></p><p>Create L and G pointers at left and right ends.</p><ul><li><p>L pointer is a friend to small items,and hates large or equal items.(注意对于equal的我们不管，不然对于全重复元素的序列我们会陷入worst case)</p></li><li><p>G pointer is a friend to large items,and hates small or equal items.</p></li><li><p>Walk pointers towards each other,stopping on a hated item.</p><ul><li><p>When both pointers have stopped,swap and move pointers by one.</p></li><li><p>When pointers cross,you are done walking.</p></li></ul></li><li><p>Swap pivot  with G.</p></li></ul><p><strong>Sorting Properties</strong></p><p>stability</p><ul><li>Equivalent items don’t ‘cross over’ when being stably sorted.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BST与平衡树</title>
    <link href="/2022/01/17/BST%E4%B8%8E%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    <url>/2022/01/17/BST%E4%B8%8E%E5%B9%B3%E8%A1%A1%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>CS61B的BST，B树，23树，红黑树，LLRB 原理</p><span id="more"></span><h2 id="Chapt10-ADTs-Sets-Maps-BSTs"><a href="#Chapt10-ADTs-Sets-Maps-BSTs" class="headerlink" title="Chapt10 ADTs, Sets, Maps, BSTs"></a>Chapt10 ADTs, Sets, Maps, BSTs</h2><p>加快链表的查找也可以使用跳表来优化  θ(logN)</p><h3 id="BST-Binary-Search-Tree"><a href="#BST-Binary-Search-Tree" class="headerlink" title="BST(Binary Search Tree)"></a>BST(Binary Search Tree)</h3><p>一篇好文<a href="https://medium.com/@liuamyj/its-triangles-all-the-way-down-part-1-17f932f4c438">It’s Triangles All the Way Down (Part 1) | by Amy Liu | Medium</a></p><p>二分查找树</p><p><strong>提出BST的原因</strong></p><ul><li>对于LinkedList来说，我们search时最坏情况需要遍历整个list，尽管list是有序的，对于ordered array来说，我们可以通过二分查找来加快查找速度</li><li>受array的启发，我们可以在LinkedList的middle node设置一个引用，然后将middle node左边的List的指向翻转，这样我们就可以从middle位置根据大小向两边查找了</li><li>我们可以做得更好，在左右部分，递归地，我们继续添加他们各自middle node的使用，直到每个部分只剩1个，这就会形成BST</li></ul><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081111897.png" alt="image-20230128191549116" style="zoom: 50%;" /><ul><li><strong>Binary Search Trees</strong>:<ul><li>Every key in the left subtree is less than X’s key.</li><li>Every key in the right subtree is greater than X’s <strong>key.</strong></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BST</span>&lt;Key&gt; &#123;<br>    <span class="hljs-keyword">private</span> Key key;<br>    <span class="hljs-keyword">private</span> BST left;<br>    <span class="hljs-keyword">private</span> BST right;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BST</span><span class="hljs-params">(Key key, BST left, BST Right)</span> &#123;<br>        <span class="hljs-built_in">this</span>.key = key;<br>        <span class="hljs-built_in">this</span>.left = left;<br>        <span class="hljs-built_in">this</span>.right = right;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BST</span><span class="hljs-params">(Key key)</span> &#123;<br>        <span class="hljs-built_in">this</span>.key = key;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BST-operations"><a href="#BST-operations" class="headerlink" title="BST operations"></a><strong>BST operations</strong></h3><ul><li><p><code>static BST find(BST T, Key key)</code></p><ul><li><p>T是BST的root，return 与key匹配的node</p></li><li><p>```java<br>static BST find(BST T, Key sk){</p><pre><code class="hljs">if(T==null)&#123;    return null;&#125;if(sk.equals(T.key))&#123;    return T;&#125;else if(sk&lt;T.key)&#123;    find(T.left,sk);&#125;else if(sk&gt;T.key)&#123;    find(T.right,sk);&#125;</code></pre><p>}</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><br>* `<span class="language-javascript"><span class="hljs-keyword">static</span> <span class="hljs-variable constant_">BST</span> <span class="hljs-title function_">insert</span>(<span class="hljs-variable constant_">BST</span> T, <span class="hljs-title class_">Key</span> ik)</span>`<br><br>  * 我们总是在叶子结点进行insert！<br><br>  * <span class="hljs-keyword">return</span> the full BST <span class="hljs-keyword">with</span> the <span class="hljs-keyword">new</span> node inserted <span class="hljs-keyword">in</span> the correct position.<br><br>  * BST 不能有重复的<br><br>  * If found, <span class="hljs-keyword">do</span> nothing.<br><br>  * If <span class="hljs-keyword">not</span> found:<br><br>    * Create <span class="hljs-keyword">new</span> node.<br>    * <span class="hljs-built_in">Set</span> appropriate link<br><br>  * ```<span class="language-javascript">java</span><br><span class="language-javascript">    <span class="hljs-keyword">static</span> <span class="hljs-variable constant_">BST</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">BST T, Key ik</span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">null</span>)&#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">BST</span>(ik);</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        <span class="hljs-keyword">if</span>(ik&lt;T.<span class="hljs-property">key</span>)&#123;</span><br><span class="language-javascript">            T.<span class="hljs-property">left</span>=<span class="hljs-title function_">insert</span>(T.<span class="hljs-property">left</span>,ik);</span><br><span class="language-javascript">        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ik&gt;T.<span class="hljs-property">key</span>)&#123;</span><br><span class="language-javascript">            T.<span class="hljs-property">right</span>=<span class="hljs-title function_">insert</span>(T.<span class="hljs-property">right</span>,ik);</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> T;</span><br><span class="language-javascript">    &#125;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>static BST delete(BST T,key dk)</code></p><ul><li><p><strong>Hibbard deletion</strong></p></li><li><p>has <strong>no children</strong></p><ul><li>删除的肯定是叶子结点，只需要改变该叶子结点的父亲，</li></ul></li><li><p>has <strong>1 child</strong></p><ul><li>把该结点父亲结点的pointer指向该结点的子结点 we can just reassign the parent’s child pointer to the node’s child and the node will eventually be garbage collected</li></ul></li><li><p>has <strong>2 children</strong></p><ul><li><p>目标是找到一个满足左边的都比他小，右边都比他大的node来代替需要删除的node</p></li><li><p>删除有两个子结点的：对该子树，选择该子树中，左边最右(predecessor)，或者右边最左(sucessor)的来代替root</p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081111870.png" alt="image-20230128232228097" style="zoom:50%;" /></li></ul></li></ul></li></ul><p>θ(logN)：This was because we could eliminate half of the elements at every step of our search</p><h2 id="Chapt11：Balanced-Trees"><a href="#Chapt11：Balanced-Trees" class="headerlink" title="Chapt11：Balanced Trees"></a>Chapt11：Balanced Trees</h2><ul><li>The <strong>depth</strong> of a node：距离根结点有多远</li><li>The <strong>“height” of a tree</strong> is the depth of its deepest leaf, e.g. height(T) = 4.  <strong>worst case</strong></li><li>The <strong>“average depth”</strong> of a tree is the average depth of a tree’s nodes.  <strong>average case</strong><ul><li>(<strong>0</strong>x1 + <strong>1</strong>x2 + <strong>2</strong>x4 + <strong>3</strong>x6 + <strong>4</strong>x1)/(1+2+4+6+1) = 2.35</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081112370.png" alt="image-20230128232650535" style="zoom:67%;" /><p>BSTs have:</p><ul><li>Worst case Θ(N) height.</li><li>Best case Θ(log N) height.</li></ul><p>对于BST来说，不同的插入顺序会形成不同height的tree，也会造成不同的查找速度</p><p><strong>Randomlized Trees</strong></p><p>现实中插入往往是随机的，已经证明，随机插入的tree</p><ul><li>average depth：~ 2 ln N = Θ(log N)</li><li>height：~ 4.311 ln N= Θ(log N)</li><li>note：~ 和 Θ是一样的，但没有丢掉常数</li></ul><p>因此，随机插入时BST的表现不错，但是现实中我们不能做到处处随机，因此我们引出B-Trees来解决这个问题(在任意插入顺序下都有很好的height)</p><h3 id="B-tree"><a href="#B-tree" class="headerlink" title="B tree"></a><strong>B tree</strong></h3><blockquote><p>BST的问题是：我们一直在叶结点之后插入，这会导致height增加；那么，我们是否可以一直不往叶结点插入，来保证tree balance</p></blockquote><p>可以处理任何输入顺序，让树饱满，平衡</p><h4 id="Avoiding-Imbalance-through-Overstuffing"><a href="#Avoiding-Imbalance-through-Overstuffing" class="headerlink" title="Avoiding Imbalance through Overstuffing"></a><strong>Avoiding Imbalance through Overstuffing</strong></h4><ul><li>Never add new leaves at the bottom.</li><li>just add to a current leaf node. </li></ul><p>这也会造成一个问题，我们的叶子结点承载了太多(Leaf nodes can get too juicy.)，在叶子结点内的search是Θ(N)，退化了</p><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081112835.png" alt="image-20230129174359497"></p><h4 id="solution"><a href="#solution" class="headerlink" title="solution"></a><strong>solution</strong></h4><ul><li>Set a limit L on the number of items, say L=3.</li><li>If any node has more than L items, give an item to parent.<ul><li>Which one? Let’s say (arbitrarily) the left-middle. 超载时有4个，选取中间靠左那个向上移</li><li>移了之后re-arrange the children accordingly.</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081112347.png" alt="image-20230129175307276" style="zoom:50%;" /><p>这些树被称作B-Tree or 2-3-4 tree or 2-3 tree，2-3-4的意思是每个结点的子结点可能有2,3,4之一</p><p>The process of adding a node to a 2-3-4 tree is:</p><ol><li>We still always inserting into a leaf node, so take the node you want to insert and traverse down the tree with it, going left and right according to whether or not the node to be inserted is greater than or smaller than the items in each node.</li><li>After adding the node to the leaf node, if the new node has 4 nodes, then pop up the middle left node and re-arrange the children accordingly.</li><li>If this results in the parent node having 4 nodes, then pop up the middle left node again, rearranging the children accordingly.</li><li>Repeat this process until the parent node can accommodate or you get to the root.</li></ol><p>Observation: Splitting-trees have <strong>perfect balance</strong>.</p><ul><li>如果分裂root，那么每个结点正好被压低一级，height+1</li><li>如果分裂叶子结点或者内部的结点，height不变</li><li>对于B树来说，不管是怎样的插入顺序，B-Tree都是稠密的，尽管可能在height上有细微的差别</li></ul><h4 id="B-Tree-Invariants"><a href="#B-Tree-Invariants" class="headerlink" title="B-Tree Invariants"></a><strong>B-Tree Invariants</strong></h4><p>由于B-Tree生成的独特方式，有以下不变的性质</p><ul><li>所有的叶结点到root的距离都相等</li><li>所有的非叶结点node有k个，那么它的子结点一定有k+1个</li></ul><p>这些不变量保证了B-Tree的稠密</p><h4 id="B-Tree-runtime"><a href="#B-Tree-runtime" class="headerlink" title="B-Tree runtime"></a>B-Tree runtime</h4><p>L: Max number of items per node.<br>Height: Between ~logL+1(N) and ~log2(N)</p><p>最高是每个叶子结点只包含一个，最低是每个叶子结点包含L个</p><ul><li><code>contains</code> O(logN)</li><li><code>add</code> O(logN)</li></ul><h4 id="2-3-Tree-Deletion"><a href="#2-3-Tree-Deletion" class="headerlink" title="2-3 Tree Deletion"></a>2-3 Tree Deletion</h4><p>In a 2-3 Tree, when we delete α from a node with 2 or more children, we:</p><ul><li><p><strong>Swap</strong> the value of the successor with α.   note:Successor will always be in a <strong>leaf node</strong></p></li><li><p>Then we <strong>delete</strong> the successor value.</p><ul><li><p>**Multi-Key Leaves **</p><ul><li><p>simply remove the item from the leaf</p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081112794.png" alt="image-20230129194308173" style="zoom:67%;" /></li></ul></li><li><p><strong>Single-Key Leaves</strong></p><ul><li>cannot simply remove the node entirely (Any node with k items must have k + 1 children! Instead, we’ll leave an empty node, which must be filled.)</li><li>so how to <strong>Filling in Empty Nodes (FIEN)</strong>?</li></ul></li></ul></li></ul><p><strong>Filling in Empty Nodes (FIEN)</strong></p><ol><li><p>兄弟结点 Mutil-key Sibling</p><ul><li><p>X steals parent’s item. Parent steals sibling’s item.</p></li><li><p>If X was not a leaf node, X steals one of sibling’s subtrees (to keep is a B-Tree).</p></li><li><p>x不是叶子结点<img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081112621.png" alt="image-20230129195026532" style="zoom:50%;" /></p></li><li><p>x是叶子结点<img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081122359.png" alt="image-20230129195130561" style="zoom:50%;" /></p></li></ul></li><li><p>Multi-key parent  ( siblings on the right all have one key)</p><ul><li>X and right sibling steal parent’s keys. Middle sibling moves into the parent.</li><li>Subtrees are passed along so that every node has the correct children.</li><li><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081112588.png" alt="image-20230129201754497" style="zoom: 50%;" /></li></ul></li><li><p>single-key parent and Sibling( The parent and all siblings have only one item.)</p><ul><li>Combine 1 sibling and parent into a single node that replaces X. Send the blank X up one level.</li><li>If blank ends up as the new root, just delete the blank and we are done.</li><li><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081112124.png" alt="image-20230129225609470" style="zoom:50%;" /></li></ul></li></ol><h3 id="BST-Rotating-Tree"><a href="#BST-Rotating-Tree" class="headerlink" title="BST Rotating Tree"></a>BST Rotating Tree</h3><blockquote><p>B-Tree实现起来很困难，尽管他快，让我们找另外一种同样快且实现简单的方法</p><p>由于插入顺序的不同，会形成多种B-Tree，其数目是可以计算的catalan(卡特兰数) <a href="https://en.wikipedia.org/wiki/Catalan_number">Catalan number - Wikipedia</a></p></blockquote><p>rotate可以在O(N)的时间内将树旋转为稠密的 (can move from any configuration to any other in 2n - 6 rotations )</p><p>The formal definition of rotation is:</p><p><code>rotateLeft(G)</code>: Let x be the right child of G. Make G the new left child of x.</p><ul><li>另一种理解方式：将right的x与G合并，然后向下发送合并之后的left(也就是G)，然后调整树的结构使其符合BST</li></ul><p><code>rotateRight(G)</code>: Let x be the left child of G. Make G the new right child of x.</p><ul><li>把G和left的x合并，然后向下发送合并之后的right(也就是G)，然后调整树使其符合BST</li></ul><p>不能rotate空的，无意义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">rotateRight</span><span class="hljs-params">(Node h)</span> &#123;<br>    <span class="hljs-comment">// assert (h != null) &amp;&amp; isRed(h.left);</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> h.left;<br>    h.left = x.right;<br>    x.right = h;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-comment">// make a right-leaning link lean to the left</span><br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">rotateLeft</span><span class="hljs-params">(Node h)</span> &#123;<br>    <span class="hljs-comment">// assert (h != null) &amp;&amp; isRed(h.right);</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> h.right;<br>    h.right = x.left;<br>    x.left = h;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><p>在建造的时候保持稠密</p><h3 id="Red-Black-Tree"><a href="#Red-Black-Tree" class="headerlink" title="Red-Black Tree"></a>Red-Black Tree</h3><blockquote><p>a specific tree data structure that remains balanced through using rotations.</p><p>一般的BST需要O(N)的时间来rotate来达到balance，这是在建造好之后采取的措施，亡羊补牢；下面介绍一种在建造的时候利用rotate来保持balance和bushy的结构</p></blockquote><p>Our goal: Build a BST that is structurally identical to a 2-3 tree.Since 2-3 trees are balanced, so will our special BSTs.</p><p>一个很好的exercise <a href="https://docs.google.com/presentation/d/1jgOgvx8tyu_LQ5Y21k4wYLffwp84putW8iD7_EerQmI/edit#slide=id.g463de7561_042">LLRB Insertion Demo - Google 幻灯片</a></p><h4 id="Representing-a-2-3-Tree-as-a-BST"><a href="#Representing-a-2-3-Tree-as-a-BST" class="headerlink" title="Representing a 2-3 Tree as a BST"></a><strong>Representing a 2-3 Tree as a BST</strong></h4><p>A 2-3 tree的2-nodes(可以有两个子结点的结点)和BST的完全一致</p><p>对于3-nodes来说：两种可能的方法</p><ol><li><p>“glue” node that doesn’t hold any information and only serves to show that its 2 children are actually a part of one node.</p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081112134.png" alt="image-20230130172316301" style="zoom:50%;" /><ul><li>缺点是不优雅，code will be ugly，而且d的right实际上浪费了</li></ul></li><li><p>Create “glue” links with the smaller item <strong>off to the left</strong>  (这种更好)</p><ul><li><p>make the left element a child of the right one.</p></li><li><p>We show that a link is a glue link by making it <strong>red</strong>.</p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081112053.png" alt="image-20230130172707741" style="zoom:50%;" /></li></ul></li></ol><h4 id="LLRB"><a href="#LLRB" class="headerlink" title="LLRB"></a><strong>LLRB</strong></h4><p>A BST with left glue links that represents a 2-3 tree is often called a “Left Leaning Red Black Binary Search Tree” or LLRB.</p><ul><li>LLRBs are normal BSTs! </li><li>There is a <strong>1-1 correspondence</strong> between an LLRB and an equivalent 2-3 tree.</li><li>The red is just a convenient fiction. Red links don’t “do” anything special.</li></ul><p><strong>LLRB’s的特征</strong></p><p>Here are the properties of LLRB’s:</p><ul><li>与 2-3 trees 1-1对应.</li><li>No node has 2 red links.</li><li>There are no red right-links.</li><li>Every path from root to leaf has same number of black links (because 2-3 trees have same number of links to every leaf).</li><li>Height is no more than ~2x height of corresponding 2-3 tree.</li></ul><p>What is the maximum height of the corresponding LLRB? (看黑线和红线之和)</p><ul><li>Total height is H (black) + H + 1 (red) = 2H + 1.</li></ul><p><strong>LLRB Construction</strong></p><ul><li>Insert as usual into a BST.</li><li>Use zero or more rotations to maintain the 1-1 mapping.</li></ul><h4 id="Inserting-into-LLRB"><a href="#Inserting-into-LLRB" class="headerlink" title="Inserting into LLRB"></a>Inserting into LLRB</h4><p>为了保持LLRB与2-3树的1-1对应，我们需要在LLRB中处理2-3树插入的各种情况</p><ol><li><p><strong>Task 1: insertion color</strong>: 在2-3 tree中，我们总是向叶子结点add，因此link的颜色总是应该为红色</p></li><li><p><strong>Task 2: insertion on the right</strong>: 回想一下，我们使用的是left-leaning的红色黑色树，这意味着我们永远不可能有一个right的红色链接。如果我们插入在右边，我们将需要使用旋转，以保持 LLRB 不变量。</p><p>但是，如果我们将要在右边加入一个红色链接，而且其左边也是一个红色链接，我们暂时允许这种情况存在，后面解决这种illegal的情况</p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081112211.png" alt="image-20230130174510212" style="zoom:50%;" /></li><li><p>**Task 3: double insertion on the left:**（two consecutive left links）</p><p>If there are 2 left red links, then we have a 4-node which is illegal. First, we will rotate to create the same tree seen in task 2 above. </p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081112848.png" alt="image-20230130174943033" style="zoom:50%;" /></li><li><p><strong>Splitting Temporary 4-Nodes</strong>：Then, in both situations, we will flip the colors of all edges touching S. This is equivalent to pushing up the middle node in a 2-3 tree.</p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081112438.png" alt="image-20230130175007766" style="zoom:50%;" /></li></ol><p>Here is a <strong>summary</strong> of all the operations:</p><ul><li>When inserting: Use a red link.</li><li>If there is aright leaning “3-node”, we have a Left Leaning Violation<ul><li><u>Rotate left</u> the appropriate node to fix.</li></ul></li><li>If there are two consecutive left links, we have an incorrect 4 Node Violation!<ul><li><u>Rotate right</u> the appropriate node to fix.</li></ul></li><li>If there are any nodes with two red children, we have a temporary 4 Node.<ul><li><u>Color flip</u> the node to emulate the split operation.</li></ul></li></ul><ul><li>注意这些情况可能会串联出现</li></ul><p><strong>Runtime</strong> :都是log(N)</p><p>Amazingly, turning a BST into an LLRB requires only 3 clever lines of code.Does not include helper methods (which do not require cleverness).</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">put</span><span class="hljs-params">(Node h, Key key, Value val)</span> &#123;<br>    <span class="hljs-keyword">if</span> (h == <span class="hljs-literal">null</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key, val, RED); &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">cmp</span> <span class="hljs-operator">=</span> key.compareTo(h.key);<br>    <span class="hljs-keyword">if</span> (cmp &lt; <span class="hljs-number">0</span>)      &#123; h.left  = put(h.left,  key, val); &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmp &gt; <span class="hljs-number">0</span>) &#123; h.right = put(h.right, key, val); &#125;<br>    <span class="hljs-keyword">else</span>              &#123; h.val   = val;                    &#125;<br><span class="hljs-comment">//只有下面这三行是额外添加的</span><br>    <span class="hljs-keyword">if</span> (isRed(h.right) &amp;&amp; !isRed(h.left))      &#123; h = rotateLeft(h);  &#125;<br>    <span class="hljs-keyword">if</span> (isRed(h.left)  &amp;&amp;  isRed(h.left.left)) &#123; h = rotateRight(h); &#125;<br>    <span class="hljs-keyword">if</span> (isRed(h.left)  &amp;&amp;  isRed(h.right))     &#123; flipColors(h);      &#125; <br><br>    <span class="hljs-keyword">return</span> h;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><ul><li>Binary search trees are simple, but they are subject to imbalance which leads to crappy runtime.</li><li>2-3 Trees (B Trees) are balanced, but painful to implement and relatively slow.</li><li>LLRBs insertion is simple to implement (but deletion is hard).<ul><li>Works by maintaining mathematical bijection with a 2-3 trees.</li></ul></li><li>Java’s <a href="https://github.com/AdoptOpenJDK/openjdk-jdk11/blob/999dbd4192d0f819cb5224f26e9e7fa75ca6f289/src/java.base/share/classes/java/util/TreeMap.java">TreeMap</a> is a red-black tree (but not left leaning).</li><li>LLRBs maintain correspondence with 2-3 tree, Standard Red-Black trees maintain correspondence with 2-3-4 trees.</li><li>Allows glue links on either side (see <a href="http://en.wikipedia.org/wiki/Red%E2%80%93black_tree">Red-Black Tree</a>).</li><li>More complex implementation, but significantly faster.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>BST</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2022/01/08/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2022/01/08/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p>CS61B 的并查集，从原理到实现，WQU，路径压缩</p><span id="more"></span><h1 id="chapt9-Disjoint-Sets-并查集"><a href="#chapt9-Disjoint-Sets-并查集" class="headerlink" title="chapt9 Disjoint Sets(并查集)"></a>chapt9 Disjoint Sets(并查集)</h1><p>不同并查集的元素也不能相同，而且为正数</p><p>支持两个操作的数据结构</p><ol><li><code>connect(x, y)</code>: connect <code>x</code> and <code>y</code>. Also known as <code>union</code></li><li><code>isConnected(x, y)</code>: returns true if <code>x</code> and <code>y</code> are connected (i.e. part of the same set).</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DisjointSets</span> &#123;<br>    <span class="hljs-comment">/** connects two items P and Q */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span>;<br><br>    <span class="hljs-comment">/** checks to see if two items are connected */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ListOfSets"><a href="#ListOfSets" class="headerlink" title="ListOfSets"></a>ListOfSets</h2><p>最朴素的做法，List存set，<code>List&lt;Set&lt;Integer&gt;&gt;</code></p><p>缺点：每次connect的时候需要遍历，O(N)，并且也不好写出</p><table><thead><tr><th>Implementation</th><th>Constructor</th><th><code>connect</code></th><th><code>isConnected</code></th></tr></thead><tbody><tr><td>ListOfSets</td><td>Θ(N)<a href="https://joshhug.gitbooks.io/hug61b/content/chap9/chap92.html#fn_1">1</a></td><td>O(N)</td><td>O(N)</td></tr></tbody></table><h2 id="Quick-Find"><a href="#Quick-Find" class="headerlink" title="Quick Find"></a>Quick Find</h2><ul><li>数组的索引表示集合的元素</li><li>The <strong>value at an index</strong> is the set number it belongs to.</li><li>只需要确保在一个集合中的元素有相同的id值就可以，这个值是什么并不重要</li></ul><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081111746.png" alt="image-20230125194838220" style="zoom: 80%;" /><ul><li><code>connect</code>：让两个集合的所有元素id改为相同 </li><li><code>isConnected(x, y)</code>：we simply check if <code>id[x] == id[y]</code>. </li></ul><table><thead><tr><th>Implementation</th><th>Constructor</th><th><code>connect</code></th><th><code>isConnected</code></th></tr></thead><tbody><tr><td>QuickFind</td><td>Θ(N)</td><td>Θ(N)</td><td>Θ(1)</td></tr></tbody></table><h2 id="Quick-Union"><a href="#Quick-Union" class="headerlink" title="Quick Union"></a>Quick Union</h2><p>不用id，我们在每个元素的索引存上他parent，如果没有parent，那么该元素为根，我们存上一个负数。这会让我们的集合看起来像个树形结构</p><p>we represent <code>&#123;0, 1, 2, 4&#125;, &#123;3, 5&#125;, &#123;6&#125;</code> as:</p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081111147.png" alt="image-20230125201839631" style="zoom:67%;" /><p>引入一个helper function： <code>find(int item)</code> which returns the root of the tree <code>item</code> is in. For example, for the sets above, <code>find(4) == 0</code>, <code>find(1) == 0</code>, <code>find(5) == 3</code>, etc. Each element has a unique root.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br>    <span class="hljs-keyword">while</span>(parent[x]&gt;<span class="hljs-number">0</span>)&#123;<br>        x=parent[x];<br>    &#125;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>connect(x,y)</code>：将x的parent改为y or 将y的parent改为x</li><li><code>isConnected(x,y)</code> ： check if <code>find(x) == find(y)</code>.</li></ul><table><thead><tr><th>Implementation</th><th>Constructor</th><th><code>connect</code>（主要find操作耗时）</th><th><code>isConnected</code></th></tr></thead><tbody><tr><td>QuickUnion</td><td>Θ(N)</td><td>O(N)</td><td>O(N)</td></tr></tbody></table><h2 id="Weighted-Quick-Union-WQU"><a href="#Weighted-Quick-Union-WQU" class="headerlink" title="Weighted Quick Union (WQU)"></a>Weighted Quick Union (WQU)</h2><p><strong>New rule:</strong> whenever we call <code>connect</code>, we always link the root of the <strong>smaller</strong> tree <strong>to the larger</strong> tree.</p><p>遵循这个规则，我们的tree高度不会超过logN，N是并查集元素的数量，因此<strong>the runtimes of <code>connect</code> and <code>isConnected</code> are bounded by O(log N).</strong></p><blockquote><p>既可以用数量，也可以用高度来衡量大小，两者的效率不会差太多，但是高度写起来很麻烦，因此我们常用集合数量来衡量</p></blockquote><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405081111558.png" alt="image-20230126164358686" style="zoom: 67%;" /><table><thead><tr><th>Implementation</th><th>Constructor</th><th><code>connect</code></th><th><code>isConnected</code></th></tr></thead><tbody><tr><td>Weighted Quick Union</td><td>Θ(N)</td><td>O(log N)</td><td>O(log N)</td></tr></tbody></table><h2 id="WQU-with-path-compression-路径压缩"><a href="#WQU-with-path-compression-路径压缩" class="headerlink" title="WQU with path compression(路径压缩)"></a>WQU with path compression(路径压缩)</h2><p>The clever insight is realizing that whenever we call <code>find(x)</code> we have to traverse the path from <code>x</code> to root. So, along the way we can connect all the items we visit to their root at no extra asymptotic cost.</p><p>Connecting all the items along the way to the root will help make our tree shorter with each call to <code>find</code>.</p><table><thead><tr><th>Implementation</th><th><code>isConnected</code></th><th><code>connect</code></th></tr></thead><tbody><tr><td>Quick Find</td><td>Θ(N)</td><td>Θ(1)</td></tr><tr><td>Quick Union</td><td>O(N)</td><td>O(N)</td></tr><tr><td>Weighted Quick Union (WQU)</td><td>O(log N)</td><td>O(log N)</td></tr><tr><td>WQU with Path Compression</td><td>O(α(N))*</td><td>O(α(N))*</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>Union find</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
