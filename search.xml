<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>dp</title>
    <url>/2023/03/17/dp/</url>
    <content><![CDATA[<h1 id="DP-动态规划-背包"><a href="#DP-动态规划-背包" class="headerlink" title="DP(动态规划)-背包"></a>DP(动态规划)-背包</h1><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><ul>
<li><p>题目</p>
<p>有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。第 i 件物品的体积是 v~i~，价值是 w~i~。</p>
<p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。</p>
</li>
<li><p>为什么称作01背包，因为对于每个物品，只对应选或者不选两种状态，因此称为01背包</p>
</li>
</ul>
<p><strong>主要思想：</strong></p>
<ul>
<li>状态表示: 我们用<code>f[i][j]</code>来表示，前<code>i</code>个物品，最大容量是<code>j</code>，可以得到的最大价值</li>
<li>状态计算:<ul>
<li>对于<code>f[i][j]</code>，第 i 个物品，我们有两种选择<ul>
<li>不选他: <code>f[i][j]=f[i-1][j]</code>，将第 i 个物品剔除然后选最大</li>
<li>选他: <code>f[i][j]=f[i-1][j-v[i]]+w[i]</code>，先将第 i 个物品放入背包，然后在前 i-1 个物品，容量为 j -v[i]的状态下找最大</li>
</ul>
</li>
<li>因此得出状态方程: <code>f[i][j] = max(f[i-1][j],f[i-1][j-v[i]]+w[i])</code></li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202303171930067.png" alt="image-20230317193055011"></p>
<h3 id="二维朴素版"><a href="#二维朴素版" class="headerlink" title="二维朴素版"></a>二维朴素版</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="comment">//对于f[i][j]，当i或者j为0时，f[i][j] = 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n; i++ )&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j &lt;= m ;j++)&#123;</span><br><span class="line">            <span class="comment">// 当前背包容量装不进第i个物品，则价值等于前i-1个物品</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; v[i]) f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="comment">// 可以装第i个物品，决策是否选他，用max来比较</span></span><br><span class="line">            <span class="keyword">else</span> f[i][j] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][j],f[i<span class="number">-1</span>][j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[n][m]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一维终极版"><a href="#一维终极版" class="headerlink" title="一维终极版"></a>一维终极版</h3><p>前提是理解了上述二维版本的递推关系与<strong>图示</strong>！</p>
<p>观察<code>f[i][j] = max(f[i-1][j],f[i-1][j-v[i]]+w[i])</code>，可以发现我们只用到了第 i-1 层的关系，因此我们可以考虑将 i 这一维度去掉变为一维数组。</p>
<p>具体如何做到变为一维？我们先简单地去掉 i 的这一维，然后验证是否依旧<strong>满足我们推导的状态转移方程</strong></p>
<ul>
<li>对于<code>if(j &lt; v[i]) f[i][j] = f[i-1][j];</code>代码段，我们直接将 j 从 v[i] 开始枚举，由于去掉 i 之后 <code>f[j] = f[j]</code>，恒等无意义，我们直接去掉该语句</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = v[i] ; j &lt;= m ;j++)</span><br><span class="line">    f[j] = <span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br></pre></td></tr></table></figure>
<ul>
<li>对于这个代码是否满足状态转移方程呢？答案是否定的</li>
</ul>
<p>推导：再看此图</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202303171929319.png" alt="image-20230317192903273"></p>
<p>一维简化的实质是: </p>
<ul>
<li>我们直接将计算第 i 层所需的 i-1 层的两个数拷贝下来，然后计算<code>f[j] = max(f[j],f[j-v[i]]+w[i])</code>，此时第 i-1 层的 <code>f[j]</code>更新为了第 i 层的<code>f[j]</code>，那么我们往后递推到计算<code>f[j+v[i]]</code>的时候，就会出现问题，我们需要的是第 <strong>i-1</strong> 层的 <code>f[j]</code>和<code>f[j+v[i]]</code>，但是由于前面的更新，第 i-1 层的 <code>f[j]</code>更新为了第 i 层的<code>f[j]</code>，不正确</li>
<li>此时我们得到的递推式其实是<code>f[i][j]=f[i-1][j]+f[i][j-v[i]]+w[i]</code>，这个递推式恰好是<strong>完全背包</strong>需要的</li>
<li>造成此原因是：<strong>二维数组使用的是正上方和左上方</strong>，转化为一维的之后就是利用从上方拷贝到该层的两个数(也就是该位置和左边相邻的位置)，如果我们从前往后 j++，就会造成我需要的<strong>上一层的<code>f[j]</code>被更新后的这一层的<code>f[j]</code>覆盖</strong>，因此显然的一个解法是我们从后往前遍历，这样就不会覆盖左边需要的数了</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span> ; i&lt;=n ; i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n; i++ )&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m ; j &gt;= v[i] ; j--)&#123;</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p>完全背包的一个改变是我们可以对于每一件物品，不再只局限于选或者不选，而是可以选任意数量，只要不超过背包容量V</p>
<p>因此我们对于每一个<code>f[i][j]</code>，我们可以选取0,1,2,…k个物品 i (k*v[i]&lt;=j)</p>
<ul>
<li>状态转移方程为 <code>f[i][j] = max(f[i][j],f[i-1][j-k*v[i]]+k*w[i])</code></li>
</ul>
<h3 id="二维朴素"><a href="#二维朴素" class="headerlink" title="二维朴素"></a>二维朴素</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N =<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span> ; i&lt;=n ; i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span> ;i &lt;=n ;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j&lt;=m ;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k*v[i]&lt;=j; k++)&#123;</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-k*v[i]]+k*w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">    cout&lt;&lt;f[n][m]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二维优化版本"><a href="#二维优化版本" class="headerlink" title="二维优化版本"></a>二维优化版本</h3><p>观察如下递推关系</p>
<p><code>f[i][j] = max(f[i-1][j] + f[i-1][j-v[i]]+w[i] + f[i-1][j-2*[i]]+2*w[i] ... f[i-1][j-k*v[i]]+k*w[i] )</code></p>
<p><code>f[i][j-v[i]]= max(        f[i-1][j-v[i]] + f[i-1][j-2*v[i]]+w[i] +  ...      f[i-1][j-k*v[i]]+(k-1)*w[i]</code></p>
<ul>
<li>推出 <code>f[i][j]=max( f[i-1][j] , f[i][j-v[i]]+w[i] )</code></li>
<li>与01背包的区别  <code>f[i][j] = max(f[i-1][j],f[i-1][j-v[i]]+w[i])</code>，第二个 i-1 变成了 i</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N =<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span> ; i&lt;=n ; i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span> ;i &lt;=n ;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j&lt;=m ;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;v[i]) f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> f[i][j] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][j],f[i][j-v[i]]+w[i]);   </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">    cout&lt;&lt;f[n][m]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一维版本"><a href="#一维版本" class="headerlink" title="一维版本"></a>一维版本</h3><p>老套路，先直接去掉 i 的一维，然后看是否符合状态转移方程</p>
<p>由上文01背包的一维错误解法中，我们知道这是正确的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span> ;i &lt;=n ;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j&lt;=m ;j++)</span><br><span class="line">        f[j] = <span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);   </span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N =<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span> ; i&lt;=n ; i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span> ; i&lt;=n ; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = v[i] ; j&lt;=m ;j++)</span><br><span class="line">            f[j] = <span class="built_in">max</span>( f[j] , f[j-v[i]]+w[i] );   </span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p>与01，完全背包的区别是，每件物品的数量有限制，既不是只有01，也不是任意，而是最多<code>s[i]</code>件</p>
<p>二进制优化</p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组</title>
    <url>/2023/03/23/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul>
<li><p>单点修改，区间求和  O(logN)</p>
</li>
<li><p>可以在，O(logN)的时间内，动态求前缀和 ( 对比前缀和，修改的话需要O(N) )</p>
</li>
</ul>
<p>注意：树状数组下标一定要<strong>从1开始</strong></p>
<h4 id="树状数组初始化"><a href="#树状数组初始化" class="headerlink" title="树状数组初始化"></a>树状数组初始化</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span> ; i&lt;=n ; i++) <span class="built_in">add</span>(i,a[i]);</span><br></pre></td></tr></table></figure>
<p>小小地解释一下原理：</p>
<ul>
<li><p>树状数组中奇数下标和原数组相等</p>
</li>
<li><p><code>c[x] = 原数组中下标从(x-lowbit(x)，x]的和</code> 左开右闭</p>
</li>
</ul>
<h4 id="三个基本操作："><a href="#三个基本操作：" class="headerlink" title="三个基本操作："></a>三个基本操作：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[N],c[N];<span class="comment">//a[N]为原数组，c[N]为树状数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一般情况下只支持add，如果要实现修改某一个数，可以add他们的差值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x , <span class="type">int</span> v )</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i)) c[i] += v;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x ; i&gt;=<span class="number">1</span> ; i-=<span class="built_in">lowbit</span>(i) )  res += c[i];<span class="comment">//for循环截止条件写成 i!=0 即 i也可以</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><p>每个结点都是一个结构体</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> L,R;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">&#125;tr[N*<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<p>线段树存储</p>
<p>注意结点个数要开 <code>4n</code> 其中n是有多少个数</p>
<p>类似于堆的存储方式，存在一维数组，对于一个序号为x的节点</p>
<ul>
<li>父节点为 x/2 (下取整) <code>x&gt;&gt;1</code></li>
<li>左子节点为 x*2  <code>x&lt;&lt;1</code></li>
<li>右子节点为 x*2+1  <code>x&lt;&lt; 1 | 1</code></li>
</ul>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><ul>
<li><p>单点修改 O(logN)</p>
</li>
<li><p>区间查询 O(logN)</p>
</li>
</ul>
<p>四个函数</p>
<p>pushup 用子节点信息更新当前节点信息</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    tr[u].sum = tr[u&lt;&lt;<span class="number">1</span>].sum + tr[u&lt;&lt;<span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>build  在一段区间上初始化线段树</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) tr[u] = &#123;l,r,w[r]&#125;;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        tr[u] = &#123;l,r&#125;;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid), <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span> | <span class="number">1</span> , mid+<span class="number">1</span> ,r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>modify  修改某个点的值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l == tr[u].r ) tr[u].sum += v;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>, x , v);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span> , x , v);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>query   查询</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l &amp;&amp; tr[u].r&lt;=r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= mid) sum += <span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span> , l ,mid);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; mid)  sum += <span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/03/17/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
