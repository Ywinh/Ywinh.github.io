<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>dp</title>
    <url>/2023/03/17/dp/</url>
    <content><![CDATA[<h1 id="DP-动态规划-背包"><a href="#DP-动态规划-背包" class="headerlink" title="DP(动态规划)-背包"></a>DP(动态规划)-背包</h1><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><ul>
<li><p>题目</p>
<p>有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。第 i 件物品的体积是 v~i~，价值是 w~i~。</p>
<p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。</p>
</li>
<li><p>为什么称作01背包，因为对于每个物品，只对应选或者不选两种状态，因此称为01背包</p>
</li>
</ul>
<p><strong>主要思想：</strong></p>
<ul>
<li>状态表示: 我们用<code>f[i][j]</code>来表示，前<code>i</code>个物品，最大容量是<code>j</code>，可以得到的最大价值</li>
<li>状态计算:<ul>
<li>对于<code>f[i][j]</code>，第 i 个物品，我们有两种选择<ul>
<li>不选他: <code>f[i][j]=f[i-1][j]</code>，将第 i 个物品剔除然后选最大</li>
<li>选他: <code>f[i][j]=f[i-1][j-v[i]]+w[i]</code>，先将第 i 个物品放入背包，然后在前 i-1 个物品，容量为 j -v[i]的状态下找最大</li>
</ul>
</li>
<li>因此得出状态方程: <code>f[i][j] = max(f[i-1][j],f[i-1][j-v[i]]+w[i])</code></li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202303171930067.png" alt="image-20230317193055011"></p>
<h3 id="二维朴素版"><a href="#二维朴素版" class="headerlink" title="二维朴素版"></a>二维朴素版</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="comment">//对于f[i][j]，当i或者j为0时，f[i][j] = 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n; i++ )&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j &lt;= m ;j++)&#123;</span><br><span class="line">            <span class="comment">// 当前背包容量装不进第i个物品，则价值等于前i-1个物品</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; v[i]) f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="comment">// 可以装第i个物品，决策是否选他，用max来比较</span></span><br><span class="line">            <span class="keyword">else</span> f[i][j] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][j],f[i<span class="number">-1</span>][j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[n][m]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一维终极版"><a href="#一维终极版" class="headerlink" title="一维终极版"></a>一维终极版</h3><p>前提是理解了上述二维版本的递推关系与<strong>图示</strong>！</p>
<p>观察<code>f[i][j] = max(f[i-1][j],f[i-1][j-v[i]]+w[i])</code>，可以发现我们只用到了第 i-1 层的关系，因此我们可以考虑将 i 这一维度去掉变为一维数组。</p>
<p>具体如何做到变为一维？我们先简单地去掉 i 的这一维，然后验证是否依旧<strong>满足我们推导的状态转移方程</strong></p>
<ul>
<li>对于<code>if(j &lt; v[i]) f[i][j] = f[i-1][j];</code>代码段，我们直接将 j 从 v[i] 开始枚举，由于去掉 i 之后 <code>f[j] = f[j]</code>，恒等无意义，我们直接去掉该语句</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = v[i] ; j &lt;= m ;j++)</span><br><span class="line">    f[j] = <span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br></pre></td></tr></table></figure>
<ul>
<li>对于这个代码是否满足状态转移方程呢？答案是否定的</li>
</ul>
<p>推导：再看此图</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202303171929319.png" alt="image-20230317192903273"></p>
<p>一维简化的实质是: </p>
<ul>
<li>我们直接将计算第 i 层所需的 i-1 层的两个数拷贝下来，然后计算<code>f[j] = max(f[j],f[j-v[i]]+w[i])</code>，此时第 i-1 层的 <code>f[j]</code>更新为了第 i 层的<code>f[j]</code>，那么我们往后递推到计算<code>f[j+v[i]]</code>的时候，就会出现问题，我们需要的是第 <strong>i-1</strong> 层的 <code>f[j]</code>和<code>f[j+v[i]]</code>，但是由于前面的更新，第 i-1 层的 <code>f[j]</code>更新为了第 i 层的<code>f[j]</code>，不正确</li>
<li>此时我们得到的递推式其实是<code>f[i][j]=f[i-1][j]+f[i][j-v[i]]+w[i]</code>，这个递推式恰好是<strong>完全背包</strong>需要的</li>
<li>造成此原因是：<strong>二维数组使用的是正上方和左上方</strong>，转化为一维的之后就是利用从上方拷贝到该层的两个数(也就是该位置和左边相邻的位置)，如果我们从前往后 j++，就会造成我需要的<strong>上一层的<code>f[j]</code>被更新后的这一层的<code>f[j]</code>覆盖</strong>，因此显然的一个解法是我们从后往前遍历，这样就不会覆盖左边需要的数了</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span> ; i&lt;=n ; i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n; i++ )&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m ; j &gt;= v[i] ; j--)&#123;</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p>完全背包的一个改变是我们可以对于每一件物品，不再只局限于选或者不选，而是可以选任意数量，只要不超过背包容量V</p>
<p>因此我们对于每一个<code>f[i][j]</code>，我们可以选取0,1,2,…k个物品 i (k*v[i]&lt;=j)</p>
<ul>
<li>状态转移方程为 <code>f[i][j] = max(f[i][j],f[i-1][j-k*v[i]]+k*w[i])</code></li>
</ul>
<h3 id="二维朴素"><a href="#二维朴素" class="headerlink" title="二维朴素"></a>二维朴素</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N =<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span> ; i&lt;=n ; i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span> ;i &lt;=n ;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j&lt;=m ;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k*v[i]&lt;=j; k++)&#123;</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-k*v[i]]+k*w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">    cout&lt;&lt;f[n][m]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二维优化版本"><a href="#二维优化版本" class="headerlink" title="二维优化版本"></a>二维优化版本</h3><p>观察如下递推关系</p>
<p><code>f[i][j] = max(f[i-1][j] + f[i-1][j-v[i]]+w[i] + f[i-1][j-2*[i]]+2*w[i] ... f[i-1][j-k*v[i]]+k*w[i] )</code></p>
<p><code>f[i][j-v[i]]= max(        f[i-1][j-v[i]] + f[i-1][j-2*v[i]]+w[i] +  ...      f[i-1][j-k*v[i]]+(k-1)*w[i]</code></p>
<ul>
<li>推出 <code>f[i][j]=max( f[i-1][j] , f[i][j-v[i]]+w[i] )</code></li>
<li>与01背包的区别  <code>f[i][j] = max(f[i-1][j],f[i-1][j-v[i]]+w[i])</code>，第二个 i-1 变成了 i</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N =<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span> ; i&lt;=n ; i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span> ;i &lt;=n ;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j&lt;=m ;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;v[i]) f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> f[i][j] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][j],f[i][j-v[i]]+w[i]);   </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">    cout&lt;&lt;f[n][m]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一维版本"><a href="#一维版本" class="headerlink" title="一维版本"></a>一维版本</h3><p>老套路，先直接去掉 i 的一维，然后看是否符合状态转移方程</p>
<p>由上文01背包的一维错误解法中，我们知道这是正确的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span> ;i &lt;=n ;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j&lt;=m ;j++)</span><br><span class="line">        f[j] = <span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);   </span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N =<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span> ; i&lt;=n ; i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span> ; i&lt;=n ; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = v[i] ; j&lt;=m ;j++)</span><br><span class="line">            f[j] = <span class="built_in">max</span>( f[j] , f[j-v[i]]+w[i] );   </span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p>与01，完全背包的区别是，每件物品的数量有限制，既不是只有01，也不是任意，而是最多<code>s[i]</code>件</p>
<p>二进制优化</p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/03/17/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
