

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Jianhui Yin">
  <meta name="keywords" content="">
  
    <meta name="description" content="算法模板：数学、二分、双指针、单调栈、单调队列、字典树、Z函数、dp、差分、堆、线段树">
<meta property="og:type" content="article">
<meta property="og:title" content="算法笔记-杂乱版持续更新">
<meta property="og:url" content="http://example.com/2024/05/31/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E6%9D%82%E4%B9%B1%E7%89%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/index.html">
<meta property="og:site_name" content="yinsist">
<meta property="og:description" content="算法模板：数学、二分、双指针、单调栈、单调队列、字典树、Z函数、dp、差分、堆、线段树">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202404051525946.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405312321398.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405091804608.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405212349828.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405212359639.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405302351001.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405302354265.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405292026288.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405292226555.png">
<meta property="article:published_time" content="2024-05-31T15:21:00.000Z">
<meta property="article:modified_time" content="2024-05-31T15:22:21.776Z">
<meta property="article:author" content="Jianhui Yin">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202404051525946.png">
  
  
  
  <title>算法笔记-杂乱版持续更新 - yinsist</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Yinsist</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="算法笔记-杂乱版持续更新"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-05-31 23:21" pubdate>
          May 31, 2024 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          9.2k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          78 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">算法笔记-杂乱版持续更新</h1>
            
            
              <div class="markdown-body">
                
                <p>算法模板：数学、二分、双指针、单调栈、单调队列、字典树、Z函数、dp、差分、堆、线段树</p>
<span id="more"></span>

<h1 id="蓝桥杯省赛考点"><a href="#蓝桥杯省赛考点" class="headerlink" title="蓝桥杯省赛考点"></a>蓝桥杯省赛考点</h1><p>统计结果如下：</p>
<p>知识点    出现次数<br>模拟    17<br>贪心    16<br>DP    14<br>枚举    11<br>数学    9<br>二分    8<br>数论    7<br>DFS    5<br>前缀和    5<br>推公式    5<br>快速幂    4<br>差分    4<br>双指针    4<br>状态压缩DP    4<br>思维题    4<br>BFS    3<br>树形DP    3<br>递推    3<br>字符串处理    3<br>排序    2<br>搜索    2<br>剪枝    2<br>递归    2<br>动态规划    2<br>分类讨论    2<br>线性DP    2<br>最大公约数    2<br>二叉树    2<br>背包问题    2<br>找规律    2<br>并查集    2<br>哈希表    2<br>分解质因数    2<br>堆    2<br>结论题    1<br>树的直径    1<br>斐波那契数列性质    1<br>龟速乘    1<br>树状数组    1<br>归并排序    1<br>矩阵乘法    1<br>哈希    1<br>区间DP    1<br>辗转相减法    1<br>图论    1<br>环    1<br>置换群    1<br>完全背包问题    1<br>扫描线    1<br>线段树    1<br>Flood Fill    1<br>均值不等式    1<br>滑动窗口    1<br>平衡树    1<br>STL Set    1<br>IDA*    1<br>日期问题    1<br>贡献法    1<br>Bellman-Ford    1<br>SPFA    1<br>Dijkstra    1<br>组合计数    1<br>栈    1<br>括号序列    1<br>博弈论    1<br>构造    1<br>图的遍历    1<br>概率论    1<br>数学期望    1<br>逆元    1<br>快速选择    1<br>链表    1<br>排序不等式    1<br>多路归并    1<br>整数分块    1<br>整除    1<br>单调队列    1<br>欧拉函数    1<br>状态机    1<br>区间合并    1</p>
<h1 id="蓝桥杯官方刷题"><a href="#蓝桥杯官方刷题" class="headerlink" title="蓝桥杯官方刷题"></a>蓝桥杯官方刷题</h1><p><a target="_blank" rel="noopener" href="https://www.lanqiao.cn/problems/17118/learning/">0走方格 - 蓝桥云课 (lanqiao.cn)</a></p>
<h1 id="python刷算法技巧-知识"><a href="#python刷算法技巧-知识" class="headerlink" title="python刷算法技巧/知识"></a>python刷算法技巧/知识</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_74850661/article/details/136595749">python 蓝桥杯之常用的库_蓝桥杯python库-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xia_yanbing/article/details/114641646">【蓝桥杯】Python自带编辑器IDLE的使用教程_python蓝桥杯编译器-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_67601373/article/details/124046655">蓝桥杯 python组IDLE的使用方法_蓝桥杯能打开idle自带的文档吗-CSDN博客</a></p>
<p>F1打开帮助文档！！！</p>
<ol>
<li><p>map事实上是返回一个迭代器</p>
</li>
<li><p>注意如果在函数里面需要使用一个全局变量</p>
<ul>
<li><p> <code>global  ans</code></p>
</li>
<li><p> <code>nonlocal ans</code></p>
</li>
<li><p> 先像上面这两种方法声明一下</p>
</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>区分 <code>t[::-1]</code>和 <code>t[:-1]</code></p>
<ul>
<li>前者：用于反转序列，返回序列的反向版本</li>
<li>后者： 用于获取序列的子序列，该子序列包含从序列的第一个元素到倒数第二个元素（不包括最后一个元素），没有反转</li>
</ul>
</li>
<li><p>格式化输出</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 格式化输出十进制</span><br>decimal_format = <span class="hljs-string">&quot;The number in decimal is: %d&quot;</span> % number<br><span class="hljs-built_in">print</span>(decimal_format)  <span class="hljs-comment"># 输出: The number in decimal is: 255</span><br></code></pre></td></tr></table></figure></li>
<li><p>python正无穷：inf，需要先从math引入</p>
<figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-keyword">from</span> <span class="hljs-built_in">math</span> <span class="hljs-keyword">import</span> inf<br></code></pre></td></tr></table></figure></li>
<li><p><code>isqrt(mid//i) 比 int(sqrt(mid//i))</code> 快很多吗，大概五倍，也要从math库引入</p>
<figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-keyword">from</span> <span class="hljs-built_in">math</span> <span class="hljs-keyword">import</span> inf<br></code></pre></td></tr></table></figure></li>
<li><p><code>join</code>的使用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27; &#x27;</span>.join(i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>,path)))<br></code></pre></td></tr></table></figure></li>
<li><p>python里面自己来调用 min，max很慢，如果觉得很慢可以自己拆开了用if，else来写。那么怎么定义”很慢“呢？</p>
</li>
<li><p><strong>输入</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#读取n个数 </span><br>a = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br></code></pre></td></tr></table></figure></li>
<li><p>输入数据太多比如10^5以上建议用 sys.stdin</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys <br><span class="hljs-built_in">input</span> = <span class="hljs-keyword">lambda</span> : sys.stdin.readline().strip()<br></code></pre></td></tr></table></figure></li>
<li><p><code>s.sort()</code> 和 <code>sorted(s)</code> 的区别：（一般习惯用<code>s.sort()</code>）</p>
<p>注意s.sort() 直接在s里面修改，不会返回一个新的</p>
<p>但是 sorted(s) 不会在s里面修改，而是返回一个新的</p>
</li>
<li><p>创建多维数组：</p>
<p>比如 n*m 的数组，注意先 m 后 n</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [[ <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br></code></pre></td></tr></table></figure>

<p>创建一个a * b *c 的数组，初始化为全0</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">f = [[[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(c)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(b)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>()]<br></code></pre></td></tr></table></figure></li>
<li><p>min(列表1的一部分，列表1的另一部分)是不可以的</p>
<p>在Python中，<code>min</code> 函数不能直接接受两个列表作为参数，然后比较这两部分来决定最小值。<code>min</code> 函数期望的是一个可迭代对象，从中它会找到最小值。如果你尝试将两个列表作为参数传递给 <code>min</code>，你将得到一个类型错误，因为 <code>min</code> 函数不知道如何比较两个列表。</p>
</li>
<li><p>手动实现上取整：</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">(x+mid-<span class="hljs-number">1</span>)//mid <span class="hljs-comment">#这一步，实现上取整，怎么实现的？ </span><br>                <span class="hljs-comment"># 上取整，其实可以测试一下 (x-1) // mid</span><br>                <span class="hljs-comment"># 如果 x是mid的倍数，那么这个结果就应该加1（恢复原样）</span><br>                <span class="hljs-comment"># 如果 x不是mid的倍数，那么这个结果也应该加一（上取整）</span><br></code></pre></td></tr></table></figure>

<ol start="15">
<li><p>python自带的bisect使用：</p>
<p>bisect_left：（最左）如果要查找 最左边的，使用bisect_left 找如果要插入，应该插入的最左端位置，如果列表中已经存在该元素，它将返回该元素在列表中的最左侧位置</p>
<p>bisect_right：（最右）返回的是插入点的右侧位置，即如果列表中已经存在该元素，它将返回该元素在列表中的最右侧位置</p>
<p>bisect：<code>bisect</code>是<code>bisect_right</code>的别名，所以它的使用方式与<code>bisect_right</code>完全相同</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bisect <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 有序列表</span><br>a = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>]<br><br><span class="hljs-comment"># 要插入的元素</span><br>x = <span class="hljs-number">5</span><br><br><span class="hljs-comment"># 使用bisect_left找到插入点</span><br>index = bisect.bisect_left(a, x)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;插入点的索引:&quot;</span>, index)<br><span class="hljs-comment"># 输出: 插入点的索引: 2</span><br><br>index = bisect.bisect_right(a, x)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;插入点的索引:&quot;</span>, index)  <span class="hljs-comment"># 输出: 插入点的索引: 3</span><br></code></pre></td></tr></table></figure></li>
<li><p>其实列表就是栈，Python中列表的实现是基于链表来的，python中的列表里的pop（）可以实现出栈，append（）实现入栈，而这两个操作的时间复杂度都是o（1），所以列表本身就是一个栈，实现队列的话用pop（0）实现出队，append（）实现入队，只不过这里的pop（0）的时间复杂度是<strong>o（n）</strong></p>
<p>所以队列最好还是用deque的popleft和append，这两个时间复杂度是o（1）</p>
<p>使用队列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> collections<br>q = collections.deque()<br><br><span class="hljs-comment">#左端出队</span><br>q.pop_left()<br><span class="hljs-comment">#右端入队</span><br>q.append()<br><br><span class="hljs-comment">#判断队列是否为空</span><br><span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li>
<li><p>熟悉一下文件操作，可能需要你打开文件？</p>
<p>逆元，博弈</p>
</li>
<li><p>排序：按照某个key排序</p>
<ul>
<li><p>按照元组的第二个元素排序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = [(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">4</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">5</span>, <span class="hljs-number">0</span>)]<br>arr.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure></li>
<li><p>按照字典的某个键排序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用 sort 方法按字典的 &#x27;age&#x27; 键排序</span><br>arr.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-string">&#x27;age&#x27;</span>])<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>千万不要像这样初始化数组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">nums = [[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]]*n<br></code></pre></td></tr></table></figure>

<p>使用列表推导式而不是乘法的原因是，乘法会创建对同一个列表对象的多个引用，这可能会导致意外的副作用。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">python复制代码<span class="hljs-comment"># 错误的方法：使用乘法</span><br>n = <span class="hljs-number">5</span><br>my_list = [[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]] * n<br><br><span class="hljs-comment"># 修改一个元素会影响所有元素，因为它们引用的是同一个对象</span><br>my_list[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(my_list)  <span class="hljs-comment"># 输出 [[1, 0], [1, 0], [1, 0], [1, 0], [1, 0]]</span><br></code></pre></td></tr></table></figure>

<p>在上面的例子中，<code>[[0, 0]] * n</code> 会创建一个包含对同一个 <code>[0, 0]</code> 列表的 <code>n</code> 个引用的列表。因此，修改其中一个元素会导致所有元素都发生变化。</p>
<p>因此，推荐使用列表推导式来避免这种问题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">python复制代码n = <span class="hljs-number">5</span><br>my_list = [[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br><br><span class="hljs-comment"># 修改一个元素不会影响其他元素</span><br>my_list[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(my_list)  <span class="hljs-comment"># 输出 [[1, 0], [0, 0], [0, 0], [0, 0], [0, 0]]</span><br></code></pre></td></tr></table></figure>

<p>这样可以确保每个元素都是独立的 <code>[0, 0]</code> 列表，不会相互影响。</p>
</li>
<li><p>python对部分数组排序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">tmp[i:j+<span class="hljs-number">1</span>] = <span class="hljs-built_in">sorted</span>(tmp[i:j+<span class="hljs-number">1</span>])<br><span class="hljs-comment"># tmp[i:j+1].sort()是错误的，不会作用于原数组</span><br><span class="hljs-comment"># 创建的是原数组的一个切片（即一个新的列表），并对这个新的列表进行排序，而不会影响原数组</span><br></code></pre></td></tr></table></figure></li>
<li><p>ascii转字符串：<code>chr()</code></p>
<p>字符串转ascii：<code>ord()</code></p>
</li>
<li><p>四舍五入: round(n)</p>
</li>
</ol>
<h1 id="由数据范围反推算法复杂度以及算法内容"><a href="#由数据范围反推算法复杂度以及算法内容" class="headerlink" title="由数据范围反推算法复杂度以及算法内容"></a>由数据范围反推算法复杂度以及算法内容</h1><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202404051525946.png" srcset="/img/loading.gif" lazyload alt="image-20240405152508844"></p>
<h1 id="1-数学"><a href="#1-数学" class="headerlink" title="1.数学"></a>1.数学</h1><h2 id="1-2试除法判定质数"><a href="#1-2试除法判定质数" class="headerlink" title="1.2试除法判定质数"></a>1.2试除法判定质数</h2><p>质数： &gt; 1且约数只包含1 和本身</p>
<p>性质： d | n， (n/d) | n</p>
<p>因此n的所有约数其实都是成对出现的，因此我们可以每次只枚举每一对里面较小的那一个，也就是满足 d &lt;= n/d，整理一下就得到 d &lt;= 根号n，因此我们只需要枚举到根号n就可以，从而降低了时间复杂度</p>
<p>n中最多只包含一个大于sqrt(n)的质因子，如果有两个，相乘不就 &gt; n了吗</p>
<h2 id="快速求因数"><a href="#快速求因数" class="headerlink" title="快速求因数"></a>快速求因数</h2><p>只用从 $1$ 到 $\sqrt{n}$ 枚举因数，另一个因数就等于 $n \div 当前因数$  ，必被整除的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums1:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,isqrt(x)+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> x%i == <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">dict</span>[i] += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> i*i &lt; x: <span class="hljs-comment"># 等于x的话就重复计算了</span><br>                <span class="hljs-built_in">dict</span>[x//i]+=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>







<p><strong>快速排序</strong></p>
<ol>
<li>确定分界点，q[(l+r)//2] or q[random]</li>
<li>调整区间： 让所有 &lt;=x 的在x左边，&gt;= x的在x右边</li>
<li>递归处理左右区间</li>
</ol>
<p>最难实现的就是第二步了：</p>
<ul>
<li><p>容易想到但是不优美的做法：</p>
<p>可以开两个额外的数组，把 &lt;= x的放在一个，&gt;=x 的放在另一个，最后把他们俩拼起来</p>
</li>
<li><p>优雅做法：</p>
<ul>
<li>用两个指针，其中 i 指向第一个，j 指向最后一个</li>
<li>遇到 &lt;=x 的数，i++，直到遇到第一个 &gt;x 的数，停下</li>
<li>遇到 &gt;=x 的数，j–，直到遇到第一个 &lt;x 的数，停下</li>
<li>交换 i 和 j 对应的数</li>
<li>循环直到 i &gt; j</li>
</ul>
</li>
</ul>
<h2 id="1-3离散化"><a href="#1-3离散化" class="headerlink" title="1.3离散化"></a>1.3离散化</h2><p>数的值域很大，但是范围不大（稀疏），需要用到数的值做下标，但是又不可能开那么大的全局数组，于是需要离散化：把数值映射</p>
<p>需要解决的问题：</p>
<ul>
<li>去重（先排序后unique去重）</li>
<li>如何算出 x 离散化之后的值（二分）</li>
</ul>
<p>一般来说 10的五次方以内差不多</p>
<p>把下标在 i 的值，映射到一个数</p>
<h2 id="1-4模运算"><a href="#1-4模运算" class="headerlink" title="1.4模运算"></a>1.4模运算</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/mDfnkW/">分享丨模运算的世界：当加减乘除遇上取模 - 力扣（LeetCode）</a></p>
<p>加法和乘法的取模：<br>$$<br>(a+b)\ mod\ m=((a\ mod\ m)+(b\ mod\ m))\ mod\ m<br>$$</p>
<p>$$<br>(a <em>b)\ mod\ m=((a\ mod\ m)</em>(b\ mod\ m))\ mod\ m<br>$$</p>
<p>负数的取模： $x&lt;0$ ，$y&gt;=0$，则 $x \equiv y\ mod\ m$ 等价于<br>$$<br>x\ mod\ m+m=y\ mod\ m<br>$$</p>
<p>除法的取模：如果 𝑝 是一个质数，𝑎是 𝑏的倍数且 𝑏和 𝑝互质（𝑏不是 𝑝的倍数），那么有<br>$$<br>\frac{a}{b}\ mod\ p =(a*b^{p-2})\ mod\ p<br>$$</p>
<p>总结<br>代码实现时，上面的加减乘除通常是这样写的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">MOD = <span class="hljs-number">1_000_000_007</span><br><br>// 加<br>(a + b) % MOD<br><br>// 减<br>(a - b + MOD) % MOD<br><br>// 乘<br>a * b % MOD<br><br>// 多个数相乘，要步步取模，防止溢出<br>a * b % MOD * c % MOD<br><br>// 除（MOD 是质数且 b 不是 MOD 的倍数）<br>a * qpow(b, MOD - <span class="hljs-number">2</span>, MOD) % MOD<br></code></pre></td></tr></table></figure>



<h2 id="1-5-gcd-与-lcm"><a href="#1-5-gcd-与-lcm" class="headerlink" title="1.5 gcd 与 lcm"></a>1.5 gcd 与 lcm</h2><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405312321398.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">gcd</span>(<span class="hljs-params">a,b</span>):<br>  <span class="hljs-keyword">if</span> a&lt;b:<br>    a,b=b,a<br>  <span class="hljs-keyword">while</span> b!=<span class="hljs-number">0</span>:<br>    a,b=b,a%b<br>  <span class="hljs-keyword">return</span> a<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lcm</span>(<span class="hljs-params">a,b</span>):<br>	<span class="hljs-keyword">return</span> (a*b)/gcd(a,b);<br><br></code></pre></td></tr></table></figure>

<p>gcd(a,b) = gcd(b,a)</p>
<h1 id="2-双指针-变长滑动窗口"><a href="#2-双指针-变长滑动窗口" class="headerlink" title="2.双指针 变长滑动窗口"></a>2.双指针 变长滑动窗口</h1><p>两数之和，三数之和：</p>
<ul>
<li>什么时候可以使用双指针？<ul>
<li>双指针要求一定要排序，排序之后元素对应的下标就变了</li>
<li>因此如果题目要求返回元素数值我们就可以使用双指针</li>
</ul>
</li>
<li>使用hash表<ul>
<li>题目要求返回下标时</li>
</ul>
</li>
</ul>
<p>双指针要满足单调性</p>
<p>在什么时候移动指针</p>
<p>什么时候记录答案要搞清楚</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组 - 力扣（LeetCode）</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subarray-product-less-than-k/description/">713. 乘积小于 K 的子数组 - 力扣（LeetCode）</a></p>
<p>[3. 无重复字符的最长子串 - 力扣（LeetCode）](</p>
<h1 id="3-二分"><a href="#3-二分" class="headerlink" title="3.二分"></a>3.二分</h1><h2 id="红蓝染色法理解二分"><a href="#红蓝染色法理解二分" class="headerlink" title="红蓝染色法理解二分"></a>红蓝染色法理解二分</h2><p>我们以寻找到 &gt;= x 的第一个下标来举例：</p>
<p>你的条件可以灵活定义</p>
<p>用<strong>红色</strong>表示不满足条件的，<strong>蓝色</strong>表示满足条件的，<strong>白色</strong>表示不确定</p>
<p><strong>核心</strong>：</p>
<ul>
<li>你要维护的区间内的都是没有染色的，<strong>区间的定义是未染色的范围，而不是答案的范围！！！</strong></li>
<li><strong>l 和 r 的初始值怎么定义？</strong>看你初始的不知道如何染色的区间范围（白色）是多少，以及你二分是使用闭区间 or 开区间 or 左闭右开 哪种策略编写的，据此定下来你的 l 和 r值</li>
<li><strong>循环条件如何终止？</strong>当你的区间不为空的时候循环</li>
<li>中间判断了之后 l，r 与 m 的关系应该怎么变化：看你想要寻找什么</li>
<li>最后答案应该怎么return：在找第一个 &gt;= x 的情况下你要return的应该是蓝色（true）的第一个</li>
</ul>
<p><strong>mid</strong> 表示正在询问的数 </p>
<p>闭区间写法下我们如何取得答案？</p>
<p>有一个循环不变量保持着：</p>
<ul>
<li>L-1始终是红色</li>
<li>R+1始终是蓝色</li>
<li>那么答案其实就是 蓝色的第一个，也就是L或者R+1</li>
</ul>
<h2 id="多种写法"><a href="#多种写法" class="headerlink" title="多种写法"></a>多种写法</h2><p><strong>一般求什么就二分什么</strong></p>
<p>三种写法：推荐开区间，中间l,r,m之间的判断关系简单</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 找 &gt;= target 的第一个</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lower_bound</span>(<span class="hljs-params">nums,target</span>):<br>    l = -<span class="hljs-number">1</span><br>    r = <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-comment">#开区间写法</span><br>    <span class="hljs-comment"># mid 满足要求时，更新的是谁就返回谁</span><br>    <span class="hljs-keyword">while</span> l+<span class="hljs-number">1</span> &lt; r: <span class="hljs-comment">#区间不为空</span><br>        m = (l+r) // <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[m] &lt; target: <span class="hljs-comment">#false</span><br>            l =  m   <span class="hljs-comment">#(m,r)</span><br>        <span class="hljs-keyword">else</span>:<br>            r = m <span class="hljs-comment">#(l,m)</span><br>    <span class="hljs-keyword">return</span> r<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lower_bound2</span>(<span class="hljs-params">nums,target</span>):<br>    <span class="hljs-comment">#闭区间写法</span><br>    l = <span class="hljs-number">0</span><br>    r = <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> l&lt;=r: <span class="hljs-comment">#区间不为空</span><br>        m = (l+r) // <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[m] &lt; target: <span class="hljs-comment">#false</span><br>            l =  m+<span class="hljs-number">1</span>   <br>        <span class="hljs-keyword">else</span>:<br>            r = m-<span class="hljs-number">1</span> <br>    <span class="hljs-keyword">return</span> l<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lower_bound3</span>(<span class="hljs-params">nums,target</span>):<br>    l = <span class="hljs-number">0</span><br>    r = <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-comment">#左闭右开区间写法 </span><br>    <span class="hljs-keyword">while</span> l &lt; r: <span class="hljs-comment">#区间不为空</span><br>        m = (l+r) // <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[m] &lt; target: <span class="hljs-comment">#false</span><br>            l =  m+<span class="hljs-number">1</span>   <br>        <span class="hljs-keyword">else</span>:<br>            r = m <br>    <span class="hljs-keyword">return</span> r<br></code></pre></td></tr></table></figure>



<p>那么一共演变了四种题型：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm">&gt;<span class="hljs-operator">=</span> <span class="hljs-keyword">x</span> 	这种是我们熟知的<br>&gt; <span class="hljs-keyword">x</span> 	这种可以转化为 &gt;<span class="hljs-operator">=</span> <span class="hljs-keyword">x</span><span class="hljs-number">+1</span><br>&lt; <span class="hljs-keyword">x</span> 	这种可以转为 &gt;<span class="hljs-operator">=</span><span class="hljs-keyword">x</span> 的下标 <span class="hljs-number">-1</span><br>&lt;<span class="hljs-operator">=</span> <span class="hljs-keyword">x</span>	这种可以转为 &gt;<span class="hljs-keyword">x</span> 的下标 <span class="hljs-number">-1</span> 即 &gt;<span class="hljs-operator">=</span> <span class="hljs-keyword">x</span><span class="hljs-number">+1</span><br></code></pre></td></tr></table></figure>



<p>如果说target比所有的数都大的话：会返回数组最大下标的next</p>
<p>target比所有的数都小的话：会返回 0</p>
<p>target在最大最小范围内，但是没有target，会返回 &gt;= target 的第一个</p>
<p>python 写二分最好还是直接调用库，这样比较快，大概快一半</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bisect <span class="hljs-keyword">import</span> *<br>bisect_left(nums,target) <span class="hljs-comment">#返回 &gt;= target的第一个，行为与我自己写的完全一致</span><br></code></pre></td></tr></table></figure>



<h2 id="162"><a href="#162" class="headerlink" title="162"></a>162</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-peak-element/">https://leetcode.cn/problems/find-peak-element/</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#红色代表峰顶左边</span><br><span class="hljs-comment">#蓝色代表峰顶以及峰顶右边</span><br><span class="hljs-comment">#区间表示不知道染什么色的东西</span><br><span class="hljs-comment">#只需要比较mid和mid+1就行，找到第一个下坡？</span><br><span class="hljs-comment">#如果你往下坡方向走，也许可能遇到新的山峰，但是也许是一个一直下降的坡，最后到边界。</span><br><span class="hljs-comment">#但是如果你往上坡方向走，就算最后一直上的边界，由于最边界是负无穷，所以就一定能找到山峰</span><br><span class="hljs-comment">#总的一句话，往递增的方向上，二分，一定能找到，往递减的方向只是可能找到，也许没有</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lower_bound</span>(<span class="hljs-params">nums</span>):<br>    l = -<span class="hljs-number">1</span> <span class="hljs-comment">#[0,n-2]</span><br>    r = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> l+<span class="hljs-number">1</span>&lt;r:<br>        mid = (l+r) // <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[mid] &lt; nums[mid+<span class="hljs-number">1</span>]:<br>            l = mid <span class="hljs-comment">#染红色</span><br>        <span class="hljs-keyword">else</span>:<br>            r = mid <span class="hljs-comment">#染蓝色</span><br>    <span class="hljs-keyword">return</span> r<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findPeakElement</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> lower_bound(nums)<br></code></pre></td></tr></table></figure>





<h2 id="153"><a href="#153" class="headerlink" title="153"></a>153</h2><p>原题链接： <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值 - 力扣（LeetCode）</a></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这题一共就两种情况，因为是对一个有序数组的旋转，看下面画的图</p>
<p>第一种情况很好解决，简单的二分，第二种情况需要分析一下</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405091804608.png" srcset="/img/loading.gif" lazyload alt="image-20240509180447566"></p>
<p>我们要找的相当于是谷底，也就是左右都比他大的</p>
<p><strong>红蓝染色法二分：</strong></p>
<ul>
<li>红色表示最小数的左边</li>
<li>蓝色表示最小数或者最小数的右边</li>
</ul>
<p>我们可以首先确定最后一个数一定是蓝色，所以开始的区间可以设为 [0,n-2]，这个区间是我们不知道要怎么染色的，接下来开始二分缩小这个区间</p>
<p>使用开区间来写的话，最初 l = -1，r = n-1</p>
<p><strong>那么我们怎么确定要染什么颜色？</strong></p>
<ul>
<li>通过已知条件来看，我们仿照上一题，让mid和mid+1来比较可以吗？显然是不行的，因为除了最小值旁边的元素其他位置都满足 num[mid] &lt; num[mid+1] ，无法根据这个来染色</li>
<li>可以根据 num[mid] 和 num[-1] (最后一个元素) 来比较<ul>
<li>如果 num[mid] &lt; num[-1]：由图可知，需要让 r = mid</li>
<li>如果 num[mid] &gt; num[-1]：由图可知：需要让 l = mid</li>
</ul>
</li>
</ul>
<p>最后返回值应该是什么呢，下标返回 r 即可</p>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这题不就是寻找谷值吗</span><br><span class="hljs-comment"># 红色表示谷左边</span><br><span class="hljs-comment"># 蓝色表示谷以及谷的右边</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">binsearch</span>(<span class="hljs-params">nums</span>):<br>    l = -<span class="hljs-number">1</span> <span class="hljs-comment"># [0,n-2]</span><br>    r = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> l+<span class="hljs-number">1</span> &lt; r:<br>        mid = (l+r) // <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[mid] &lt; nums[-<span class="hljs-number">1</span>]:<br>            r = mid <br>        <span class="hljs-keyword">else</span>:<br>            l = mid<br>    <span class="hljs-keyword">return</span> nums[r]<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findMin</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> binsearch(nums)<br></code></pre></td></tr></table></figure>

<p>思考：</p>
<p>边界条件，最小的在最右怎么办?</p>
<ul>
<li>这种情况由于一开始其实我们就给最右染色了，那么 r 一直是不会移动的，合理</li>
</ul>
<p>一般最大化最小值或者最小化最大值都可以用二分来做</p>
<h1 id="4-单调栈"><a href="#4-单调栈" class="headerlink" title="4.单调栈"></a>4.单调栈</h1><p>单调栈：如果你发现你要计算的内容和上一个更大（小）/下一个更大/（小）的元素有关，尝试单调栈</p>
<p>栈中保存有用的，维护它的单调性【这一点是最难的，你如果知道需要保留什么，就知道什么东西需要入栈，什么东西需要出栈，在什么时候计算答案】</p>
<p>可以在进栈 or 出栈的时候来做你想做的</p>
<p>原题链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/daily-temperatures/description/">739. 每日温度 - 力扣（LeetCode）</a></p>
<p>从左往右</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dailyTemperatures</span>(<span class="hljs-params">self, temperatures: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        st = [] <span class="hljs-comment"># st 存的下标</span><br>        ans = [<span class="hljs-number">0</span>]*<span class="hljs-built_in">len</span>(temperatures)<br>        <span class="hljs-keyword">for</span> i,x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(temperatures):<br>            <span class="hljs-keyword">while</span> st <span class="hljs-keyword">and</span> x &gt; temperatures[st[-<span class="hljs-number">1</span>]]:<br>                t = st.pop()<br>                ans[t] = i - t<br>            st.append(i)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure>



<p>从右往左：</p>
<p>现在的是 x，弹出栈中所有 &lt;= x的数（弹出意味着这些数没有用了，为什么呢，是因为x把右边的全部遮住了，我们左边的所有数的答案都不可能是和遮住的这些数有关）</p>
<p>那为什么比更大的数还要保留呢，如果一个数比x大并且小于这个栈顶更大的数，那么这个数的答案就是我们提到的更大的数</p>
<p>然后放入栈，x的答案是在发现栈为空（此时不用操作，初始化时已经设置为了0）或者栈顶元素比自己大了，此时可以算x对应的答案，然后放入x</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dailyTemperatures</span>(<span class="hljs-params">self, temperatures: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        st = [] <span class="hljs-comment"># st 存的下标</span><br>        n = <span class="hljs-built_in">len</span>(temperatures)<br>        ans = [<span class="hljs-number">0</span>]*n <span class="hljs-comment"># 这里的初始化很重要，对于没有下一个更高温度的，在下面是不会处理它的</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br>            x = temperatures[i]<br>            <span class="hljs-keyword">while</span> st <span class="hljs-keyword">and</span> x &gt;= temperatures[st[-<span class="hljs-number">1</span>]]: <span class="hljs-comment"># 注意这里要 x&gt;= 不然对于一样的会有错误比如 3,5,5,6,2</span><br>                t = st.pop()<br>            <span class="hljs-keyword">if</span> st:<br>                ans[i] = st[-<span class="hljs-number">1</span>] - i<br>            st.append(i)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure>

<p>注意最后，栈不一定是空的</p>
<p>个人更偏向从左往右</p>
<p>对栈顶元素找上一个更大的元素，在找的过程中填坑</p>
<p>横着计算，看成水泥，填平了，那么 &lt;= 自己的高度就不需要了，因为已经填平</p>
<p>需要的下标：当前元素的下标，栈顶元素的下标，栈顶元素的上一个的下标</p>
<p>这个栈里面存的是从右往左能看到的东西</p>
<p>每次必入栈，出栈不一定</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">trap</span>(<span class="hljs-params">self, height: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ans = <span class="hljs-number">0</span><br>        st = []<br>        <span class="hljs-keyword">for</span> i,x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(height):<br>            <span class="hljs-comment">#要找下一个更小和下一个&gt;=自己的</span><br>            <span class="hljs-comment"># 出栈的,清除掉 &lt;= x的</span><br>            left = <span class="hljs-number">0</span><br>            bottom = <span class="hljs-number">0</span><br>            right = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">while</span> st <span class="hljs-keyword">and</span>  x &gt;= height[st[-<span class="hljs-number">1</span>]]: <span class="hljs-comment">#这里 &gt; 或者 &gt;= 都可以，如果是&gt;=的话 min(right,left)-bottom 就等于 0 ，其实 &gt;= 更好，比如2,2,0,1，其</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(st) &gt;= <span class="hljs-number">2</span>:<br>                    bot = st.pop()<br>                    l = st[-<span class="hljs-number">1</span>] <span class="hljs-comment">#注意这个不能出栈，这个还有用，只有栈顶没用了，被水泥封上了</span><br>                    bottom = height[bot]<br>                    left = height[l]<br>                    right = x<br>                    ans += (<span class="hljs-built_in">min</span>(right,left)-bottom)*(i-l -<span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    st.pop()<br>            st.append(i)<br>        <span class="hljs-keyword">return</span> ans<br>                    <br></code></pre></td></tr></table></figure>

<p>时间复杂度</p>
<p><a target="_blank" rel="noopener" href="https://www.lanqiao.cn/problems/17152/learning/?page=3&first_category_id=1&second_category_id=3&tags=2023,%E5%9B%BD%E8%B5%9B">0最大区间 - 蓝桥云课 (lanqiao.cn)</a></p>
<p>需要特别注意，在数组的开头和末尾各自加上一个0 如果开头不加上0，会出现越界访问；如果末尾不加上0，会出现这种数据没有结果 5,1 2 3 4 5。原理是让最后一个0来让前面的所有没有更新的出栈更新至少一次</p>
<h1 id="5-单调队列"><a href="#5-单调队列" class="headerlink" title="5.单调队列"></a>5.单调队列</h1><blockquote>
<p>及时去掉无用数据，保证双端队列有序</p>
</blockquote>
<p>滑动窗口最大值</p>
<p>deque里面存的是下标</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxSlidingWindow</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        q = deque()<br>        ans = []<br>        <span class="hljs-keyword">for</span> i,x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            <span class="hljs-comment"># 出</span><br>            <span class="hljs-keyword">while</span> q <span class="hljs-keyword">and</span> x &gt;= nums[q[-<span class="hljs-number">1</span>]]:<br>                q.pop()<br><br>            <span class="hljs-comment"># 入</span><br>            q.append(i)<br>            <span class="hljs-comment">#最大下标 i-k+1</span><br>            <span class="hljs-comment">#为什么只看q[0]呢，因为我们只后移了一位相当于，只有队首有可能out了</span><br>            <span class="hljs-keyword">if</span> q[<span class="hljs-number">0</span>] &lt; i-k+<span class="hljs-number">1</span>: <br>                q.popleft()<br>            <span class="hljs-comment">#记录答案</span><br>            <span class="hljs-keyword">if</span> i&gt;=k-<span class="hljs-number">1</span>:<br>                ans.append(nums[q[<span class="hljs-number">0</span>]])<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure>

<p>复杂度：每个下标最多入队出队各一次，所以复杂度是O(n)</p>
<p>当前数字 &gt;= 队尾，弹出队尾</p>
<p>弹出队首不在窗口内的元素</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/description/">1438. 绝对差不超过限制的最长连续子数组 - 力扣（LeetCode）</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dq</span>(<span class="hljs-params">nums,limit</span>):<br>    q_min = deque()<br>    q_max = deque()<br>    ret =left= <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i,x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>        <span class="hljs-keyword">while</span> q_min <span class="hljs-keyword">and</span> x &lt; nums[q_min[-<span class="hljs-number">1</span>]]:<br>            q_min.pop()<br>        q_min.append(i)<br>        <span class="hljs-comment"># if q_min[0] &lt; i-k+1:</span><br>        <span class="hljs-comment">#     q_min.popleft()</span><br>        <br>        <span class="hljs-keyword">while</span> q_max <span class="hljs-keyword">and</span> x &gt; nums[q_max[-<span class="hljs-number">1</span>]]:<br>            q_max.pop()<br>        q_max.append(i)<br>        <span class="hljs-comment"># if q_max[0] &lt; i-k+1:</span><br>        <span class="hljs-comment">#     q_max.popleft()</span><br><br>        <span class="hljs-keyword">while</span> q_min <span class="hljs-keyword">and</span> q_max <span class="hljs-keyword">and</span>  nums[q_max[<span class="hljs-number">0</span>]]-nums[q_min[<span class="hljs-number">0</span>]] &gt; limit:<br>            <span class="hljs-keyword">if</span> nums[q_min[<span class="hljs-number">0</span>]] == nums[left]:<br>                q_min.popleft()<br>            <span class="hljs-keyword">if</span> nums[q_max[<span class="hljs-number">0</span>]] == nums[left]:<br>                q_max.popleft()<br>            left += <span class="hljs-number">1</span><br><br>        ret = <span class="hljs-built_in">max</span>(ret,i-left+<span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">return</span> ret<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestSubarray</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], limit: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 任意两个元素之间的绝对差必须小于或者等于 limit 转化为 最大最小之差 &lt;= limit</span><br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> :<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> dq(nums,limit)<br><br></code></pre></td></tr></table></figure>

<p>注意这是没有 k 限制的滑动窗口</p>
<p>然后 <code>ret = max(ret,i-left+1)</code> 这里不能写成 <code>ret = max(ret,i-min(q_max[0],q_min[0])+1)</code>，因为窗口最左端的索引有可能已经被顶掉了，看下面这个样例。 nums = [4,10,2,6,1] limit = 10</p>
<p>所以需要额外的信息来保存最左端的索引</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/solutions/2777332/ling-shen-ke-hou-zuo-ye-dan-diao-dui-lie-to7c/comments/2301234/">1438. 绝对差不超过限制的最长连续子数组 - 力扣（LeetCode）</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">https://leetcode.cn/problems/longest-substring-without-repeating-characters/</a>)</p>
<h1 id="6-字典树"><a href="#6-字典树" class="headerlink" title="6.字典树"></a>6.字典树</h1><p>注意下面所说的字母和字符串的区别</p>
<ol>
<li>把<strong>字符串</strong>按照前缀分组，第一个字母相同的，分到一组，第二个字母相同的，分到另一组….</li>
<li>用一颗树来实现</li>
<li>把每个<strong>字母</strong>对应到一颗树上的某个节点，保证对于每个字符串s内部，s[i]一定是s[i+1]的父节点</li>
</ol>
<p>字典树可以用来快速判断一个字符串是否是另一个字符串的前缀，但是没办法判断后缀</p>
<p>后缀可以转为前缀 ，从后往前建树和查找不就行了</p>
<p>可以用两个前缀树，但是可以转化，把这两个信息整合到一个pair</p>
<p>什么时候想到用字典树呢，分组，组里面还有更小的组，这种就可能需要树：本质就是用树来分组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.children = &#123;&#125;<br>        self.is_end_of = <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">self, word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        current = self<br>        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> word:<br>            <span class="hljs-keyword">if</span> char <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> current.children:<br>                current.children[char] = Trie()<br>            current = current.children[char]<br>        current.is_end_of = <span class="hljs-literal">True</span>    <br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        current = self<br>        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> word:<br>            <span class="hljs-keyword">if</span> char <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> current.children:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            current = current.children[char]<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span> <span class="hljs-keyword">if</span> current.is_end_of <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span><br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">startsWith</span>(<span class="hljs-params">self, prefix: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        current = self<br>        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> prefix:<br>            <span class="hljs-keyword">if</span> char <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> current.children:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            current = current.children[char]<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><br><span class="hljs-comment"># Your Trie object will be instantiated and called as such:</span><br><span class="hljs-comment"># obj = Trie()</span><br><span class="hljs-comment"># obj.insert(word)</span><br><span class="hljs-comment"># param_2 = obj.search(word)</span><br><span class="hljs-comment"># param_3 = obj.startsWith(prefix)</span><br></code></pre></td></tr></table></figure>



<p>入门字典树：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-trie-prefix-tree/description/">208. 实现 Trie (前缀树) - 力扣（LeetCode）</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-suffix-queries/solutions/2785807/zi-dian-shu-ban-zi-jie-ti-by-insist-w-rlfv/">3093. 最长公共后缀查询 - 力扣（LeetCode）</a></p>
<p><strong>最大异或和</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/description/">421. 数组中两个数的最大异或值 - 力扣（LeetCode）</a></p>
<h1 id="7-Z函数-扩展kmp"><a href="#7-Z函数-扩展kmp" class="headerlink" title="7.Z函数 扩展kmp"></a>7.Z函数 扩展kmp</h1><p>但实际上和kmp没什么关系</p>
<p>计算每个后缀能和字符串开头匹配多长</p>
<p>利用已经匹配的信息</p>
<p>z-box右侧的字符都是没有见过的</p>
<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><p>回溯三问！！！</p>
<ol>
<li>当前操作</li>
<li>子问题？</li>
<li>下一个子问题？</li>
</ol>
<h1 id="8-dp"><a href="#8-dp" class="headerlink" title="8.dp"></a>8.dp</h1><h2 id="如何手动记忆化搜索"><a href="#如何手动记忆化搜索" class="headerlink" title="如何手动记忆化搜索"></a>如何手动记忆化搜索</h2><p>核心是两点：</p>
<ul>
<li>dfs改成数组</li>
<li>递归改成循环</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 由于有两个背包，所以二维肯定不行</span><br><span class="hljs-comment"># 考虑用两个数组或者三维</span><br>n,a,b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())<br>nums = [<span class="hljs-number">0</span>]*n<br>nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split()))<br><span class="hljs-comment"># f[a][b][n] 表示余量为a,b，前n个物品的最大值</span><br>f = [[[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n+<span class="hljs-number">1</span>)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(b+<span class="hljs-number">1</span>)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(a+<span class="hljs-number">1</span>)]<br><br><br> <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i,j,k</span>):<br>   <span class="hljs-keyword">if</span> k&lt;<span class="hljs-number">0</span>:<br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>   <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> j &lt;<span class="hljs-number">0</span>:<br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>   <span class="hljs-keyword">if</span> f[i][j][k] != -<span class="hljs-number">1</span>:<br>     <span class="hljs-keyword">return</span> f[i][j][k]<br>   <span class="hljs-keyword">if</span> i &gt;= nums[k]:<br>     suma = <span class="hljs-built_in">max</span>(dfs(i,j,k-<span class="hljs-number">1</span>),dfs(i-nums[k],j,k-<span class="hljs-number">1</span>)+nums[k])<br>   <span class="hljs-keyword">else</span>:<br>     suma = dfs(i,j,k-<span class="hljs-number">1</span>)<br>   <span class="hljs-keyword">if</span> j &gt;= nums[k]:<br>     sumb = <span class="hljs-built_in">max</span>(dfs(i,j,k-<span class="hljs-number">1</span>),dfs(i,j-nums[k],k-<span class="hljs-number">1</span>)+nums[k])<br>   <span class="hljs-keyword">else</span>:<br>     sumb = dfs(i,j,k-<span class="hljs-number">1</span>)<br>   f[i][j][k] = <span class="hljs-built_in">max</span>(suma,sumb)<br>   <span class="hljs-keyword">return</span> f[i][j][k]<br></code></pre></td></tr></table></figure>

<p>注意看，<code>if f[i][j][k] != -1 return f[i][j][k]</code> 这一行就是利用记忆化搜索了</p>
<p>然后注意更新数组的位置<code> f[i][j][k] = max(suma,sumb)</code> 别忘记了</p>
<p>在每次return之前更新对应的dp数组，然后dp数组的初始值可以给一个不可能达到的值，后面判断是不是这个值就可以知道是否搜索过了，从而实现记忆化搜索</p>
<p>注意你的结果是return dfs的结果而不是dp数组</p>
<p>dfs.cache_clear()  # 防止爆内存</p>
<p>记忆化搜索：</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-number-of-ways-to-reach-the-k-th-stair/description/">3154. 到达第 K 级台阶的方案数 - 力扣（LeetCode）</a></p>
<p>注意如果很难确定数组大小，用hash表</p>
<p>注意遇到需要记录的dp数组，右边应该是dfs结果而不是dp数组结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#正确</span><br><span class="hljs-keyword">if</span> s[i] == s[j]:<br>    f[i][j] = dfs(i+<span class="hljs-number">1</span>,j-<span class="hljs-number">1</span>)+<span class="hljs-number">2</span><br>    <span class="hljs-keyword">return</span> f[i][j]<br><span class="hljs-comment">#错误</span><br><span class="hljs-keyword">if</span> s[i] == s[j]:<br>    f[i][j] = f[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+<span class="hljs-number">2</span><br>    <span class="hljs-keyword">return</span> f[i][j]<br><span class="hljs-comment">#然后要注意return的是 f[i][j] 而不是 dfs(i,j)不然又算了一遍哈，浪费时间</span><br></code></pre></td></tr></table></figure>



<p>记忆化搜索翻译为递推时，要注意循环的顺序，看你是从什么转移过来的</p>
<ul>
<li>从i+1这种更大的转移过来，那么就需要反序枚举</li>
<li>从i-1这种更小的转移过来，那么就需要正序枚举</li>
</ul>
<p>还要注意是否增加下标防止数组越界，也就是看有没有-1的出现和n的出现（数组最大下标为n-）</p>
<h2 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h2><p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405212349828.png" srcset="/img/loading.gif" lazyload alt="image-20240521234859561"></p>
<ul>
<li>恰好：dfs时必须等于0才记录答案</li>
<li>至多：dfs时&gt;=0记录答案，然后初始化要变一下</li>
<li>至少：这个没看懂</li>
</ul>
<p>看评论七水佬的总结</p>
<p>递推的初始值就是递归的边界</p>
<p>判断一维数组时是否需要反序遍历，自己根据状态转移方程列一个表来比较看一下</p>
<p>在只用一个一维数组的情况下，要注意转移来源 1. 不能被覆盖 2. 必须已经计算出来。按照这个要求，正序遍历会导致 0-1 背包状态被覆盖，而完全背包则是正确的（转移来源被计算出来，且不存在被覆盖的问题）；逆序遍历对于 0-1 背包是正确的（转移来源是上一行的，早就被计算出来了且没有被覆盖），而完全背包则不行（转移来源没有被计算出来）。</p>
<p>像这样画个图就很好理解</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405212359639.png" srcset="/img/loading.gif" lazyload alt="image-20240521235910512"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findTargetSumWays</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 假设添加+号的正数的和为p</span><br>        <span class="hljs-comment"># s为 sum(nums)</span><br>        <span class="hljs-comment"># 那么添加-号的负数绝对值之和就为 s-p</span><br>        <span class="hljs-comment"># 那么题意就转化为 p-(s-p) = t</span><br>        <span class="hljs-comment"># p = (s+t)/2，p是非负数，整数</span><br>        <span class="hljs-comment"># 那这样本题就变成了从nums中选择一些数，他们的和恰好为 (s+t)/2，这个固定的数</span><br>        <span class="hljs-comment"># 也就是背包问题</span><br>        target += <span class="hljs-built_in">sum</span>(nums)<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">if</span> target&lt;<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> target%<span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        target//=<span class="hljs-number">2</span><br>        <span class="hljs-comment"># def dfs(i,c):</span><br>        <span class="hljs-comment">#     if i &lt; 0:</span><br>        <span class="hljs-comment">#         return 1 if c == 0 else 0</span><br>        <span class="hljs-comment">#     if c &lt; nums[i]:</span><br>        <span class="hljs-comment">#         return dfs(i-1,c)</span><br>        <span class="hljs-comment">#     return dfs(i-1,c) + dfs(i-1,c-nums[i])</span><br>        <span class="hljs-comment"># return dfs(n-1,target)</span><br><br>        <span class="hljs-comment">#优化空间，每次只用到了i-1和i，那么第一个下标就只用2就好了，每次%2</span><br>        <span class="hljs-comment"># f = [[0]*(target+1) for _ in range(2)]</span><br>        <span class="hljs-comment"># f[0][0] = 1</span><br>        <span class="hljs-comment"># for i in range(1,n+1):</span><br>        <span class="hljs-comment">#     for c in range(target+1):</span><br>        <span class="hljs-comment">#         if c &lt; nums[i-1]:</span><br>        <span class="hljs-comment">#             f[i%2][c] = f[(i-1)%2][c]</span><br>        <span class="hljs-comment">#         else:</span><br>        <span class="hljs-comment">#             f[i%2][c] = f[(i-1)%2][c] + f[(i-1)%2][c-nums[i-1]]</span><br>        <span class="hljs-comment"># return f[n%2][target]</span><br><br>        <span class="hljs-comment"># 优化空间之一维</span><br>                <span class="hljs-comment">#优化空间，每次只用到了i-1和i，那么第一个下标就只用2就好了，每次%2</span><br>        f = [<span class="hljs-number">0</span>]*(target+<span class="hljs-number">1</span>)<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(target,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>): <span class="hljs-comment">#或者枚举范围 range(target,nums[i-1]-1,-1)，这样就不需要if了</span><br>                <span class="hljs-keyword">if</span> c &gt;= nums[i-<span class="hljs-number">1</span>]:<br>                    f[c] = f[c] + f[c-nums[i-<span class="hljs-number">1</span>]]<br>        <span class="hljs-keyword">return</span> f[target]<br></code></pre></td></tr></table></figure>





<p>类似背包问题循环顺序的思考：</p>
<p>假设你现在在c，要转移到<code>(i+1,c)</code>你转移的其中一个肯定是<code>(i,c)</code></p>
<p>那么对于另一个，如果你是从图中这两个蓝色框转移过来，那么需要倒序遍历</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405302351001.png" srcset="/img/loading.gif" lazyload alt="image-20240530235131706"></p>
<ul>
<li>左上蓝色圈分析：你需要从一个左边的旧值转移过来，你如果正序遍历，那么左边的旧值会被新值覆盖，导致错误</li>
<li>右下蓝色圈分析：你需要从一个右边的新值转移过来，如果正序遍历，你得到的右边的还没有更新，还是旧值</li>
</ul>
<p>如果是从这两个绿色框转移过来，那么需要正序遍历：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405302354265.png" srcset="/img/loading.gif" lazyload alt="image-20240530235422146"></p>
<ul>
<li>左下绿色圈分析：你需要从一个左边的新值转移过来，那么就要从左到右依次更新，如果你倒序遍历，左边的还是旧值没有更新</li>
<li>右上绿色圈分析：你需要一个右边的旧值转移过来，那么不能从右边更新过来，如果倒序遍历，右边的旧值会被新值覆盖，导致错误</li>
</ul>
<p>如果察觉到重复的子问题，就可以使用动态规划（记忆化搜索）</p>
<p>从第一个或者最后一个开始思考?</p>
<p>如何满足恰好？ 在dfs返回值的时候判断此时背包剩余容量是不是0</p>
<h2 id="线性dp"><a href="#线性dp" class="headerlink" title="线性dp"></a>线性dp</h2><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-operation-for-two-strings/">583. 两个字符串的删除操作</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/">712. 两个字符串的最小 ASCII 删除和</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a></li>
</ul>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></li>
</ul>
<p>前缀或者后缀</p>
<h2 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h2><p>不再是前缀或者后缀，而是数组中间的区间</p>
<p>核心思想是分治法？</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-score-triangulation-of-polygon/description/">1039. 多边形三角剖分的最低得分 - 力扣（LeetCode）</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/guess-number-higher-or-lower-ii/solutions/2793594/ling-shen-ke-hou-ti-da-qia-liang-chong-f-e83e/">375. 猜数字大小 II - 力扣（LeetCode）</a></p>
<h2 id="状态压缩dp"><a href="#状态压缩dp" class="headerlink" title="状态压缩dp"></a>状态压缩dp</h2><p>一般看到很小的数据范围，就有可能是一个状压dp，什么十几啊这种</p>
<h1 id="9-差分数组"><a href="#9-差分数组" class="headerlink" title="9.差分数组"></a>9.差分数组</h1><p><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/FfMCgb/">分享｜【算法小课堂】差分数组（Python/Java/C++/Go/JS） - 力扣（LeetCode）</a></p>
<p>优化对区间每个数都加/减同一个数的操作</p>
<p>记录变化量来优化</p>
<p>也可以这样理解，d[i] 表示把下标  &gt;= i 的数都加上 d[i]。</p>
<p><strong>性质 1</strong>：从左到右累加 𝑑 中的元素，可以得到数组 𝑎</p>
<p>代码模板</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 你有一个长为 n 的数组 a，一开始所有元素均为 0。</span><br><span class="hljs-comment"># 给定一些区间操作，其中 queries[i] = [left, right, x]，</span><br><span class="hljs-comment"># 你需要把子数组 a[left], a[left+1], ... a[right] 都加上 x。</span><br><span class="hljs-comment"># 返回所有操作执行完后的数组 a。</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solve</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span>, queries: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>    diff = [<span class="hljs-number">0</span>] * n  <span class="hljs-comment"># 差分数组</span><br>    <span class="hljs-keyword">for</span> left, right, x <span class="hljs-keyword">in</span> queries:<br>        diff[left] += x<br>        <span class="hljs-comment">#</span><br>        <span class="hljs-keyword">if</span> right + <span class="hljs-number">1</span> &lt; n:<br>            diff[right + <span class="hljs-number">1</span>] -= x<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>        diff[i] += diff[i - <span class="hljs-number">1</span>]  <span class="hljs-comment"># 直接在差分数组上复原数组 a</span><br>    <span class="hljs-keyword">return</span> diff<br></code></pre></td></tr></table></figure>



<p>这题目前还看不懂：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximize-the-minimum-powered-city/description/">2528. 最大化城市的最小电量 - 力扣（LeetCode）</a></p>
<h1 id="10-堆，优先队列"><a href="#10-堆，优先队列" class="headerlink" title="10.堆，优先队列"></a>10.堆，优先队列</h1><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/last-stone-weight/">1046. 最后一块石头的重量 - 力扣（LeetCode）</a></p>
<p>手写小顶堆：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/last-stone-weight/solutions/540369/python-zui-da-dui-diao-ku-shou-xie-shi-x-utdj/">1046. 最后一块石头的重量 - 力扣（LeetCode）</a></p>
<p>python库实现的是小顶堆：<code>heapq</code> 是 Python 中的一个内置模块（不需要导入？）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> heapq<br>a = []<br>heapq.heapify(a) <span class="hljs-comment">#将一个可迭代对象转换为堆数据结构</span><br>heapq.heappush(a,<span class="hljs-number">1</span>) <span class="hljs-comment">#向堆中添加一个新元素</span><br>heapq.heappop(a) <span class="hljs-comment">#从堆中弹出并返回最小元素</span><br>heapreplace(heap, item) <span class="hljs-comment">#弹出并返回最小元素，并将新元素推入堆中</span><br>nlargest(n, iterable) <span class="hljs-comment">#返回可迭代对象中的前 n 个最大元素</span><br>nsmallest(n, iterable) <span class="hljs-comment">#返回可迭代对象中的前 n 个最小元素</span><br></code></pre></td></tr></table></figure>

<p>堆顶就是第0个元素</p>
<p>如果你需要实现大顶堆（最大优先队列），可以通过将优先级的值取负来实现：</p>
<p><a target="_blank" rel="noopener" href="https://www.lanqiao.cn/problems/17120/learning/">0选段排序 - 蓝桥云课 (lanqiao.cn)</a></p>
<h1 id="11-树状数组，线段树"><a href="#11-树状数组，线段树" class="headerlink" title="11.树状数组，线段树"></a>11.树状数组，线段树</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ce411u7qP">https://www.bilibili.com/video/BV1ce411u7qP</a></p>
<p>动机，我们想修改一个点，然后查询某个区间的和</p>
<p>可选的方法：</p>
<ul>
<li>维护 $n^2$ 个区间的和：此时查询是 $O(1)$，但是更新某个点是$O(n^2)$</li>
<li>把每个区间分成单个，也就是[1,1], [2,2] .. [n,n]，这样的话更新某个点是$O(1)$，查询是$O(n)$</li>
</ul>
<p>这里查询和更新就像天平的两端，你需要做一个tradeoff</p>
<p>那么我们试着把维护的区间多一点，但是又不至于到 $n^2$ 个</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405292026288.png" srcset="/img/loading.gif" lazyload alt="image-20240529202553048"></p>
<p>像这张图一样：此时我们要查询某个区间的和，复杂度其实降到了$O(logn)$</p>
<p>上面看上去就像树形结构了，好了，此时你就发明了线段树了()</p>
<p>代码实现：</p>
<p>首先我们需要开多大的数组，图上面这个数组最下面一层16，然后8,4,2,1</p>
<p>$16+8+4+2+1=31$ </p>
<p>你的数组长度要差不多 $2^{n的二进制长度}*2$  或者 4n</p>
<p>把最下面一层补满</p>
<p>树状数组：单点更新，区间查询<br>线段树：区间更新（都加上一个数、把子数组内的元素取反），区间查询</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ywinh/TyporaImages@main/202405292226555.png" srcset="/img/loading.gif" lazyload alt="image-20240529222616388"></p>
<p>两大思想：</p>
<ol>
<li><p>挑选O(n)个特殊区间，使得任意一个区间可以拆分为O(logn)个特殊区间</p>
<p>特殊区间个数 &lt;= 4n </p>
<p>最坏情况下，左边走到叶子结点，右边走到叶子结点，一共就拆分了2*树高 = 2 *logn个区间，也可以最近公共祖先来思考</p>
</li>
</ol>
<p>o 表示结点编号</p>
<p>特别注意：<strong>由于o和0离得比较近切像，不要打错了！</strong>！！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">o:<span class="hljs-built_in">int</span>, l:<span class="hljs-built_in">int</span>, r:<span class="hljs-built_in">int</span></span>):<span class="hljs-comment">#相当于自底向上建树</span><br>    <span class="hljs-keyword">if</span> l==r:<br>        <span class="hljs-comment">#更新...</span><br>        d[o] = a[l]<br>        <span class="hljs-keyword">return</span><br>    m = l+r&gt;&gt;<span class="hljs-number">1</span><br>    <span class="hljs-comment">#递归对左右区间建树</span><br>    build(o*<span class="hljs-number">2</span>,l,m)<br>    build(o*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,m+<span class="hljs-number">1</span>,r)<br>    <span class="hljs-comment">#维护...</span><br>    d[o] = d[o*<span class="hljs-number">2</span>] + d[o*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]<br><br><span class="hljs-comment">#区间查询</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getsum</span>(<span class="hljs-params">o:<span class="hljs-built_in">int</span>, l:<span class="hljs-built_in">int</span>, r:<span class="hljs-built_in">int</span>, L:<span class="hljs-built_in">int</span>, R:<span class="hljs-built_in">int</span></span>)-&gt;<span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># [L,R]表示固定的你需要查询的区间</span><br>    <span class="hljs-comment"># [l,r]表示当前节点包含区间</span><br>    <span class="hljs-keyword">if</span> L&lt;=l <span class="hljs-keyword">and</span> r&lt;=R: <br>        <span class="hljs-keyword">return</span> d[o] <span class="hljs-comment">#当前区间为询问区间的子集时直接返回当前区间的和</span><br>    m = l+r&gt;&gt;<span class="hljs-number">1</span><br>    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 如果左儿子代表的区间 [l, m] 与询问区间有交集, 则递归查询左儿子</span><br>    <span class="hljs-keyword">if</span> L&lt;=m:<span class="hljs-built_in">sum</span>+=getsum(o,l,m,L,R)<br>    <span class="hljs-comment"># 如果右儿子代表的区间 [m+1, r] 与询问区间有交集, 则递归查询左儿子</span><br>    <span class="hljs-keyword">if</span> m+<span class="hljs-number">1</span>&lt;=R:<span class="hljs-built_in">sum</span>+=getsum(o,m+<span class="hljs-number">1</span>,r,L,R)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span><br>    <br>    <br>    <span class="hljs-comment">#[L,R]表示固定的，你需要update的区间</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">o:<span class="hljs-built_in">int</span>, l:<span class="hljs-built_in">int</span>, r:<span class="hljs-built_in">int</span>, L:<span class="hljs-built_in">int</span>, R:<span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-keyword">if</span> L&lt;=l <span class="hljs-keyword">and</span> r&lt;=R: <br>        <span class="hljs-comment">#更新...</span><br>        <span class="hljs-keyword">return</span><br>    m = l+r&gt;&gt;<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> m&gt;=L:update(o*<span class="hljs-number">2</span>,l,m,L,R)<br>    <span class="hljs-keyword">if</span> m+<span class="hljs-number">1</span>&lt;=R:update(o*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,m+<span class="hljs-number">1</span>,r,L,R)<br>    <span class="hljs-comment">#维护...</span><br></code></pre></td></tr></table></figure>



<p>单点修改不用lazy？区间修改才用lazy</p>
<blockquote>
<p>单点修改直接到底了 不需要lazy延迟?</p>
</blockquote>
<p>lazy更新</p>
<p>如果说我要更新的区间被完全包含在了这次更新的区间内，那就不继续往下走，而是添加一个lazy tag</p>
<p>如果这个区间在后续的更新、查询被破坏掉了，就把lazy tag往下传</p>
<p>lazy标记下，区间修改和查询操作的实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python">todo = [<span class="hljs-number">0</span>]*<span class="hljs-number">4</span>*n <span class="hljs-comment">#todo数组表示lazy标记</span><br><span class="hljs-comment">#注意lazy tag打在的这个区间是已经更新了的，只是他的自区间还没有更新</span><br><br><span class="hljs-comment"># 区间修改</span><br><span class="hljs-comment"># c表示被修改区间的变化量</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">o:<span class="hljs-built_in">int</span>, l:<span class="hljs-built_in">int</span>, r:<span class="hljs-built_in">int</span>, L:<span class="hljs-built_in">int</span>, R:<span class="hljs-built_in">int</span>, c:<span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-keyword">if</span> L&lt;=l <span class="hljs-keyword">and</span> r&lt;=R: <span class="hljs-comment"># 当前区间为修改区间的子集时直接修改当前节点的值,然后打标记,结束修改</span><br>        d[o] += (r-l+<span class="hljs-number">1</span>)*c<br>        todo[o] += c<br>        <span class="hljs-keyword">return</span> <br>    m=l+r&gt;&gt;<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> todo[o] <span class="hljs-keyword">and</span> l!=r: <span class="hljs-comment">#如果当前节点的懒标记非空,则更新当前节点两个子节点的值和懒标记值</span><br>        <span class="hljs-comment">#如果l==r代表到了叶结点，下面没有子节点了，不用更新子节点</span><br>        <span class="hljs-comment">#更新当前节点两个子结点的值</span><br>        d[o*<span class="hljs-number">2</span>] += todo[o]*(m-l+<span class="hljs-number">1</span>)<br>        d[o*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>] += todo[o]*(r-m)<br>        <span class="hljs-comment"># 将标记下传给子节点</span><br>        todo[o*<span class="hljs-number">2</span>] += todo[o]<br>        todo[o*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>] += todo[o]<br>        <span class="hljs-comment">#清空当前节点的标记</span><br>        todo[o] = <span class="hljs-number">0</span><br>        <br>    <span class="hljs-keyword">if</span> m&gt;=L:update(o*<span class="hljs-number">2</span>,l,m,L,R,c)<br>    <span class="hljs-keyword">if</span> m+<span class="hljs-number">1</span>&lt;=R:update(o*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,m+<span class="hljs-number">1</span>,r,L,R,c)<br>    d[o] = d[o*<span class="hljs-number">2</span>]+d[o*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]<br>    <br><span class="hljs-comment">#区间查询</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getsum</span>(<span class="hljs-params">o:<span class="hljs-built_in">int</span>, l:<span class="hljs-built_in">int</span>, r:<span class="hljs-built_in">int</span>, L:<span class="hljs-built_in">int</span>, R:<span class="hljs-built_in">int</span></span>)-&gt;<span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">if</span> L&lt;=l <span class="hljs-keyword">and</span> r&lt;=R:<br>        <span class="hljs-keyword">return</span> d[o]<br>    m = l+r&gt;&gt;<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> todo[o]:<br>        d[o*<span class="hljs-number">2</span>] += todo[o]*(m-l+<span class="hljs-number">1</span>)<br>        d[o*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>] += todo[o]*(r-m)<br>        todo[o*<span class="hljs-number">2</span>] += todo[o]<br>        todo[o*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>] += todo[o]<br>        todo[o] = <span class="hljs-number">0</span><br>    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> m&gt;=L: <span class="hljs-built_in">sum</span>+=getsum(o*<span class="hljs-number">2</span>,l,m,L,R)<br>    <span class="hljs-keyword">if</span> m+<span class="hljs-number">1</span>&lt;=R:<span class="hljs-built_in">sum</span>+=getsum(o*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,m+<span class="hljs-number">1</span>,r,L,R)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span><br></code></pre></td></tr></table></figure>



<p>如果要实现区间修改为某个值而不是加上某一个值的话：把<code>+=</code>改为<code>=</code></p>
<p>注意，下面这个是oi-wiki的模板，不是我的，等待修改为我的版本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">o:<span class="hljs-built_in">int</span>, l:<span class="hljs-built_in">int</span>, r:<span class="hljs-built_in">int</span>, L:<span class="hljs-built_in">int</span>, R:<span class="hljs-built_in">int</span>, c:<span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-keyword">if</span> L&lt;=l <span class="hljs-keyword">and</span> r&lt;=R:<br>        d[o]<br></code></pre></td></tr></table></figure>





<h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><p>灵神主页题单：<a target="_blank" rel="noopener" href="https://leetcode.cn/u/endlesscheng/">灵茶山艾府 - 力扣（LeetCode）</a> 在讨论发布里面</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/CaOJ45/">分享｜从集合论到位运算，常见位运算技巧分类总结！ - 力扣（LeetCode）</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c">n,p,q = <span class="hljs-built_in">map</span>(<span class="hljs-type">int</span>,input().split())<br><br>f = [<span class="hljs-number">0</span>] + <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-type">int</span>,input().split()))<br><br># 求f[q]-f[p]的最大值，选一段来排序<br># 先向着左边扩展 [p,q]扩展为[<span class="hljs-number">0</span>,q]<br># 双堆模拟，大根堆，小根堆<br># 其实不用小根堆<br>mint = inf<br>maxt = <span class="hljs-number">0</span><br><br>h2 = [] #大根堆，存的相反数<br><span class="hljs-keyword">for</span> i in range(p,q+<span class="hljs-number">1</span>):<br>  maxt = max(maxt,f[i])<br>  mint = min(mint,f[i])<br>  heapq.heappush(h2,-f[i])<br>res = maxt-mint<br>#开始向右扩展<br><span class="hljs-keyword">for</span> i in range(q+<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):<br>  # 找此时的最小值，也就是f[p]<br>  mint = min(mint,f[i])<br>  # 找此时的最大值，也就是f[q]<br>  # 取出大根堆top<br>  heapq.heappush(h2,-f[i])<br>  heapq.heappop(h2)<br>  maxt = -h2[<span class="hljs-number">0</span>]<br>  res = max(res,maxt-mint)<br><br>h2 = [] #大根堆，存的相反数<br><span class="hljs-keyword">for</span> i in range(p,q+<span class="hljs-number">1</span>):<br>  maxt = max(maxt,f[i])<br>  mint = min(mint,f[i])<br>  heapq.heappush(h2,f[i])<br><br>#向左拓展<br><span class="hljs-keyword">for</span> i in range(p<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>):<br>  maxt = max(f[i],maxt)<br>  heapq.heappush(h2,f[i])<br>  heapq.heappop(h2)<br>  mint = h2[<span class="hljs-number">0</span>]<br>  res = max(res,maxt-mint)<br><br>print(res)<br></code></pre></td></tr></table></figure>


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>算法笔记-杂乱版持续更新</div>
      <div>http://example.com/2024/05/31/算法笔记-杂乱版持续更新/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Jianhui Yin</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>May 31, 2024</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/06/08/xv6-lab-trap/" title="xv6-lab-trap">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">xv6-lab-trap</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/05/28/xv6-locks/" title="xv6-locks">
                        <span class="hidden-mobile">xv6-locks</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>rain</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
